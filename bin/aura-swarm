#!/usr/bin/env python3
"""
aura-swarm — Unified agent orchestration for Claude Code.

Supports two modes:
  - worktree (default): Creates isolated git worktree, discovers beads tasks,
    launches Claude with full epic context.
  - intree: Launches Claude agents in-place (no worktree), requires --prompt.

Branch model (worktree mode):
    main
     └── epic/<epic-id>                 (aura-swarm creates this branch + worktree)
           ├── agent/<task-id-1>         (Claude's Agent Teams creates these)
           ├── agent/<task-id-2>
           └── agent/<task-id-3>

Usage:
    # Worktree mode (default)
    aura-swarm start --epic aura-dyu --model sonnet
    aura-swarm start --epic aura-dyu --restart

    # Intree mode (replaces aura-parallel)
    aura-swarm start --swarm-mode intree --role supervisor -n 1 --prompt "..."
    aura-swarm start --swarm-mode intree --role worker -n 3 --task-id t1 --task-id t2 --task-id t3 --prompt "..."

    # Window mode (accumulate agents in one tmux session)
    aura-swarm start --epic aura-dyu --tmux-dest window -n 2

    # Management
    aura-swarm status
    aura-swarm attach aura-dyu
    aura-swarm stop aura-dyu
    aura-swarm merge aura-dyu
    aura-swarm review --epic aura-dyu
    aura-swarm cleanup aura-dyu
    aura-swarm cleanup --done
    aura-swarm cleanup --all
"""

from __future__ import annotations

# Read PACKAGE_SKILLS_DIR from env var (set by Nix writeShellApplication wrapper)
# or fall back to the sentinel for source-checkout mode.
import os

PACKAGE_SKILLS_DIR = os.environ.get("AURA_PACKAGE_SKILLS_DIR", "__AURA_PACKAGE_SKILLS_DIR__")

import argparse
import hashlib
import json
import secrets
import signal
import subprocess
import sys
import textwrap
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, NamedTuple

from aura_protocol.session_registry import (
    ModelTier,
    PermissionMode,
    SessionRecord,
    SessionRole,
    SessionStatus,
    SwarmMode,
    TmuxDest,
    YAMLSessionRegistry,
    is_pid_alive,
)


# ──────────────────────────────────────────────
# Constants
# ──────────────────────────────────────────────

VALID_ROLES = frozenset(SessionRole)
VALID_MODELS = frozenset(ModelTier)
VALID_PERMISSION_MODES = frozenset(PermissionMode)
AURA_PROMPT_STATE_DIR = Path.home() / ".local" / "share" / "aura" / "aura-swarm" / "prompts"
DEFAULT_WORKTREE_DIR = SwarmMode.WORKTREE
DEFAULT_ROLE = SessionRole.SUPERVISOR
DEFAULT_MODEL = ModelTier.SONNET

_interrupted = False


# ──────────────────────────────────────────────
# Data types
# ──────────────────────────────────────────────


class LaunchResult(NamedTuple):
    """Result of launching a tmux session or window."""

    session_name: str
    success: bool
    error: str | None = None
    prompt_path: Path | None = None


class BeadTask(NamedTuple):
    """Minimal representation of a beads task for prompt building."""

    id: str
    title: str
    description: str
    status: str
    dependencies: list[str]
    relation: str  # "blocker" (blocks the epic) or "dependent" (blocked by the epic)


# ──────────────────────────────────────────────
# Helpers
# ──────────────────────────────────────────────


def signal_handler(signum: int, frame: Any) -> None:
    global _interrupted
    _interrupted = True
    print("\nInterrupted.", file=sys.stderr)


def run_command(
    cmd: list[str], *, capture: bool = False, cwd: str | Path | None = None
) -> subprocess.CompletedProcess[str]:
    if capture:
        return subprocess.run(cmd, capture_output=True, text=True, cwd=cwd)
    return subprocess.run(cmd, text=True, cwd=cwd)


def get_git_root() -> Path | None:
    result = run_command(["git", "rev-parse", "--show-toplevel"], capture=True)
    if result.returncode == 0:
        return Path(result.stdout.strip())
    return None


def check_tmux_session_exists(session_name: str) -> bool:
    result = run_command(["tmux", "has-session", "-t", session_name], capture=True)
    return result.returncode == 0


def generate_session_name(
    role: str, epic_suffix: str, num: int, task_id: str | None, max_retries: int = 5
) -> str:
    """Generate unique session name: {role}-{epic_suffix}--{hex4} or with task_id."""
    for _ in range(max_retries):
        hex4 = secrets.token_hex(2)
        if task_id:
            name = f"{role}-{num}--{hex4}--{task_id}"
        elif epic_suffix:
            name = f"{role}-{epic_suffix}--{hex4}"
        else:
            name = f"{role}-{num}--{hex4}"
        if not check_tmux_session_exists(name):
            return name
    raise RuntimeError(f"Failed to generate unique session name after {max_retries} retries")


def generate_window_name(role: str, num: int, task_id: str | None) -> str:
    """Generate tmux window name for window mode."""
    hex4 = secrets.token_hex(2)
    if task_id:
        return f"{role}-{num}--{task_id}"
    return f"{role}-{num}--{hex4}"


def get_epic_suffix(epic_id: str) -> str:
    """Extract suffix from epic ID (e.g. 'aura-dyu' -> 'dyu')."""
    parts = epic_id.split("-", 1)
    return parts[1] if len(parts) > 1 else epic_id


def get_role_instructions(role: str, working_dir: Path) -> tuple[str | None, Path | None]:
    """Load role instructions from skills/{role}/SKILL.md.

    Search order (first match wins):
      1. {working_dir}/skills/{role}/SKILL.md  — project-local override
      2. {script_dir}/../skills/{role}/SKILL.md — relative to script (source checkout)
      3. {PACKAGE_SKILLS_DIR}/{role}/SKILL.md   — package-bundled (Nix store)

    Returns (content, path) tuple. Both are None if not found.
    """
    skill_file = f"skills/{role}/SKILL.md"

    # 1. Project-local override
    local_path = working_dir / skill_file
    if local_path.exists():
        return local_path.read_text(), local_path

    # 2. Relative to script location (works from source checkout)
    script_path = Path(__file__).resolve().parent.parent / skill_file
    if script_path.exists():
        return script_path.read_text(), script_path

    # 3. Package-bundled skills (Nix store path or env var)
    pkg_path = Path(PACKAGE_SKILLS_DIR) / f"{role}/SKILL.md"
    if pkg_path.exists():
        return pkg_path.read_text(), pkg_path

    return None, None


def write_prompt_file(prompt: str) -> Path:
    """Write prompt to ~/.local/share/aura/aura-swarm/prompts/.

    Returns the absolute Path. Files persist as an audit trail.
    """
    AURA_PROMPT_STATE_DIR.mkdir(parents=True, exist_ok=True)
    timestamp = datetime.now(timezone.utc).strftime("%Y%m%dT%H%M%SZ")
    hex4 = secrets.token_hex(2)
    prompt_path = AURA_PROMPT_STATE_DIR / f"{timestamp}-{hex4}-prompt.md"
    prompt_path.write_text(prompt)
    return prompt_path


def branch_exists(branch: str, *, cwd: str | Path | None = None) -> bool:
    result = run_command(
        ["git", "rev-parse", "--verify", f"refs/heads/{branch}"],
        capture=True,
        cwd=cwd,
    )
    return result.returncode == 0


def branch_merged_into_main(branch: str, *, cwd: str | Path | None = None) -> bool:
    """Check if branch is merged into main (or master)."""
    for main_branch in ("main", "master"):
        result = run_command(
            ["git", "merge-base", "--is-ancestor", branch, main_branch],
            capture=True,
            cwd=cwd,
        )
        if result.returncode == 0:
            return True
    return False


def worktree_is_dirty(worktree_path: Path) -> bool:
    result = run_command(
        ["git", "-C", str(worktree_path), "status", "--porcelain"],
        capture=True,
    )
    return bool(result.stdout.strip())


def check_prerequisites(swarm_mode: str, has_epic: bool) -> list[str]:
    """Check that required tools are on PATH. Returns list of errors.

    In intree mode without --epic, bd is not required.
    """
    errors: list[str] = []
    required = ["git", "tmux"]
    if swarm_mode == SwarmMode.WORKTREE or has_epic:
        required.append("bd")

    for tool in required:
        result = run_command(["which", tool], capture=True)
        if result.returncode != 0:
            errors.append(f"Required tool not found: {tool}")

    return errors


def validate_permission_mode(mode: str) -> str | None:
    """Validate permission mode, returning error message or None."""
    if "dangerously" in mode.lower() or "skip" in mode.lower():
        return (
            "SECURITY ERROR: 'dangerously-skip-permissions' mode is explicitly forbidden. "
            f"Allowed modes: {', '.join(sorted(VALID_PERMISSION_MODES))}"
        )
    if mode not in VALID_PERMISSION_MODES:
        return f"Invalid permission mode '{mode}'. Allowed: {', '.join(sorted(VALID_PERMISSION_MODES))}"
    return None


def detect_parent_permission(registry: YAMLSessionRegistry) -> str | None:
    """Detect permission mode from parent tmux session via registry lookup.

    Returns the parent's permission_mode if $TMUX is set and parent is found
    in registry with bypassPermissions. Returns None otherwise.
    """
    tmux_env = os.environ.get("TMUX")
    if not tmux_env:
        return None

    result = run_command(
        ["tmux", "display-message", "-p", "#{session_name}"],
        capture=True,
    )
    if result.returncode != 0:
        return None

    parent_session_name = result.stdout.strip()
    if not parent_session_name:
        return None

    # Look up parent in registry
    for record in registry.list_active():
        if record.tmux_session == parent_session_name:
            if record.permission_mode == PermissionMode.BYPASS_PERMISSIONS:
                return PermissionMode.BYPASS_PERMISSIONS
            break

    return None


# ──────────────────────────────────────────────
# Beads helpers
# ──────────────────────────────────────────────


def bd_show_json(task_id: str) -> dict[str, Any] | None:
    """Run `bd show <id> --json` and return parsed JSON, or None on failure."""
    result = run_command(["bd", "show", task_id, "--json"], capture=True)
    if result.returncode != 0:
        return None
    try:
        data = json.loads(result.stdout)
        if isinstance(data, list) and len(data) > 0:
            return data[0]
        return data
    except json.JSONDecodeError:
        return None


URD_LABEL = "aura:user:reqs"
URD_TITLE_PREFIX = "[aura:user:reqs]"


def _is_urd(task: dict[str, Any]) -> bool:
    """Check if a task is a User Requirements Document by label or title convention."""
    labels = task.get("labels") or []
    if URD_LABEL in labels:
        return True
    title = task.get("title", "")
    if title.startswith(URD_TITLE_PREFIX):
        return True
    return False


def discover_urd(epic_id: str, explicit_urd: str | None) -> str | None:
    """Discover the User Requirements Document task for an epic."""
    if explicit_urd:
        return explicit_urd

    epic = bd_show_json(epic_id)
    if epic is None:
        return None

    visited: set[str] = set()
    to_check: list[str] = []

    for dep in epic.get("dependencies", []):
        if isinstance(dep, dict) and "id" in dep:
            if _is_urd(dep):
                return dep["id"]
            to_check.append(dep["id"])
            visited.add(dep["id"])

    for dep_id in to_check:
        dep_data = bd_show_json(dep_id)
        if dep_data is None:
            continue
        for related in dep_data.get("dependencies", []):
            if isinstance(related, dict) and "id" in related:
                rid = related["id"]
                if rid in visited or rid == epic_id:
                    continue
                visited.add(rid)
                if _is_urd(related):
                    return rid

    return None


def _extract_ids(entries: list[Any]) -> list[str]:
    return [d["id"] for d in entries if isinstance(d, dict) and "id" in d]


def discover_tasks(epic_id: str, explicit_task_ids: list[str] | None) -> list[BeadTask]:
    """Discover tasks for an epic."""
    if explicit_task_ids:
        id_to_relation = {tid: "blocker" for tid in explicit_task_ids}
    else:
        epic = bd_show_json(epic_id)
        if epic is None:
            print(f"Warning: Could not fetch epic {epic_id} from beads", file=sys.stderr)
            return []

        id_to_relation: dict[str, str] = {}
        for d in epic.get("dependencies", []):
            if isinstance(d, dict) and "id" in d:
                id_to_relation[d["id"]] = "blocker"
        for d in epic.get("dependents", []):
            if isinstance(d, dict) and "id" in d and d["id"] not in id_to_relation:
                id_to_relation[d["id"]] = "dependent"

        if id_to_relation:
            blockers = [tid for tid, r in id_to_relation.items() if r == "blocker"]
            dependents = [tid for tid, r in id_to_relation.items() if r == "dependent"]
            if blockers:
                print(f"  Blockers (must complete first): {', '.join(blockers)}")
            if dependents:
                print(f"  Dependents (downstream work):   {', '.join(dependents)}")

    tasks: list[BeadTask] = []
    for tid, relation in id_to_relation.items():
        data = bd_show_json(tid)
        if data is None:
            print(f"Warning: Could not fetch task {tid}", file=sys.stderr)
            continue
        dep_ids = _extract_ids(data.get("dependencies", []))
        tasks.append(
            BeadTask(
                id=data["id"],
                title=data.get("title", ""),
                description=data.get("description", ""),
                status=data.get("status", "unknown"),
                dependencies=dep_ids,
                relation=relation,
            )
        )
    return tasks


# ──────────────────────────────────────────────
# Prompt builders
# ──────────────────────────────────────────────


PROMPT_TEMPLATE = """\
You are implementing Epic {epic_id}: "{epic_title}"
{urd_section}
## Context Discovery

Before starting, gather full context on the epic and each task using beads:

```bash
# Epic overview (description, dependencies, dependents)
bd show {epic_id}
{urd_show_command}
# Individual task details (description, acceptance criteria, design)
{task_show_commands}
```

## Tasks to Implement

{task_table}

## Instructions

Use Agent Teams (TeamCreate) to coordinate implementation of these tasks.

### Task Assignment
- When assigning a task to a worker, register ownership in beads:
  `bd update <task-id> --assignee "<worker-agent-name>"`
- Then track progress: `bd update <task-id> --status=in_progress` when starting, `bd close <task-id>` when done

### Worker Guidelines
- Create worker agents for each task
- Each worker MUST create and work in its own worktree:
  `git worktree add worktree/agent/<task-id> -b agent/<task-id> {epic_branch}`
  The worker's working directory should be `worktree/agent/<task-id>`
- Workers should run `bd show <their-task-id>` to get full requirements before starting
- Run `npm run typecheck && npm run test` before completing each task
- Use `git agent-commit` for commits (not `git commit`)
- Follow the constraints in CLAUDE.md and CONSTRAINTS.md
- When a task is done, merge the agent branch back into `{epic_branch}`
{urd_instructions}"""


def build_task_table(tasks: list[BeadTask]) -> str:
    """Build a compact markdown table of tasks."""
    lines = [
        "| ID | Title | Status | Relation | Dependencies |",
        "|----|-------|--------|----------|--------------|",
    ]
    for t in tasks:
        deps = ", ".join(t.dependencies) if t.dependencies else "-"
        lines.append(f"| {t.id} | {t.title} | {t.status} | {t.relation} | {deps} |")
    return "\n".join(lines)


def build_worktree_prompt(
    epic_id: str,
    epic_data: dict[str, Any],
    tasks: list[BeadTask],
    urd_id: str | None,
) -> str:
    """Build a rich prompt for worktree mode (auto-discovers beads context)."""
    task_show_commands = "\n".join(f"bd show {t.id}" for t in tasks)
    task_table = build_task_table(tasks)

    if urd_id:
        urd_section = f"\n**User Requirements Document:** `{urd_id}` — ALL requirements must be met and validated.\n"
        urd_show_command = f"\n# User Requirements Document (MUST satisfy all requirements)\nbd show {urd_id}\n"
        urd_instructions = (
            "\n### Requirements Validation\n"
            f"- The User Requirements Document is `{urd_id}` — run `bd show {urd_id}` to read it\n"
            "- Before claiming completion, verify EVERY requirement in the URD is met\n"
            "- Each worker must check their task's output against the relevant URD requirements\n"
        )
    else:
        urd_section = (
            "\n**User Requirements Document:** Not yet identified — you MUST locate it before starting work.\n"
        )
        urd_show_command = (
            "\n# Find the User Requirements Document\n"
            '# Search beads for URD tasks (by label or title convention):\n'
            'bd list --title-contains "user:reqs" --limit 10\n'
            'bd list --label-any "aura:user:reqs" --limit 10\n'
            "# Also check docs/ for requirement markdown files:\n"
            "# ls docs/urd-*.md\n"
        )
        urd_instructions = (
            "\n### Requirements Validation\n"
            "- The User Requirements Document was NOT automatically found\n"
            "- Before starting implementation, locate the URD using the discovery commands above\n"
            "- Check beads tasks AND `docs/urd-*.md` files for requirements related to this epic\n"
            "- ALL requirements in the URD must be met and validated before claiming completion\n"
            "- Each worker must check their task's output against the relevant URD requirements\n"
        )

    return PROMPT_TEMPLATE.format(
        epic_id=epic_id,
        epic_title=epic_data.get("title", ""),
        epic_branch=f"epic/{epic_id}",
        task_show_commands=task_show_commands,
        task_table=task_table,
        urd_section=urd_section,
        urd_show_command=urd_show_command,
        urd_instructions=urd_instructions,
    )


def build_intree_prompt(
    base_prompt: str,
    skill: str | None,
    task_ids: list[str] | None,
) -> str:
    """Build prompt for intree mode (adapted from aura-parallel)."""
    parts: list[str] = []

    if skill:
        if skill.startswith("aura:"):
            parts.append(f"1. Use Skill(/{skill})")
        else:
            parts.append(f"1. Use Skill(/aura:{skill})")
        parts.append("")

    parts.append(base_prompt)

    if task_ids:
        parts.append("")
        if len(task_ids) == 1:
            parts.append(f"Task ID: {task_ids[0]}")
        else:
            parts.append("Task IDs:")
            for tid in task_ids:
                parts.append(f"  - {tid}")

    return "\n".join(parts)


# ──────────────────────────────────────────────
# Tmux launch functions
# ──────────────────────────────────────────────


def _build_claude_cmd(
    model: str,
    instructions_path: Path,
    prompt_path: Path,
    permission_mode: str,
) -> str:
    """Build the claude CLI command string for tmux."""
    claude_cmd = (
        f"claude --model {model} "
        f"--append-system-prompt \"$(cat '{instructions_path}')\" "
        f"--permission-mode {permission_mode} "
        f"\"$(cat '{prompt_path}')\""
    )
    return f"{claude_cmd}; echo ''; echo 'Session complete. Press Enter to close.'; read"


def launch_tmux_session(
    *,
    session_name: str,
    working_dir: Path,
    instructions_path: Path,
    prompt: str,
    model: str,
    permission_mode: str = PermissionMode.ACCEPT_EDITS,
) -> LaunchResult:
    """Launch a Claude agent in a detached tmux session."""
    try:
        prompt_path = write_prompt_file(prompt)
    except OSError as e:
        return LaunchResult(session_name, success=False, error=f"Failed to write prompt file: {e}")

    full_cmd = _build_claude_cmd(model, instructions_path, prompt_path, permission_mode)

    tmux_cmd = [
        "tmux", "new-session", "-d",
        "-s", session_name,
        "-c", str(working_dir),
        full_cmd,
    ]

    if check_tmux_session_exists(session_name):
        return LaunchResult(session_name, success=False, error=f"Session '{session_name}' already exists")

    result = run_command(tmux_cmd, capture=True)
    if result.returncode != 0:
        error_msg = result.stderr.strip() if result.stderr else "Unknown error"
        return LaunchResult(session_name, success=False, error=error_msg)

    return LaunchResult(session_name, success=True, prompt_path=prompt_path)


def launch_in_tmux_window(
    *,
    tmux_session: str,
    window_name: str,
    working_dir: Path,
    instructions_path: Path,
    prompt: str,
    model: str,
    permission_mode: str = PermissionMode.ACCEPT_EDITS,
) -> LaunchResult:
    """Launch a Claude agent as a window in an existing (or new) tmux session.

    If the session exists, adds a new window. Otherwise creates the session
    with the window as its initial window.
    """
    try:
        prompt_path = write_prompt_file(prompt)
    except OSError as e:
        return LaunchResult(window_name, success=False, error=f"Failed to write prompt file: {e}")

    full_cmd = _build_claude_cmd(model, instructions_path, prompt_path, permission_mode)

    if check_tmux_session_exists(tmux_session):
        tmux_cmd = [
            "tmux", "new-window",
            "-t", tmux_session,
            "-c", str(working_dir),
            "-n", window_name,
            full_cmd,
        ]
    else:
        tmux_cmd = [
            "tmux", "new-session", "-d",
            "-s", tmux_session,
            "-c", str(working_dir),
            "-n", window_name,
            full_cmd,
        ]

    result = run_command(tmux_cmd, capture=True)
    if result.returncode != 0:
        error_msg = result.stderr.strip() if result.stderr else "Unknown error"
        return LaunchResult(window_name, success=False, error=error_msg)

    return LaunchResult(window_name, success=True, prompt_path=prompt_path)


# ──────────────────────────────────────────────
# Subcommands
# ──────────────────────────────────────────────


def cmd_start(args: argparse.Namespace) -> int:
    """Unified start: worktree or intree mode, session or window tmux dest."""
    git_root = get_git_root()
    if git_root is None:
        print("Error: Not inside a git repository", file=sys.stderr)
        return 1

    swarm_mode: str = args.swarm_mode
    tmux_dest: str = args.tmux_dest
    epic_id: str | None = args.epic
    role: str = args.role
    model: str = args.model
    skill: str | None = args.skill
    dry_run: bool = args.dry_run
    njobs: int = args.njobs
    prompt_text: str | None = args.prompt
    prompt_file: Path | None = getattr(args, "prompt_file", None)
    attach: bool = getattr(args, "attach", False)
    session_name_override: str | None = getattr(args, "session_name", None)

    # Validate permission mode
    permission_mode: str = args.permission_mode
    perm_err = validate_permission_mode(permission_mode)
    if perm_err:
        print(f"Error: {perm_err}", file=sys.stderr)
        return 1

    # Resolve working directory
    working_dir = git_root
    if hasattr(args, "working_dir") and args.working_dir:
        working_dir = Path(args.working_dir).resolve()

    # Load session registry and cleanup stale entries
    registry = YAMLSessionRegistry()
    stale = registry.cleanup_stale()
    if stale:
        print(f"Cleaned up {len(stale)} stale session(s)")

    # Permission inheritance
    parent_perm = detect_parent_permission(registry)
    if parent_perm and permission_mode != parent_perm:
        print(f"  Inheriting permission mode from parent: {parent_perm}")
        permission_mode = parent_perm

    # ── Mode-specific validation ──

    if swarm_mode == SwarmMode.WORKTREE:
        if not epic_id:
            print("Error: --epic is required for worktree mode", file=sys.stderr)
            return 1
        return _start_worktree(
            args, git_root, registry, epic_id, role, model, skill,
            permission_mode, dry_run, njobs, tmux_dest,
            session_name_override, attach,
        )
    else:
        # Intree mode
        if not prompt_text and not prompt_file:
            print("Error: --prompt or --prompt-file is required for intree mode", file=sys.stderr)
            return 1
        if prompt_text and prompt_file:
            print("Error: --prompt and --prompt-file are mutually exclusive", file=sys.stderr)
            return 1

        base_prompt: str
        if prompt_text:
            base_prompt = prompt_text
        else:
            assert prompt_file is not None
            if not prompt_file.exists():
                print(f"Error: Prompt file not found: {prompt_file}", file=sys.stderr)
                return 1
            base_prompt = prompt_file.read_text()

        return _start_intree(
            args, git_root, registry, epic_id, role, model, skill,
            permission_mode, dry_run, njobs, tmux_dest, base_prompt,
            session_name_override, attach, working_dir,
        )


def _start_worktree(
    args: argparse.Namespace,
    git_root: Path,
    registry: YAMLSessionRegistry,
    epic_id: str,
    role: str,
    model: str,
    skill: str | None,
    permission_mode: str,
    dry_run: bool,
    njobs: int,
    tmux_dest: str,
    session_name_override: str | None,
    attach: bool,
) -> int:
    """Worktree mode: create worktree, discover tasks, launch Claude."""
    worktree_dir = Path(getattr(args, "worktree_dir", DEFAULT_WORKTREE_DIR))
    explicit_tasks: list[str] | None = args.task_ids if getattr(args, "task_ids", None) else None
    explicit_urd: str | None = getattr(args, "urd", None)

    epic_branch = f"epic/{epic_id}"
    worktree_path = git_root / worktree_dir / epic_id
    epic_suffix = get_epic_suffix(epic_id)

    # Check for existing active session
    restart: bool = getattr(args, "restart", False)
    existing_sessions = registry.find_by_epic(epic_id)
    for existing in existing_sessions:
        tmux_alive = check_tmux_session_exists(existing.tmux_session)
        if tmux_alive and not restart:
            print(f"Epic {epic_id} already has an active session: {existing.tmux_session}")
            print(f"  Attach with: aura-swarm attach {epic_id}")
            print(f"  Or use --restart to stop it and start fresh.")
            return 1
        if restart or not tmux_alive:
            if tmux_alive:
                if dry_run:
                    print(f"  [dry-run] Would stop existing session: {existing.tmux_session}")
                else:
                    run_command(["tmux", "kill-session", "-t", existing.tmux_session], capture=True)
                    print(f"Stopped existing session: {existing.tmux_session}")
            else:
                print(f"Cleaned up stale session record for {epic_id}")
            if not dry_run:
                registry.remove(existing.session_id)

    # ── Step 1: Epic branch + worktree setup ──

    if worktree_path.exists():
        print(f"Warning: Worktree already exists at {worktree_path}, reusing.")
        if dry_run:
            print(f"  [dry-run] Would reuse worktree at {worktree_path}")
    else:
        if branch_exists(epic_branch):
            git_worktree_cmd = ["git", "worktree", "add", str(worktree_path), epic_branch]
        else:
            git_worktree_cmd = ["git", "worktree", "add", str(worktree_path), "-b", epic_branch]

        if dry_run:
            print(f"  [dry-run] Would run: {' '.join(git_worktree_cmd)}")
        else:
            print(f"Creating worktree at {worktree_path} on branch {epic_branch}...")
            result = run_command(git_worktree_cmd, capture=True)
            if result.returncode != 0:
                print(f"Error creating worktree: {result.stderr.strip()}", file=sys.stderr)
                return 1
            print(f"  Created: {worktree_path}")

    # ── Step 2: Task discovery ──

    print("Discovering tasks...")
    epic_data = bd_show_json(epic_id)
    if epic_data is None:
        print(f"Error: Could not fetch epic {epic_id} from beads", file=sys.stderr)
        return 1

    tasks = discover_tasks(epic_id, explicit_tasks)
    if not tasks:
        print(f"No tasks found for epic {epic_id}.")
        print(f"  Provide task IDs explicitly: aura-swarm start --epic {epic_id} task-1 task-2")
        return 0

    print(f"  Found {len(tasks)} task(s):")
    for t in tasks:
        print(f"    {t.id}: {t.title} [{t.status}]")

    # ── Step 2b: URD discovery ──

    urd_id = discover_urd(epic_id, explicit_urd)
    if urd_id:
        print(f"  URD: {urd_id}")
    else:
        print("  No URD found (specify with --urd <id> if needed)")

    # ── Step 3: Build prompt ──

    prompt = build_worktree_prompt(epic_id, epic_data, tasks, urd_id)

    prompt_addon: str | None = getattr(args, "prompt_addon", None)
    if prompt_addon:
        prompt += f"\n\n## Additional Instructions\n\n{prompt_addon}\n"

    if dry_run:
        print()
        print("Generated prompt:")
        print("-" * 60)
        if len(prompt) > 3000:
            print(prompt[:3000])
            print(f"... ({len(prompt)} chars total, truncated)")
        else:
            print(prompt)
        print("-" * 60)
        print()
        print("Dry run complete. No sessions created.")
        return 0

    # ── Step 4: Load role instructions ──

    role_instructions, instructions_path = get_role_instructions(role, worktree_path)
    if role_instructions is None:
        script_dir = Path(__file__).resolve().parent.parent
        print(f"Error: Role file not found: skills/{role}/SKILL.md", file=sys.stderr)
        print(f"  Looked in: {worktree_path}/skills/", file=sys.stderr)
        print(f"  Looked in: {script_dir}/skills/", file=sys.stderr)
        print(f"  Looked in: {PACKAGE_SKILLS_DIR}/", file=sys.stderr)
        return 1

    # ── Step 5: Launch ──

    return _launch_agents(
        registry=registry,
        njobs=njobs,
        tmux_dest=tmux_dest,
        epic_id=epic_id,
        epic_suffix=epic_suffix,
        role=role,
        model=model,
        working_dir=worktree_path,
        instructions_path=instructions_path,
        prompt=prompt,
        permission_mode=permission_mode,
        swarm_mode=SwarmMode.WORKTREE,
        git_branch=epic_branch,
        task_ids=[t.id for t in tasks],
        session_name_override=session_name_override,
        attach=attach,
    )


def _start_intree(
    args: argparse.Namespace,
    git_root: Path,
    registry: YAMLSessionRegistry,
    epic_id: str | None,
    role: str,
    model: str,
    skill: str | None,
    permission_mode: str,
    dry_run: bool,
    njobs: int,
    tmux_dest: str,
    base_prompt: str,
    session_name_override: str | None,
    attach: bool,
    working_dir: Path,
) -> int:
    """Intree mode: launch agents without worktree (replaces aura-parallel)."""
    epic_suffix = get_epic_suffix(epic_id) if epic_id else secrets.token_hex(4)
    task_ids_raw: list[str] = getattr(args, "task_id", None) or []

    # Load role instructions
    role_instructions, instructions_path = get_role_instructions(role, working_dir)
    if role_instructions is None:
        script_dir = Path(__file__).resolve().parent.parent
        print(f"Error: Role file not found: skills/{role}/SKILL.md", file=sys.stderr)
        print(f"  Looked in: {working_dir}/skills/", file=sys.stderr)
        print(f"  Looked in: {script_dir}/skills/", file=sys.stderr)
        print(f"  Looked in: {PACKAGE_SKILLS_DIR}/", file=sys.stderr)
        return 1

    if not dry_run:
        print(f"Launching {njobs} {role} agent(s) (intree mode)...")
        print(f"  Working directory: {working_dir}")
        print(f"  Role instructions: {instructions_path}")
        print(f"  Model: {model}")
        print(f"  Permission mode: {permission_mode}")
        if skill:
            print(f"  Skill: {skill}")
        if task_ids_raw:
            print(f"  Task IDs: {', '.join(task_ids_raw)}")
        print()

    # Setup signal handler for graceful interruption
    signal.signal(signal.SIGINT, signal_handler)

    # Build per-job prompts and launch
    results: list[LaunchResult] = []
    first_session_name: str | None = None

    for i in range(njobs):
        if _interrupted:
            print(f"Skipping remaining {njobs - i} session(s) due to interrupt", file=sys.stderr)
            break

        # Distribute task IDs: n=1 gets all, n>1 gets 1:1
        if njobs == 1:
            job_task_ids = task_ids_raw if task_ids_raw else None
            session_task_id = task_ids_raw[0] if task_ids_raw else None
        else:
            job_task_ids = [task_ids_raw[i]] if i < len(task_ids_raw) else None
            session_task_id = task_ids_raw[i] if i < len(task_ids_raw) else None

        prompt = build_intree_prompt(base_prompt, skill, job_task_ids)

        if dry_run:
            if session_name_override:
                name = session_name_override if njobs == 1 else f"{session_name_override}--{i + 1}"
            else:
                name = f"{role}-{epic_suffix}--{i + 1}--<hex4>"
            print(f"Would create {'window' if tmux_dest == TmuxDest.WINDOW else 'session'}: {name}")
            print(f"  tmux {'new-window' if tmux_dest == TmuxDest.WINDOW else 'new-session'} \\")
            print(f"    claude --model {model} --append-system-prompt <role-instructions> \\")
            print(f"           --permission-mode {permission_mode} '<prompt>'")
            results.append(LaunchResult(name, success=True))
            continue

        # Generate names
        if session_name_override:
            session_name = session_name_override if njobs == 1 else f"{session_name_override}--{i + 1}"
        elif tmux_dest == TmuxDest.WINDOW:
            session_name = f"swarm-{epic_suffix}"
        else:
            try:
                session_name = generate_session_name(role, epic_suffix, i + 1, session_task_id)
            except RuntimeError as e:
                results.append(LaunchResult(f"{role}--{i + 1}--???", success=False, error=str(e)))
                continue

        window_name = generate_window_name(role, i + 1, session_task_id)

        # Launch
        if tmux_dest == TmuxDest.WINDOW:
            lr = launch_in_tmux_window(
                tmux_session=session_name,
                window_name=window_name,
                working_dir=working_dir,
                instructions_path=instructions_path,
                prompt=prompt,
                model=model,
                permission_mode=permission_mode,
            )
        else:
            lr = launch_tmux_session(
                session_name=session_name,
                working_dir=working_dir,
                instructions_path=instructions_path,
                prompt=prompt,
                model=model,
                permission_mode=permission_mode,
            )
        results.append(lr)

        if lr.success:
            print(f"  Started: {session_name}" + (f" (window: {window_name})" if tmux_dest == TmuxDest.WINDOW else ""))
            if first_session_name is None:
                first_session_name = session_name

            # Register in session registry
            prompt_hash = hashlib.sha256(prompt.encode()).hexdigest()[:16]
            current_branch_result = run_command(["git", "rev-parse", "--abbrev-ref", "HEAD"], capture=True)
            git_branch = current_branch_result.stdout.strip() if current_branch_result.returncode == 0 else ""

            record = SessionRecord(
                session_id=f"{session_name}--{window_name}" if tmux_dest == TmuxDest.WINDOW else session_name,
                permission_mode=permission_mode,
                model=model,
                pid=_get_tmux_pane_pid(session_name),
                working_dir=str(working_dir),
                started_at=datetime.now(timezone.utc).isoformat(),
                parent_session_id="",
                role=role,
                epic_id=epic_id or "",
                swarm_mode=SwarmMode.INTREE,
                tmux_session=session_name,
                tmux_window=window_name if tmux_dest == TmuxDest.WINDOW else "",
                status=SessionStatus.RUNNING,
                last_activity_at=datetime.now(timezone.utc).isoformat(),
                prompt_hash=prompt_hash,
                git_branch=git_branch,
                beads_task_id="",
                task_ids=tuple(job_task_ids) if job_task_ids else (),
            )
            try:
                registry.register(record)
            except FileExistsError:
                pass  # Session already registered
        else:
            print(f"  Failed: {session_name} - {lr.error}", file=sys.stderr)

    # Summary
    successful = sum(1 for r in results if r.success)
    total = len(results)

    print()
    if dry_run:
        print("Dry run complete.")
        print()
        print(f"Role instructions (from {instructions_path}):")
        print("-" * 60)
        preview = role_instructions[:500] + "..." if len(role_instructions) > 500 else role_instructions
        print(preview)
        print("-" * 60)
        print()
        print("Prompt content (example for first job):")
        print("-" * 60)
        example_task_ids = task_ids_raw if (njobs == 1 and task_ids_raw) else ([task_ids_raw[0]] if task_ids_raw else None)
        example_prompt = build_intree_prompt(base_prompt, skill, example_task_ids)
        print(example_prompt)
        print("-" * 60)
    else:
        print(f"Launched {successful}/{total} sessions successfully.")

        if successful > 0:
            print()
            if tmux_dest == TmuxDest.WINDOW:
                print(f"  All agents in tmux session: swarm-{epic_suffix}")
                print(f"  Attach: tmux attach -t swarm-{epic_suffix}")
            else:
                print("Commands:")
                print(f"  List:    tmux list-sessions | grep {role}")
                print(f"  Attach:  tmux attach -t <session-name>")
                print(f"  Kill:    tmux kill-session -t <session-name>")

        if attach and first_session_name:
            print()
            print(f"Attaching to {first_session_name}...")
            run_command(["tmux", "attach", "-t", first_session_name])

    return 1 if successful < total else 0


def _launch_agents(
    *,
    registry: YAMLSessionRegistry,
    njobs: int,
    tmux_dest: str,
    epic_id: str,
    epic_suffix: str,
    role: str,
    model: str,
    working_dir: Path,
    instructions_path: Path,
    prompt: str,
    permission_mode: str,
    swarm_mode: str,
    git_branch: str,
    task_ids: list[str],
    session_name_override: str | None,
    attach: bool,
) -> int:
    """Launch N agents in session or window mode, register in registry."""
    signal.signal(signal.SIGINT, signal_handler)

    results: list[LaunchResult] = []
    first_session_name: str | None = None

    for i in range(njobs):
        if _interrupted:
            print(f"Skipping remaining {njobs - i} session(s) due to interrupt", file=sys.stderr)
            break

        if session_name_override:
            session_name = session_name_override if njobs == 1 else f"{session_name_override}--{i + 1}"
        elif tmux_dest == TmuxDest.WINDOW:
            session_name = f"swarm-{epic_suffix}"
        else:
            try:
                session_name = generate_session_name(role, epic_suffix, i + 1, None)
            except RuntimeError as e:
                results.append(LaunchResult(f"{role}--{i + 1}--???", success=False, error=str(e)))
                continue

        window_name = generate_window_name(role, i + 1, None)

        print(f"\nLaunching Claude ({model}, role={role})...")
        print(f"  Role instructions: {instructions_path}")

        if tmux_dest == TmuxDest.WINDOW:
            lr = launch_in_tmux_window(
                tmux_session=session_name,
                window_name=window_name,
                working_dir=working_dir,
                instructions_path=instructions_path,
                prompt=prompt,
                model=model,
                permission_mode=permission_mode,
            )
        else:
            lr = launch_tmux_session(
                session_name=session_name,
                working_dir=working_dir,
                instructions_path=instructions_path,
                prompt=prompt,
                model=model,
                permission_mode=permission_mode,
            )
        results.append(lr)

        if lr.success:
            print(f"  Started: {session_name}" + (f" (window: {window_name})" if tmux_dest == TmuxDest.WINDOW else ""))
            if first_session_name is None:
                first_session_name = session_name

            prompt_hash = hashlib.sha256(prompt.encode()).hexdigest()[:16]
            record = SessionRecord(
                session_id=f"{session_name}--{window_name}" if tmux_dest == TmuxDest.WINDOW else session_name,
                permission_mode=permission_mode,
                model=model,
                pid=_get_tmux_pane_pid(session_name),
                working_dir=str(working_dir),
                started_at=datetime.now(timezone.utc).isoformat(),
                parent_session_id="",
                role=role,
                epic_id=epic_id,
                swarm_mode=swarm_mode,
                tmux_session=session_name,
                tmux_window=window_name if tmux_dest == TmuxDest.WINDOW else "",
                status=SessionStatus.RUNNING,
                last_activity_at=datetime.now(timezone.utc).isoformat(),
                prompt_hash=prompt_hash,
                git_branch=git_branch,
                beads_task_id="",
                task_ids=tuple(task_ids),
            )
            try:
                registry.register(record)
            except FileExistsError:
                pass
        else:
            print(f"Error launching tmux: {lr.error}", file=sys.stderr)

    successful = sum(1 for r in results if r.success)
    total = len(results)

    if successful > 0 and first_session_name:
        print()
        print(f"Swarm session started for epic {epic_id}")
        print(f"  tmux:     {first_session_name}")
        print(f"  worktree: {working_dir}")
        print(f"  branch:   {git_branch}")
        print(f"  tasks:    {len(task_ids)}")
        print()
        print(f"  Attach: aura-swarm attach {epic_id}")

        if attach:
            print()
            print(f"Attaching to {first_session_name}...")
            run_command(["tmux", "attach", "-t", first_session_name])

    return 1 if successful < total else 0


def _get_tmux_pane_pid(session_name: str) -> int:
    """Get the PID of the command running in a tmux session's first pane."""
    result = run_command(
        ["tmux", "list-panes", "-t", session_name, "-F", "#{pane_pid}"],
        capture=True,
    )
    if result.returncode == 0 and result.stdout.strip():
        try:
            return int(result.stdout.strip().splitlines()[0])
        except ValueError:
            pass
    return os.getpid()  # Fallback: use own PID


def cmd_status(args: argparse.Namespace) -> int:
    """Print table of active sessions (from YAML registry)."""
    registry = YAMLSessionRegistry()
    stale = registry.cleanup_stale()

    # Get all remaining sessions
    all_sessions: list[SessionRecord] = []
    sessions_dir = registry._dir
    for path in sessions_dir.glob("*.yaml"):
        try:
            from aura_protocol.session_registry import deserialize_session
            record = deserialize_session(path.read_text())
            all_sessions.append(record)
        except (FileNotFoundError, ValueError, KeyError):
            continue

    if not all_sessions:
        print("No active sessions.")
        if stale:
            print(f"  (cleaned up {len(stale)} stale session(s))")
        return 0

    # Header
    print(f"{'session-id':<32} {'mode':<8} {'role':<12} {'alive?':<8} {'epic':<16} {'working-dir':<30}")
    print("-" * 106)

    for r in all_sessions:
        alive = "yes" if check_tmux_session_exists(r.tmux_session) else "no"
        wd = r.working_dir
        if len(wd) > 28:
            wd = "..." + wd[-25:]
        print(f"{r.session_id:<32} {r.swarm_mode:<8} {r.role:<12} {alive:<8} {r.epic_id:<16} {wd:<30}")

    if stale:
        print(f"\n  (cleaned up {len(stale)} stale session(s))")
    return 0


def cmd_attach(args: argparse.Namespace) -> int:
    """Attach to an epic's tmux session (or a session by ID)."""
    registry = YAMLSessionRegistry()
    target = args.epic_id

    # Try by epic first
    sessions = registry.find_by_epic(target)
    if sessions:
        entry = sessions[0]
    else:
        # Try by session_id
        entry = registry.get(target)

    if entry is None:
        print(f"No session found for '{target}'", file=sys.stderr)
        print("  Run `aura-swarm status` to see active sessions.", file=sys.stderr)
        return 1

    if not check_tmux_session_exists(entry.tmux_session):
        print(f"tmux session '{entry.tmux_session}' is no longer alive.", file=sys.stderr)
        print(f"  Run `aura-swarm stop {target}` to clean up.", file=sys.stderr)
        return 1

    print(f"Attaching to {entry.tmux_session}...")
    os.execvp("tmux", ["tmux", "attach", "-t", entry.tmux_session])
    return 1  # Only reached on exec error


def cmd_stop(args: argparse.Namespace) -> int:
    """Kill tmux session, leave worktree intact."""
    registry = YAMLSessionRegistry()
    target = args.epic_id
    dry_run: bool = args.dry_run

    sessions = registry.find_by_epic(target)
    if not sessions:
        entry = registry.get(target)
        sessions = [entry] if entry else []

    if not sessions:
        print(f"No session found for '{target}'", file=sys.stderr)
        return 1

    for entry in sessions:
        if check_tmux_session_exists(entry.tmux_session):
            if dry_run:
                print(f"  [dry-run] Would kill tmux session: {entry.tmux_session}")
            else:
                run_command(["tmux", "kill-session", "-t", entry.tmux_session], capture=True)
                print(f"Killed tmux session: {entry.tmux_session}")
        else:
            print(f"tmux session '{entry.tmux_session}' was already dead.")

        if not dry_run:
            registry.remove(entry.session_id)
            print(f"Removed session record: {entry.session_id}")
            if entry.swarm_mode == SwarmMode.WORKTREE:
                print(f"  Worktree preserved at: {entry.working_dir}")

    return 0


def cmd_merge(args: argparse.Namespace) -> int:
    """Merge epic branch back to main."""
    git_root = get_git_root()
    if git_root is None:
        print("Error: Not inside a git repository", file=sys.stderr)
        return 1

    epic_id: str = args.epic_id
    epic_branch = f"epic/{epic_id}"
    dry_run: bool = args.dry_run

    # Check worktree cleanliness via registry
    registry = YAMLSessionRegistry()
    sessions = registry.find_by_epic(epic_id)
    for entry in sessions:
        if entry.swarm_mode == SwarmMode.INTREE:
            if not dry_run:
                print(f"Note: Epic {epic_id} has intree sessions — merge is a no-op for intree mode.")
                return 0

        wt_path = Path(entry.working_dir)
        if wt_path.exists() and worktree_is_dirty(wt_path):
            print(f"Error: Worktree at {wt_path} has uncommitted changes.", file=sys.stderr)
            print("  Commit or stash changes before merging.", file=sys.stderr)
            return 1

    if not branch_exists(epic_branch, cwd=git_root):
        print(f"Error: Branch {epic_branch} does not exist.", file=sys.stderr)
        return 1

    if dry_run:
        print(f"  [dry-run] Would merge {epic_branch} into current branch with --no-ff")
        return 0

    print(f"Merging {epic_branch} into current branch...")
    result = run_command(
        ["git", "merge", epic_branch, "--no-ff", "-m", f"Merge epic/{epic_id}"],
        capture=True,
        cwd=git_root,
    )
    if result.returncode != 0:
        stderr = result.stderr.strip() if result.stderr else ""
        stdout = result.stdout.strip() if result.stdout else ""

        print("Merge failed.", file=sys.stderr)
        if "CONFLICT" in stdout or "CONFLICT" in stderr:
            print("Conflicts detected. Aborting merge...", file=sys.stderr)
            run_command(["git", "merge", "--abort"], capture=True, cwd=git_root)
            if stdout:
                print(stdout, file=sys.stderr)
            print("\nResolve conflicts manually, then retry.", file=sys.stderr)
        else:
            if stderr:
                print(stderr, file=sys.stderr)
            if stdout:
                print(stdout, file=sys.stderr)
        return 1

    print(f"Successfully merged {epic_branch}")
    if result.stdout.strip():
        print(result.stdout.strip())
    return 0


def cmd_review(args: argparse.Namespace) -> int:
    """Generate a review document for a completed epic."""
    git_root = get_git_root()
    if git_root is None:
        print("Error: Not inside a git repository", file=sys.stderr)
        return 1

    epic_id: str = args.epic
    epic_branch = f"epic/{epic_id}"
    dry_run: bool = args.dry_run

    if not branch_exists(epic_branch, cwd=git_root):
        # For intree mode, diff against main from HEAD
        epic_branch = "HEAD"

    epic_data = bd_show_json(epic_id)
    if epic_data is None:
        print(f"Error: Could not fetch epic {epic_id} from beads", file=sys.stderr)
        return 1

    tasks = discover_tasks(epic_id, None)

    diff_stat_result = run_command(
        ["git", "diff", "--stat", f"main...{epic_branch}"],
        capture=True,
        cwd=git_root,
    )
    diff_stat = diff_stat_result.stdout.strip() if diff_stat_result.returncode == 0 else "N/A"

    doc_lines = [
        f"# Review: Epic {epic_id}",
        "",
        f"**Title:** {epic_data.get('title', '')}",
        f"**Branch:** {epic_branch}",
        f"**Generated:** {datetime.now(timezone.utc).isoformat()}",
        "",
        "## Epic Description",
        "",
        epic_data.get("description", ""),
        "",
        "## Task Breakdown",
        "",
    ]

    for t in tasks:
        doc_lines.append(f"### {t.id}: {t.title}")
        doc_lines.append(f"**Status:** {t.status}")
        if t.dependencies:
            doc_lines.append(f"**Dependencies:** {', '.join(t.dependencies)}")
        doc_lines.append("")

    doc_lines.extend([
        "## Diff Summary",
        "",
        "```",
        diff_stat,
        "```",
        "",
        "## Review Checklist",
        "",
        "- [ ] All tasks completed",
        "- [ ] Tests pass",
        "- [ ] Type checking passes",
        "- [ ] No security issues introduced",
        "- [ ] Code follows project conventions",
        "- [ ] Documentation updated if needed",
        "",
    ])

    doc_content = "\n".join(doc_lines)
    review_path = git_root / "docs" / f"review-{epic_id}.md"

    if dry_run:
        print(f"  [dry-run] Would write review to {review_path}")
        print()
        print("Preview:")
        print("-" * 60)
        print(doc_content[:2000])
        if len(doc_content) > 2000:
            print(f"... ({len(doc_content)} chars total)")
        print("-" * 60)
        return 0

    review_path.parent.mkdir(parents=True, exist_ok=True)
    review_path.write_text(doc_content)
    print(f"Wrote review document: {review_path}")

    create_result = run_command(
        ["bd", "create", f"--title=[REVIEW] Epic {epic_id}", "--type=task", "--priority=1"],
        capture=True,
    )
    if create_result.returncode == 0:
        print(f"Created review task: {create_result.stdout.strip()}")
    else:
        print("Warning: Could not create beads review task", file=sys.stderr)

    return 0


def cmd_cleanup(args: argparse.Namespace) -> int:
    """Remove sessions and optionally worktrees/branches."""
    git_root = get_git_root()
    if git_root is None:
        print("Error: Not inside a git repository", file=sys.stderr)
        return 1

    registry = YAMLSessionRegistry()
    dry_run: bool = args.dry_run
    force: bool = args.force

    if args.epic_id:
        targets = registry.find_by_epic(args.epic_id)
        if not targets:
            # Try as session_id
            entry = registry.get(args.epic_id)
            targets = [entry] if entry else []
    elif args.done:
        all_sessions: list[SessionRecord] = []
        for path in registry._dir.glob("*.yaml"):
            try:
                from aura_protocol.session_registry import deserialize_session
                record = deserialize_session(path.read_text())
                all_sessions.append(record)
            except (FileNotFoundError, ValueError, KeyError):
                continue

        targets = []
        for s in all_sessions:
            if s.swarm_mode == SwarmMode.WORKTREE:
                epic_branch = f"epic/{s.epic_id}"
                if branch_merged_into_main(epic_branch, cwd=git_root):
                    targets.append(s)
            else:
                # Intree sessions with dead tmux are stale
                if not check_tmux_session_exists(s.tmux_session):
                    targets.append(s)

        if not targets:
            print("No completed sessions found to clean up.")
            return 0
        print(f"Found {len(targets)} completed session(s) to clean up:")
        for t in targets:
            print(f"  - {t.session_id} ({t.swarm_mode})")
    elif args.all:
        all_sessions = []
        for path in registry._dir.glob("*.yaml"):
            try:
                from aura_protocol.session_registry import deserialize_session
                record = deserialize_session(path.read_text())
                all_sessions.append(record)
            except (FileNotFoundError, ValueError, KeyError):
                continue

        if not all_sessions:
            print("No sessions to clean up.")
            return 0

        print(f"The following {len(all_sessions)} session(s) will be removed:")
        for s in all_sessions:
            flags = []
            if s.swarm_mode == SwarmMode.WORKTREE and Path(s.working_dir).exists() and worktree_is_dirty(Path(s.working_dir)):
                flags.append("DIRTY")
            if check_tmux_session_exists(s.tmux_session):
                flags.append("tmux alive")
            flag_str = f" ({', '.join(flags)})" if flags else ""
            print(f"  - {s.session_id}: {s.working_dir}{flag_str}")

        if not dry_run:
            confirm = input("\nType 'yes' to confirm cleanup: ")
            if confirm.strip().lower() != "yes":
                print("Aborted.")
                return 0

        targets = all_sessions
    else:
        print("Error: Provide an epic-id, --done, or --all", file=sys.stderr)
        return 1

    errors = 0
    for entry in targets:
        # Only handle worktree cleanup for worktree mode
        if entry.swarm_mode == SwarmMode.WORKTREE:
            worktree_path = Path(entry.working_dir)
            epic_branch = f"epic/{entry.epic_id}"

            if worktree_path.exists() and worktree_is_dirty(worktree_path):
                if not force:
                    print(f"  Skipping {entry.session_id}: worktree is dirty (use --force)", file=sys.stderr)
                    errors += 1
                    continue

            # Kill tmux if alive
            if check_tmux_session_exists(entry.tmux_session):
                if dry_run:
                    print(f"  [dry-run] Would kill tmux: {entry.tmux_session}")
                else:
                    run_command(["tmux", "kill-session", "-t", entry.tmux_session], capture=True)
                    print(f"  Killed tmux: {entry.tmux_session}")

            # Remove worktree
            if worktree_path.exists():
                if dry_run:
                    print(f"  [dry-run] Would remove worktree: {worktree_path}")
                else:
                    wt_cmd = ["git", "worktree", "remove", str(worktree_path)]
                    if force:
                        wt_cmd.append("--force")
                    result = run_command(wt_cmd, capture=True, cwd=git_root)
                    if result.returncode != 0:
                        print(f"  Error removing worktree {worktree_path}: {result.stderr.strip()}", file=sys.stderr)
                        errors += 1
                        continue
                    print(f"  Removed worktree: {worktree_path}")

            # Delete branch
            if branch_exists(epic_branch, cwd=git_root):
                if dry_run:
                    print(f"  [dry-run] Would delete branch: {epic_branch}")
                else:
                    flag = "-D" if force else "-d"
                    result = run_command(
                        ["git", "branch", flag, epic_branch],
                        capture=True,
                        cwd=git_root,
                    )
                    if result.returncode != 0:
                        print(f"  Error deleting branch {epic_branch}: {result.stderr.strip()}", file=sys.stderr)
                        errors += 1
                    else:
                        print(f"  Deleted branch: {epic_branch}")

        else:
            # Intree mode: just kill tmux
            if check_tmux_session_exists(entry.tmux_session):
                if dry_run:
                    print(f"  [dry-run] Would kill tmux: {entry.tmux_session}")
                else:
                    run_command(["tmux", "kill-session", "-t", entry.tmux_session], capture=True)
                    print(f"  Killed tmux: {entry.tmux_session}")

        # Remove registry entry
        if not dry_run:
            registry.remove(entry.session_id)

    if dry_run:
        print("\nDry run complete. No changes made.")
    elif errors:
        print(f"\nCleanup completed with {errors} error(s).")
    else:
        print("\nCleanup complete.")

    return 1 if errors > 0 else 0


# ──────────────────────────────────────────────
# Argument parser
# ──────────────────────────────────────────────


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        prog="aura-swarm",
        description="Unified agent orchestration — launch Claude swarms in worktree or intree mode",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=textwrap.dedent("""\
            Examples:
              # Worktree mode (default)
              aura-swarm start --epic aura-dyu                    # Launch with default settings
              aura-swarm start --epic aura-dyu --model opus       # Use opus model
              aura-swarm start --epic aura-dyu --restart          # Stop existing + start fresh

              # Intree mode (replaces aura-parallel)
              aura-swarm start --swarm-mode intree --role supervisor -n 1 --prompt "..."
              aura-swarm start --swarm-mode intree -n 3 --prompt "..." --task-id t1 --task-id t2

              # Window mode (agents accumulate in one tmux session)
              aura-swarm start --epic aura-dyu --tmux-dest window -n 2

              # Management
              aura-swarm status                                   # Show active sessions
              aura-swarm attach aura-dyu                          # Attach to tmux session
              aura-swarm stop aura-dyu                            # Kill session, keep worktree
              aura-swarm merge aura-dyu                           # Merge epic to main
              aura-swarm review --epic aura-dyu                   # Generate review doc
              aura-swarm cleanup aura-dyu                         # Remove worktree + branch
              aura-swarm cleanup --done                           # Clean completed sessions
              aura-swarm cleanup --all                            # Interactive cleanup of all
        """),
    )

    # Shared flags
    shared = argparse.ArgumentParser(add_help=False)
    shared.add_argument("--dry-run", action="store_true", default=False, help="Show what would be done without executing")
    shared.add_argument("--worktree-dir", default=DEFAULT_WORKTREE_DIR, help=f"Override worktree root directory (default: {DEFAULT_WORKTREE_DIR}/)")

    subparsers = parser.add_subparsers(dest="command", required=True)

    # ── start ──
    start_p = subparsers.add_parser("start", parents=[shared], help="Launch Claude agent(s) in worktree or intree mode")
    start_p.add_argument("--epic", default=None, help="Epic beads ID (required for worktree mode, optional for intree)")
    start_p.add_argument("--swarm-mode", default=SwarmMode.WORKTREE, choices=[SwarmMode.WORKTREE, SwarmMode.INTREE], help="Operation mode (default: worktree)")
    start_p.add_argument("--tmux-dest", default=TmuxDest.SESSION, choices=[TmuxDest.SESSION, TmuxDest.WINDOW], help="Tmux launch target (default: session)")
    start_p.add_argument("-n", "--njobs", type=int, default=1, help="Number of parallel agents (default: 1)")
    start_p.add_argument("--role", default=DEFAULT_ROLE, choices=sorted(VALID_ROLES), help=f"Agent role (default: {DEFAULT_ROLE})")
    start_p.add_argument("--model", default=DEFAULT_MODEL, choices=sorted(VALID_MODELS), help=f"Model to use (default: {DEFAULT_MODEL})")
    start_p.add_argument("--skill", help="Skill to invoke at start")
    start_p.add_argument("--restart", action="store_true", default=False, help="Stop existing session and start fresh")
    start_p.add_argument("--prompt", default=None, help="Prompt text (required for intree mode)")
    start_p.add_argument("--prompt-file", type=Path, default=None, help="Read prompt from file (mutually exclusive with --prompt)")
    start_p.add_argument("--prompt-addon", default=None, help="Additional instructions appended to auto-generated prompt (worktree mode)")
    start_p.add_argument("--permission-mode", default=PermissionMode.ACCEPT_EDITS, choices=sorted(VALID_PERMISSION_MODES), help=f"Claude permission mode (default: {PermissionMode.ACCEPT_EDITS})")
    start_p.add_argument("--urd", help="User Requirements Document beads ID (auto-discovered if not set)")
    start_p.add_argument("--task-id", action="append", help="Beads task ID (repeatable). Intree: distributed 1:1 across agents")
    start_p.add_argument("--session-name", default=None, help="Override tmux session name")
    start_p.add_argument("--attach", action="store_true", default=False, help="Attach to first session after launching")
    start_p.add_argument("--working-dir", type=Path, default=None, help="Working directory (default: git root)")
    start_p.add_argument("task_ids", nargs="*", default=None, help="Explicit task IDs for worktree mode (default: discover from epic)")

    # ── status ──
    subparsers.add_parser("status", parents=[shared], help="Show active sessions")

    # ── attach ──
    attach_p = subparsers.add_parser("attach", parents=[shared], help="Attach to a session's tmux")
    attach_p.add_argument("epic_id", help="Epic beads ID or session ID")

    # ── stop ──
    stop_p = subparsers.add_parser("stop", parents=[shared], help="Kill tmux session, preserve worktree")
    stop_p.add_argument("epic_id", help="Epic beads ID or session ID")

    # ── merge ──
    merge_p = subparsers.add_parser("merge", parents=[shared], help="Merge epic branch back to main")
    merge_p.add_argument("epic_id", help="Epic beads ID")

    # ── review ──
    review_p = subparsers.add_parser("review", parents=[shared], help="Generate review document for an epic")
    review_p.add_argument("--epic", required=True, help="Epic beads ID")

    # ── cleanup ──
    cleanup_p = subparsers.add_parser("cleanup", parents=[shared], help="Remove sessions, worktrees, and branches")
    cleanup_target = cleanup_p.add_mutually_exclusive_group(required=True)
    cleanup_target.add_argument("epic_id", nargs="?", default=None, help="Specific epic ID or session ID")
    cleanup_target.add_argument("--done", action="store_true", help="Remove completed/merged sessions")
    cleanup_target.add_argument("--all", action="store_true", help="Remove all sessions (interactive confirmation)")
    cleanup_p.add_argument("--force", action="store_true", help="Force removal even if worktree is dirty")

    return parser


# ──────────────────────────────────────────────
# Argv pre-processing
# ──────────────────────────────────────────────

_SUBCOMMANDS = frozenset(["start", "status", "attach", "stop", "merge", "review", "cleanup"])

_GLOBAL_FLAGS = [
    ("--dry-run", False),
    ("--worktree-dir", True),
]


def _hoist_global_flags(argv: list[str]) -> list[str]:
    """Move global flags to right after the subcommand so argparse sees them."""
    hoisted: list[str] = []
    remaining: list[str] = []
    i = 0
    while i < len(argv):
        arg = argv[i]
        matched = False
        for flag, has_value in _GLOBAL_FLAGS:
            if arg == flag:
                hoisted.append(arg)
                if has_value and i + 1 < len(argv):
                    i += 1
                    hoisted.append(argv[i])
                matched = True
                break
            if has_value and arg.startswith(flag + "="):
                hoisted.append(arg)
                matched = True
                break
        if not matched:
            remaining.append(arg)
        i += 1

    result: list[str] = []
    inserted = False
    for arg in remaining:
        result.append(arg)
        if not inserted and arg in _SUBCOMMANDS:
            result.extend(hoisted)
            inserted = True
    if not inserted:
        result.extend(hoisted)
    return result


# ──────────────────────────────────────────────
# Main
# ──────────────────────────────────────────────


def main() -> int:
    signal.signal(signal.SIGINT, signal_handler)

    parser = build_parser()
    args = parser.parse_args(_hoist_global_flags(sys.argv[1:]))

    # Determine mode for prerequisite check
    swarm_mode = getattr(args, "swarm_mode", SwarmMode.WORKTREE)
    has_epic = bool(getattr(args, "epic", None))

    prereq_errors = check_prerequisites(swarm_mode, has_epic)
    if prereq_errors:
        for err in prereq_errors:
            print(f"Error: {err}", file=sys.stderr)
        return 1

    dispatch = {
        "start": cmd_start,
        "status": cmd_status,
        "attach": cmd_attach,
        "stop": cmd_stop,
        "merge": cmd_merge,
        "review": cmd_review,
        "cleanup": cmd_cleanup,
    }

    handler = dispatch.get(args.command)
    if handler is None:
        parser.print_help()
        return 1

    return handler(args)


if __name__ == "__main__":
    sys.exit(main())
