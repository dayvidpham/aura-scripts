<?xml version='1.0' encoding='UTF-8'?>
<aura-protocol version="2.0">
  <!--
  Aura Protocol Schema v2.0

  Canonical, machine-readable definition of the Aura multi-agent protocol.
  All markdown documentation (PROCESS.md, AGENTS.md, SKILLS.md, etc.) is
  derived from this schema. Changes to the protocol MUST be reflected here first.

  Design: Boyce-Codd Normal Form (BCNF)
  - Each fact stored exactly once
  - Relationships via idref attributes, no duplication
  - No transitive dependencies
  - Enums define closed sets; entities reference enums by id
-->
  <!-- ═══════════════════════════════════════════════════════════════════════
     ENUMERATIONS
     ═══════════════════════════════════════════════════════════════════════ -->
  <enums>
    <enum name="DomainType">
      <value id="user" description="User-facing interaction (requests, elicitation, UAT)" />
      <value id="plan" description="Planning and design (proposals, reviews, ratification)" />
      <value id="impl" description="Implementation (slices, code review, landing)" />
    </enum>
    <enum name="VoteType">
      <value id="ACCEPT" description="All review criteria satisfied; no BLOCKER items" />
      <value id="REVISE" description="BLOCKER issues found; must provide actionable feedback" />
    </enum>
    <enum name="SeverityLevel">
      <value id="BLOCKER" blocks="true" label="aura:severity:blocker" description="Security, type errors, test failures, broken production code paths" />
      <value id="IMPORTANT" blocks="false" label="aura:severity:important" description="Performance, missing validation, architectural concerns" />
      <value id="MINOR" blocks="false" label="aura:severity:minor" description="Style, optional optimizations, naming improvements" />
    </enum>
    <enum name="ExecutionMode">
      <value id="sequential" description="Must complete before next step starts" />
      <value id="parallel" description="Can run concurrently with sibling steps in same parallel-group" />
    </enum>
    <enum name="ContentLevel">
      <value id="full-provenance" description="Full inline context with all decisions and rationale" />
      <value id="summary-with-ids" description="Summary with Beads task ID references" />
    </enum>
    <!-- Classification axes (s1_1-classify) -->
    <enum name="ClassificationScope">
      <value id="single-file" description="Change is isolated to a single file" />
      <value id="module" description="Change spans a module or package" />
      <value id="cross-cutting" description="Change affects multiple modules or subsystems" />
    </enum>
    <enum name="ClassificationComplexity">
      <value id="low" description="Straightforward implementation, familiar patterns" />
      <value id="medium" description="Some design decisions needed, moderate scope" />
      <value id="high" description="Significant design work, unfamiliar territory, or many moving parts" />
    </enum>
    <enum name="ClassificationRisk">
      <value id="internal-only" description="No external API changes, no breaking changes" />
      <value id="new-api" description="Introduces new public interfaces or APIs" />
      <value id="breaking-changes" description="Modifies existing behavior or public contracts" />
    </enum>
    <enum name="ClassificationNovelty">
      <value id="familiar" description="Well-known patterns, team has done this before" />
      <value id="new-territory" description="Unfamiliar domain, requires research and exploration" />
    </enum>
    <enum name="ResearchDepth">
      <value id="quick-scan" description="Familiar domain, low complexity — brief prior art check (local only)" />
      <value id="standard-research" description="Moderate complexity or some novelty — find existing patterns and standards (local + docs)" />
      <value id="deep-dive" description="High complexity, new territory, or high risk — thorough domain analysis (local + web)" />
    </enum>
  </enums>
  <!-- ═══════════════════════════════════════════════════════════════════════
     LABELS (closed set)

     Label schema: aura:p{phase}-{domain}:s{step}-{type}
     Special labels do not follow the phase pattern.
     ═══════════════════════════════════════════════════════════════════════ -->
  <labels>
    <!-- Phase labels (one per substep) -->
    <label id="L-p1s1_1" value="aura:p1-user:s1_1-classify" phase-ref="p1" substep-ref="s1_1" />
    <label id="L-p1s1_2" value="aura:p1-user:s1_2-research" phase-ref="p1" substep-ref="s1_2" />
    <label id="L-p1s1_3" value="aura:p1-user:s1_3-explore" phase-ref="p1" substep-ref="s1_3" />
    <label id="L-p2s2_1" value="aura:p2-user:s2_1-elicit" phase-ref="p2" substep-ref="s2_1" />
    <label id="L-p2s2_2" value="aura:p2-user:s2_2-urd" phase-ref="p2" substep-ref="s2_2" />
    <label id="L-p3s3" value="aura:p3-plan:s3-propose" phase-ref="p3" substep-ref="s3" />
    <label id="L-p4s4" value="aura:p4-plan:s4-review" phase-ref="p4" substep-ref="s4" />
    <label id="L-p5s5" value="aura:p5-user:s5-uat" phase-ref="p5" substep-ref="s5" />
    <label id="L-p6s6" value="aura:p6-plan:s6-ratify" phase-ref="p6" substep-ref="s6" />
    <label id="L-p7s7" value="aura:p7-plan:s7-handoff" phase-ref="p7" substep-ref="s7" />
    <label id="L-p8s8" value="aura:p8-impl:s8-plan" phase-ref="p8" substep-ref="s8" />
    <label id="L-p9s9" value="aura:p9-impl:s9-slice" phase-ref="p9" substep-ref="s9" />
    <label id="L-p10s10" value="aura:p10-impl:s10-review" phase-ref="p10" substep-ref="s10" />
    <label id="L-p11s11" value="aura:p11-user:s11-uat" phase-ref="p11" substep-ref="s11" />
    <label id="L-p12s12" value="aura:p12-impl:s12-landing" phase-ref="p12" substep-ref="s12" />
    <!-- Special labels (not phase-scoped) -->
    <label id="L-urd" value="aura:urd" special="true" description="User Requirements Document" />
    <label id="L-superseded" value="aura:superseded" special="true" description="Superseded proposal or plan" />
    <label id="L-sev-blocker" value="aura:severity:blocker" special="true" severity-ref="BLOCKER" />
    <label id="L-sev-import" value="aura:severity:important" special="true" severity-ref="IMPORTANT" />
    <label id="L-sev-minor" value="aura:severity:minor" special="true" severity-ref="MINOR" />
    <label id="L-followup" value="aura:epic-followup" special="true" description="Follow-up epic for non-blocking findings" />
  </labels>
  <!-- ═══════════════════════════════════════════════════════════════════════
     REVIEW AXES
     ═══════════════════════════════════════════════════════════════════════ -->
  <review-axes>
    <axis id="axis-A" letter="A" name="Correctness" short="Spirit and technicality">
      <key-questions>
        <q>Does the implementation faithfully serve the user's original request?</q>
        <q>Are technical decisions consistent with the rationale in the proposal?</q>
        <q>Are there gaps where the proposal says one thing but the code does another?</q>
      </key-questions>
    </axis>
    <axis id="axis-B" letter="B" name="Test quality" short="Test strategy adequacy">
      <key-questions>
        <q>Favour integration tests over brittle unit tests?</q>
        <q>System under test NOT mocked — mock dependencies only?</q>
        <q>Shared fixtures for common test values?</q>
        <q>Assert observable outcomes, not internal state?</q>
      </key-questions>
    </axis>
    <axis id="axis-C" letter="C" name="Elegance" short="Complexity matching">
      <key-questions>
        <q>Design the API you know you will need?</q>
        <q>No over-engineering (premature abstractions, plugin systems)?</q>
        <q>No under-engineering (cutting corners on security or correctness)?</q>
        <q>Complexity proportional to innate problem complexity?</q>
      </key-questions>
    </axis>
  </review-axes>
  <!-- ═══════════════════════════════════════════════════════════════════════
     PHASES (12-phase lifecycle)

     Order of operations is defined by:
       1. phase/@number (global ordering)
       2. substep/@order within a phase
       3. substep/@execution + @parallel-group (concurrency)
       4. transition/@condition (gate to next phase)
     ═══════════════════════════════════════════════════════════════════════ -->
  <phases>
    <phase id="p1" number="1" domain="user" name="Request">
      <description>Capture, classify, research, and explore user request</description>
      <substeps>
        <substep id="s1_1" type="classify" execution="sequential" order="1" label-ref="L-p1s1_1">
          <description>Classify request along 4 axes: scope, complexity, risk, domain novelty</description>
        </substep>
        <substep id="s1_2" type="research" execution="parallel" order="2" parallel-group="p1-discovery" label-ref="L-p1s1_2">
          <description>Find domain standards, prior art, relevant documentation</description>
        </substep>
        <substep id="s1_3" type="explore" execution="parallel" order="2" parallel-group="p1-discovery" label-ref="L-p1s1_3">
          <description>Codebase exploration for integration points</description>
        </substep>
      </substeps>
      <task-title pattern="REQUEST: {description}" />
      <transitions>
        <transition to-phase="p2" condition="classification confirmed, research and explore complete" />
      </transitions>
    </phase>
    <phase id="p2" number="2" domain="user" name="Elicit">
      <description>User Requirements Elicitation survey and URD creation</description>
      <substeps>
        <substep id="s2_1" type="elicit" execution="sequential" order="1" label-ref="L-p2s2_1">
          <description>URE survey: structured Q&amp;A with user to capture requirements</description>
        </substep>
        <substep id="s2_2" type="urd" execution="sequential" order="2" label-ref="L-p2s2_2">
          <description>Create URD as single source of truth for requirements</description>
          <extra-label ref="L-urd" />
        </substep>
      </substeps>
      <task-title pattern="ELICIT: {description}" substep="s2_1" />
      <task-title pattern="URD: {description}" substep="s2_2" />
      <task-title pattern="FOLLOWUP_URE: {description}" substep="s2_1">
        <convention>Scoping URE to determine which IMPORTANT/MINOR findings to address</convention>
      </task-title>
      <task-title pattern="FOLLOWUP_URD: {description}" substep="s2_2">
        <convention>Requirements doc for follow-up scope. References original URD.</convention>
      </task-title>
      <transitions>
        <transition to-phase="p3" condition="URD created with structured requirements" />
      </transitions>
    </phase>
    <phase id="p3" number="3" domain="plan" name="Propose">
      <description>Architect creates technical proposal</description>
      <substeps>
        <substep id="s3" type="propose" execution="sequential" order="1" label-ref="L-p3s3">
          <description>Full technical proposal: interfaces, approach, validation checklist, BDD criteria</description>
        </substep>
      </substeps>
      <task-title pattern="PROPOSAL-{N}: {description}" substep="s3">
        <convention>N increments per revision. Old proposals marked aura:superseded.</convention>
      </task-title>
      <task-title pattern="FOLLOWUP_PROPOSAL-{N}: {description}" substep="s3">
        <convention>Proposal accounting for original URD + FOLLOWUP_URD + outstanding findings</convention>
      </task-title>
      <transitions>
        <transition to-phase="p4" condition="proposal created" />
      </transitions>
    </phase>
    <phase id="p4" number="4" domain="plan" name="Review">
      <description>3 axis-specific reviewers assess proposal</description>
      <substeps>
        <substep id="s4" type="review" execution="parallel" order="1" label-ref="L-p4s4">
          <description>Each reviewer assesses one axis (A/B/C). All 3 must ACCEPT.</description>
          <instances count="3" per="review-axis" />
        </substep>
      </substeps>
      <task-title pattern="PROPOSAL-{N}-REVIEW-{axis}-{round}: {description}">
        <convention>axis=A|B|C, round starts at 1</convention>
      </task-title>
      <severity-tree enabled="false" reason="Plan reviews use binary ACCEPT/REVISE only" />
      <transitions>
        <transition to-phase="p5" condition="all 3 reviewers vote ACCEPT" />
        <transition to-phase="p3" condition="any reviewer votes REVISE" action="create PROPOSAL-{N+1}, mark current aura:superseded" />
      </transitions>
    </phase>
    <phase id="p5" number="5" domain="user" name="Plan UAT">
      <description>User acceptance test on the plan</description>
      <substeps>
        <substep id="s5" type="uat" execution="sequential" order="1" label-ref="L-p5s5">
          <description>Present plan to user with demonstrative examples. User approves or requests changes.</description>
        </substep>
      </substeps>
      <task-title pattern="UAT-{N}: {description}" />
      <transitions>
        <transition to-phase="p6" condition="user accepts plan" />
        <transition to-phase="p3" condition="user requests changes" action="create PROPOSAL-{N+1}" />
      </transitions>
    </phase>
    <phase id="p6" number="6" domain="plan" name="Ratify">
      <description>Ratify the accepted proposal, supersede old ones</description>
      <substeps>
        <substep id="s6" type="ratify" execution="sequential" order="1" label-ref="L-p6s6">
          <description>Add ratify label. Mark prior proposals aura:superseded. Create placeholder IMPL_PLAN.</description>
        </substep>
      </substeps>
      <same-actor-as phase-ref="p5" note="Architect performs p5, p6, p7 — no handoff between them" />
      <transitions>
        <transition to-phase="p7" condition="proposal ratified, IMPL_PLAN placeholder created" />
      </transitions>
    </phase>
    <phase id="p7" number="7" domain="plan" name="Handoff">
      <description>Architect hands off to supervisor</description>
      <substeps>
        <substep id="s7" type="handoff" execution="sequential" order="1" label-ref="L-p7s7">
          <description>Create handoff document with full inline provenance. Transfer to supervisor.</description>
        </substep>
      </substeps>
      <transitions>
        <transition to-phase="p8" condition="handoff document stored at .git/.aura/handoff/">
          <skill-invocation target-role="supervisor" command-ref="cmd-supervisor" directive="Supervisor launch prompt MUST start with Skill(/aura:supervisor)" />
        </transition>
      </transitions>
    </phase>
    <phase id="p8" number="8" domain="impl" name="Impl Plan">
      <description>Supervisor decomposes ratified plan into vertical slices</description>
      <substeps>
        <substep id="s8" type="plan" execution="sequential" order="1" label-ref="L-p8s8">
          <description>Identify production code paths. Create SLICE-N tasks with leaf tasks. Assign workers.</description>
          <startup-sequence>
            <step order="1">Call Skill(/aura:supervisor) to load role instructions</step>
            <step order="2">Read RATIFIED_PLAN and URD via bd show</step>
            <step order="3">Create standing explore team via TeamCreate before any codebase exploration</step>
            <step order="4" next-state="p8">Decompose into vertical slices</step>
            <step order="5">Create leaf tasks (L1/L2/L3) for every slice</step>
            <step order="6" next-state="p9">Spawn workers for leaf tasks</step>
          </startup-sequence>
        </substep>
      </substeps>
      <task-title pattern="IMPL_PLAN: {description}" substep="s8" />
      <task-title pattern="FOLLOWUP_IMPL_PLAN: {description}" substep="s8">
        <convention>Implementation plan for follow-up slices</convention>
      </task-title>
      <transitions>
        <transition to-phase="p9" condition="all slices created with leaf tasks, assigned, and dependency-chained" />
      </transitions>
    </phase>
    <phase id="p9" number="9" domain="impl" name="Worker Slices">
      <description>Parallel workers implement vertical slices</description>
      <substeps>
        <substep id="s9" type="slice" execution="parallel" order="1" label-ref="L-p9s9">
          <description>Each worker owns full vertical: types, tests, implementation, wiring</description>
          <instances count="N" per="production-code-path" />
        </substep>
      </substeps>
      <task-title pattern="SLICE-{N}: {description}" substep="s9">
        <convention>N identifies slice within the implementation plan</convention>
      </task-title>
      <task-title pattern="FOLLOWUP_SLICE-{N}: {description}" substep="s9">
        <convention>Follow-up slice. Adopts IMPORTANT/MINOR leaf tasks from original review as children (dual-parent: leaf blocks both original severity group AND follow-up slice).</convention>
      </task-title>
      <tdd-layers>
        <layer number="1" name="Types" description="Types, interfaces, schemas (no deps)" />
        <layer number="2" name="Tests" description="Tests importing production code (will fail initially)" />
        <layer number="3" name="Implementation" description="Make tests pass. Wire with real dependencies. No TODOs." />
      </tdd-layers>
      <transitions>
        <transition to-phase="p10" condition="all slices complete, quality gates pass" />
      </transitions>
    </phase>
    <phase id="p10" number="10" domain="impl" name="Code Review">
      <description>3 axis-specific reviewers review ALL slices</description>
      <substeps>
        <substep id="s10" type="review" execution="parallel" order="1" label-ref="L-p10s10">
          <description>Each reviewer reviews ALL slices against their axis. EAGER severity tree.</description>
          <instances count="3" per="review-axis" />
        </substep>
      </substeps>
      <task-title pattern="SLICE-{N}-REVIEW-{axis}-{round}: {description}" substep="s10">
        <convention>axis=A|B|C, round starts at 1</convention>
      </task-title>
      <task-title pattern="IMPL-REVIEW-{axis}-{round}: {description}" substep="s10">
        <convention>When reviewing all slices collectively</convention>
      </task-title>
      <severity-tree enabled="true" creation="eager">
        <rule>Always create 3 severity groups per review round, even if empty.</rule>
        <rule>Empty groups have no children and are closed immediately.</rule>
        <group severity-ref="BLOCKER" label-ref="L-sev-blocker" dual-parent="true" />
        <group severity-ref="IMPORTANT" label-ref="L-sev-import" />
        <group severity-ref="MINOR" label-ref="L-sev-minor" />
      </severity-tree>
      <followup-epic label-ref="L-followup" trigger="review-completion AND (IMPORTANT OR MINOR findings exist)" gated-on-blocker="false" owner-role="supervisor" />
      <transitions>
        <transition to-phase="p11" condition="all 3 reviewers ACCEPT, all BLOCKERs resolved" />
        <transition to-phase="p9" condition="any reviewer votes REVISE" action="fix BLOCKERs in affected slices, then re-review" />
      </transitions>
    </phase>
    <phase id="p11" number="11" domain="user" name="Impl UAT">
      <description>User acceptance test on the implementation</description>
      <substeps>
        <substep id="s11" type="uat" execution="sequential" order="1" label-ref="L-p11s11">
          <description>Present implementation to user. User approves or requests fixes.</description>
        </substep>
      </substeps>
      <transitions>
        <transition to-phase="p12" condition="user accepts implementation" />
        <transition to-phase="p9" condition="user requests changes" action="create fix tasks in affected slices" />
      </transitions>
    </phase>
    <phase id="p12" number="12" domain="impl" name="Landing">
      <description>Commit, push, close tasks, hand off</description>
      <substeps>
        <substep id="s12" type="landing" execution="sequential" order="1" label-ref="L-p12s12">
          <description>git agent-commit, bd sync, git push. Close upstream tasks.</description>
        </substep>
      </substeps>
      <transitions>
        <transition to-phase="complete" condition="git push succeeds, all tasks closed or dependency-resolved" />
      </transitions>
    </phase>
  </phases>
  <!-- ═══════════════════════════════════════════════════════════════════════
     ROLES

     Each role owns a set of phases and has access to specific commands.
     The role-phase mapping is the primary relationship; commands are
     grouped under their owning role.
     ═══════════════════════════════════════════════════════════════════════ -->
  <roles>
    <role id="epoch" name="Epoch" description="Master orchestrator for full 12-phase workflow">
      <owns-phases>
        <phase-ref ref="p1" />
        <phase-ref ref="p2" />
        <phase-ref ref="p3" />
        <phase-ref ref="p4" />
        <phase-ref ref="p5" />
        <phase-ref ref="p6" />
        <phase-ref ref="p7" />
        <phase-ref ref="p8" />
        <phase-ref ref="p9" />
        <phase-ref ref="p10" />
        <phase-ref ref="p11" />
        <phase-ref ref="p12" />
      </owns-phases>
      <delegates>
        <delegate to-role="architect" phases="p1,p2,p3,p4,p5,p6,p7" />
        <delegate to-role="supervisor" phases="p7,p8,p9,p10,p11,p12" />
      </delegates>
    </role>
    <role id="architect" name="Architect" description="Specification writer and implementation designer">
      <owns-phases>
        <phase-ref ref="p1" />
        <phase-ref ref="p2" />
        <phase-ref ref="p3" />
        <phase-ref ref="p4" />
        <phase-ref ref="p5" />
        <phase-ref ref="p6" />
        <phase-ref ref="p7" />
      </owns-phases>
      <label-awareness>
      aura:p1-user, aura:p2-user, aura:p3-plan, aura:p4-plan, aura:p5-user, aura:p6-plan, aura:p7-plan
    </label-awareness>
    </role>
    <role id="reviewer" name="Reviewer" description="End-user alignment reviewer for plans and code">
      <owns-phases>
        <phase-ref ref="p4" />
        <phase-ref ref="p10" />
      </owns-phases>
      <label-awareness>
      aura:p4-plan:s4-review, aura:p10-impl:s10-review, aura:severity:blocker, aura:severity:important, aura:severity:minor
    </label-awareness>
      <uses-axes>
        <axis-ref ref="axis-A" />
        <axis-ref ref="axis-B" />
        <axis-ref ref="axis-C" />
      </uses-axes>
    </role>
    <role id="supervisor" name="Supervisor" description="Task coordinator, spawns workers, manages parallel execution">
      <owns-phases>
        <phase-ref ref="p7" />
        <phase-ref ref="p8" />
        <phase-ref ref="p9" />
        <phase-ref ref="p10" />
        <phase-ref ref="p11" />
        <phase-ref ref="p12" />
      </owns-phases>
      <label-awareness>
      aura:p7-plan, aura:p8-impl, aura:p9-impl, aura:p10-impl, aura:p11-user, aura:p12-impl, aura:epic-followup
    </label-awareness>
      <invariants>
        <invariant>NEVER implements code — always spawns workers</invariant>
        <invariant>NEVER explores codebase directly — delegates to standing explore team</invariant>
        <invariant>ALWAYS creates leaf tasks within each slice — no undecomposed slices</invariant>
        <invariant>Creates follow-up epic when code review has IMPORTANT or MINOR findings</invariant>
      </invariants>
      <standing-teams>
        <team id="explore-team" purpose="Context-cached codebase exploration agents">
          <description>
          Standing team of explore agents created via TeamCreate at the start of Phase 8.
          Each agent is scoped to a specific codebase domain. Agents retain context between
          queries, making follow-up questions on the same domain near-zero-cost.
          Minimum 1 agent; scale based on feature complexity (1-4 agents).
        </description>
          <agent-template role="explore" skill-ref="cmd-explore" invocation="Skill(/aura:explore)" min-count="1" max-count="4">
            <scoping>Each agent assigned a specific codebase domain (e.g., CLI wiring, DB layer, build system)</scoping>
            <lifecycle>Created before exploration, shut down after all slices have leaf tasks</lifecycle>
          </agent-template>
        </team>
      </standing-teams>
    </role>
    <role id="worker" name="Worker" description="Vertical slice implementer (full production code path)">
      <owns-phases>
        <phase-ref ref="p9" />
      </owns-phases>
      <label-awareness>
      aura:p9-impl:s9-slice
    </label-awareness>
      <ownership-model>
      One worker per production code path. Owns full vertical
      (types → tests → implementation → wiring).
    </ownership-model>
    </role>
  </roles>
  <!-- ═══════════════════════════════════════════════════════════════════════
     COMMANDS (skills)

     Each skill maps to a SKILL.md file in skills/, belongs to a role,
     operates in specific phases, and may create specific labels on tasks.
     ═══════════════════════════════════════════════════════════════════════ -->
  <commands>
    <!-- ── Orchestration ──────────────────────────────────────────────── -->
    <command id="cmd-epoch" name="aura:epoch" role-ref="epoch" description="Master orchestrator for full 12-phase workflow">
      <phases>
        <phase-ref ref="p1" />
        <phase-ref ref="p2" />
        <phase-ref ref="p3" />
        <phase-ref ref="p4" />
        <phase-ref ref="p5" />
        <phase-ref ref="p6" />
        <phase-ref ref="p7" />
        <phase-ref ref="p8" />
        <phase-ref ref="p9" />
        <phase-ref ref="p10" />
        <phase-ref ref="p11" />
        <phase-ref ref="p12" />
      </phases>
      <file>skills/epoch/SKILL.md</file>
    </command>
    <command id="cmd-plan" name="aura:plan" role-ref="architect" description="Plan coordination across phases 1-6">
      <phases>
        <phase-ref ref="p1" />
        <phase-ref ref="p2" />
        <phase-ref ref="p3" />
        <phase-ref ref="p4" />
        <phase-ref ref="p5" />
        <phase-ref ref="p6" />
      </phases>
      <file>skills/plan/SKILL.md</file>
    </command>
    <command id="cmd-status" name="aura:status" description="Project status and monitoring via Beads queries">
      <file>skills/status/SKILL.md</file>
    </command>
    <!-- ── User interaction ───────────────────────────────────────── -->
    <command id="cmd-user-request" name="aura:user:request" role-ref="architect" description="Capture user feature request verbatim (Phase 1)">
      <phases>
        <phase-ref ref="p1" />
      </phases>
      <creates-labels>
        <label-ref ref="L-p1s1_1" />
      </creates-labels>
      <file>skills/user-request/SKILL.md</file>
    </command>
    <command id="cmd-user-elicit" name="aura:user:elicit" role-ref="architect" description="User Requirements Elicitation survey (Phase 2)">
      <phases>
        <phase-ref ref="p2" />
      </phases>
      <creates-labels>
        <label-ref ref="L-p2s2_1" />
        <label-ref ref="L-p2s2_2" />
        <label-ref ref="L-urd" />
      </creates-labels>
      <file>skills/user-elicit/SKILL.md</file>
    </command>
    <command id="cmd-user-uat" name="aura:user:uat" description="User Acceptance Testing with demonstrative examples">
      <phases>
        <phase-ref ref="p5" />
        <phase-ref ref="p11" />
      </phases>
      <creates-labels>
        <label-ref ref="L-p5s5" />
        <label-ref ref="L-p11s11" />
      </creates-labels>
      <file>skills/user-uat/SKILL.md</file>
    </command>
    <!-- ── Architect ──────────────────────────────────────────────────── -->
    <command id="cmd-architect" name="aura:architect" role-ref="architect" description="Specification writer and implementation designer">
      <phases>
        <phase-ref ref="p1" />
        <phase-ref ref="p2" />
        <phase-ref ref="p3" />
        <phase-ref ref="p4" />
        <phase-ref ref="p5" />
        <phase-ref ref="p6" />
        <phase-ref ref="p7" />
      </phases>
      <file>skills/architect/SKILL.md</file>
    </command>
    <command id="cmd-arch-propose" name="aura:architect:propose-plan" role-ref="architect" description="Create PROPOSAL-N task with full technical plan">
      <phases>
        <phase-ref ref="p3" />
      </phases>
      <creates-labels>
        <label-ref ref="L-p3s3" />
      </creates-labels>
      <file>skills/architect-propose-plan/SKILL.md</file>
    </command>
    <command id="cmd-arch-review" name="aura:architect:request-review" role-ref="architect" description="Spawn 3 axis-specific reviewers (A/B/C)">
      <phases>
        <phase-ref ref="p4" />
      </phases>
      <creates-labels>
        <label-ref ref="L-p4s4" />
      </creates-labels>
      <file>skills/architect-request-review/SKILL.md</file>
    </command>
    <command id="cmd-arch-ratify" name="aura:architect:ratify" role-ref="architect" description="Ratify proposal, mark old proposals aura:superseded">
      <phases>
        <phase-ref ref="p6" />
      </phases>
      <creates-labels>
        <label-ref ref="L-p6s6" />
        <label-ref ref="L-superseded" />
      </creates-labels>
      <file>skills/architect-ratify/SKILL.md</file>
    </command>
    <command id="cmd-arch-handoff" name="aura:architect:handoff" role-ref="architect" description="Create handoff document and transfer to supervisor">
      <phases>
        <phase-ref ref="p7" />
      </phases>
      <creates-labels>
        <label-ref ref="L-p7s7" />
      </creates-labels>
      <file>skills/architect-handoff/SKILL.md</file>
    </command>
    <!-- ── Supervisor ─────────────────────────────────────────────────── -->
    <command id="cmd-supervisor" name="aura:supervisor" role-ref="supervisor" description="Task coordinator, spawns workers, manages parallel execution">
      <phases>
        <phase-ref ref="p7" />
        <phase-ref ref="p8" />
        <phase-ref ref="p9" />
        <phase-ref ref="p10" />
        <phase-ref ref="p11" />
        <phase-ref ref="p12" />
      </phases>
      <file>skills/supervisor/SKILL.md</file>
    </command>
    <command id="cmd-sup-plan" name="aura:supervisor:plan-tasks" role-ref="supervisor" description="Decompose ratified plan into vertical slices (SLICE-N)">
      <phases>
        <phase-ref ref="p8" />
      </phases>
      <creates-labels>
        <label-ref ref="L-p8s8" />
        <label-ref ref="L-p9s9" />
      </creates-labels>
      <file>skills/supervisor-plan-tasks/SKILL.md</file>
    </command>
    <command id="cmd-sup-spawn" name="aura:supervisor:spawn-worker" role-ref="supervisor" description="Launch a worker agent for an assigned slice">
      <phases>
        <phase-ref ref="p9" />
      </phases>
      <creates-labels>
        <label-ref ref="L-p9s9" />
      </creates-labels>
      <file>skills/supervisor-spawn-worker/SKILL.md</file>
    </command>
    <command id="cmd-sup-track" name="aura:supervisor:track-progress" role-ref="supervisor" description="Monitor worker status via Beads">
      <phases>
        <phase-ref ref="p9" />
        <phase-ref ref="p10" />
      </phases>
      <file>skills/supervisor-track-progress/SKILL.md</file>
    </command>
    <command id="cmd-sup-commit" name="aura:supervisor:commit" role-ref="supervisor" description="Atomic commit per completed layer/slice">
      <phases>
        <phase-ref ref="p12" />
      </phases>
      <creates-labels>
        <label-ref ref="L-p12s12" />
      </creates-labels>
      <file>skills/supervisor-commit/SKILL.md</file>
    </command>
    <!-- ── Worker ─────────────────────────────────────────────────────── -->
    <command id="cmd-worker" name="aura:worker" role-ref="worker" description="Vertical slice implementer (full production code path)">
      <phases>
        <phase-ref ref="p9" />
      </phases>
      <file>skills/worker/SKILL.md</file>
    </command>
    <command id="cmd-work-impl" name="aura:worker:implement" role-ref="worker" description="Implement assigned vertical slice following TDD layers">
      <phases>
        <phase-ref ref="p9" />
      </phases>
      <creates-labels>
        <label-ref ref="L-p9s9" />
      </creates-labels>
      <file>skills/worker-implement/SKILL.md</file>
    </command>
    <command id="cmd-work-complete" name="aura:worker:complete" role-ref="worker" description="Signal slice completion after quality gates pass">
      <phases>
        <phase-ref ref="p9" />
      </phases>
      <file>skills/worker-complete/SKILL.md</file>
    </command>
    <command id="cmd-work-blocked" name="aura:worker:blocked" role-ref="worker" description="Report a blocker to supervisor via Beads">
      <phases>
        <phase-ref ref="p9" />
      </phases>
      <file>skills/worker-blocked/SKILL.md</file>
    </command>
    <!-- ── Reviewer ───────────────────────────────────────────────────── -->
    <command id="cmd-reviewer" name="aura:reviewer" role-ref="reviewer" description="End-user alignment reviewer for plans and code">
      <phases>
        <phase-ref ref="p4" />
        <phase-ref ref="p10" />
      </phases>
      <file>skills/reviewer/SKILL.md</file>
    </command>
    <command id="cmd-rev-plan" name="aura:reviewer:review-plan" role-ref="reviewer" description="Evaluate proposal against one axis (binary ACCEPT/REVISE)">
      <phases>
        <phase-ref ref="p4" />
      </phases>
      <creates-labels>
        <label-ref ref="L-p4s4" />
      </creates-labels>
      <file>skills/reviewer-review-plan/SKILL.md</file>
    </command>
    <command id="cmd-rev-code" name="aura:reviewer:review-code" role-ref="reviewer" description="Review implementation slices with EAGER severity tree">
      <phases>
        <phase-ref ref="p10" />
      </phases>
      <creates-labels>
        <label-ref ref="L-p10s10" />
        <label-ref ref="L-sev-blocker" />
        <label-ref ref="L-sev-import" />
        <label-ref ref="L-sev-minor" />
      </creates-labels>
      <file>skills/reviewer-review-code/SKILL.md</file>
    </command>
    <command id="cmd-rev-comment" name="aura:reviewer:comment" role-ref="reviewer" description="Leave structured review comment via Beads">
      <phases>
        <phase-ref ref="p4" />
        <phase-ref ref="p10" />
      </phases>
      <file>skills/reviewer-comment/SKILL.md</file>
    </command>
    <command id="cmd-rev-vote" name="aura:reviewer:vote" role-ref="reviewer" description="Cast ACCEPT or REVISE vote (binary only)">
      <phases>
        <phase-ref ref="p4" />
        <phase-ref ref="p10" />
      </phases>
      <file>skills/reviewer-vote/SKILL.md</file>
    </command>
    <!-- ── Implementation coordination ────────────────────────────────── -->
    <command id="cmd-impl-slice" name="aura:impl:slice" role-ref="supervisor" description="Vertical slice assignment and tracking">
      <phases>
        <phase-ref ref="p9" />
      </phases>
      <creates-labels>
        <label-ref ref="L-p9s9" />
      </creates-labels>
      <file>skills/impl-slice/SKILL.md</file>
    </command>
    <command id="cmd-impl-review" name="aura:impl:review" role-ref="supervisor" description="Code review coordination across all slices (Phase 10)">
      <phases>
        <phase-ref ref="p10" />
      </phases>
      <creates-labels>
        <label-ref ref="L-p10s10" />
        <label-ref ref="L-sev-blocker" />
        <label-ref ref="L-sev-import" />
        <label-ref ref="L-sev-minor" />
      </creates-labels>
      <file>skills/impl-review/SKILL.md</file>
    </command>
    <!-- ── Messaging (Beads-based IPC) ────────────────────────────────── -->
    <command id="cmd-msg-send" name="aura:msg:send" description="Send a message to another agent via Beads comment">
      <file>skills/msg-send/SKILL.md</file>
    </command>
    <command id="cmd-msg-receive" name="aura:msg:receive" description="Check inbox for messages from other agents">
      <file>skills/msg-receive/SKILL.md</file>
    </command>
    <command id="cmd-msg-broadcast" name="aura:msg:broadcast" description="Broadcast a message to multiple agents">
      <file>skills/msg-broadcast/SKILL.md</file>
    </command>
    <command id="cmd-msg-ack" name="aura:msg:ack" description="Acknowledge received messages">
      <file>skills/msg-ack/SKILL.md</file>
    </command>
    <!-- ── Exploration ────────────────────────────────────────────────── -->
    <command id="cmd-explore" name="aura:explore" description="Codebase exploration — find integration points, existing patterns, and related code">
      <phases>
        <phase-ref ref="p1" />
        <phase-ref ref="p8" />
      </phases>
      <creates-labels>
        <label-ref ref="L-p1s1_3" />
      </creates-labels>
      <file>skills/explore/SKILL.md</file>
      <note>Used in Phase 1 (s1_3) by architect, and in Phase 8 by supervisor's standing explore team.</note>
    </command>
    <command id="cmd-research" name="aura:research" description="Domain research — find standards, prior art, and competing approaches">
      <phases>
        <phase-ref ref="p1" />
      </phases>
      <creates-labels>
        <label-ref ref="L-p1s1_2" />
      </creates-labels>
      <file>skills/research/SKILL.md</file>
    </command>
    <!-- ── Utilities ──────────────────────────────────────────────────── -->
    <command id="cmd-test" name="aura:test" description="Run tests using BDD patterns">
      <file>skills/test/SKILL.md</file>
    </command>
    <command id="cmd-feedback" name="aura:feedback" description="Leave structured feedback on any Beads task">
      <file>skills/feedback/SKILL.md</file>
    </command>
  </commands>
  <!-- ═══════════════════════════════════════════════════════════════════════
     HANDOFFS (actor-change transitions)

     6 transitions require handoff documents.
     Same-actor transitions (p5→p6, p6→p7) do NOT require handoffs.
     ═══════════════════════════════════════════════════════════════════════ -->
  <handoffs storage-pattern=".git/.aura/handoff/{request-task-id}/{source}-to-{target}.md">
    <handoff id="h1" source-role="architect" target-role="supervisor" at-phase="p7" content-level="full-provenance" file-pattern="architect-to-supervisor.md">
      <required-fields>
      request, urd, proposal, ratified-plan, context, key-decisions, open-items, acceptance-criteria
    </required-fields>
      <skill-invocation directive="Skill(/aura:supervisor)" note="Supervisor launch prompt MUST start with this invocation. Without it, supervisor skips explore team setup and leaf task creation." />
    </handoff>
    <handoff id="h2" source-role="supervisor" target-role="worker" at-phase="p9" content-level="summary-with-ids" file-pattern="supervisor-to-worker.md">
      <required-fields>
      request, urd, proposal, ratified-plan, impl-plan, slice, context, key-decisions, open-items, acceptance-criteria
    </required-fields>
      <skill-invocation directive="Skill(/aura:worker)" note="Worker message MUST include explicit instruction to call this skill." />
    </handoff>
    <handoff id="h3" source-role="supervisor" target-role="reviewer" at-phase="p10" content-level="summary-with-ids" file-pattern="supervisor-to-reviewer.md">
      <required-fields>
      request, urd, proposal, ratified-plan, impl-plan, context, key-decisions, acceptance-criteria
    </required-fields>
      <skill-invocation directive="Skill(/aura:reviewer)" note="Reviewer prompt MUST include instruction to call this skill." />
    </handoff>
    <handoff id="h4" source-role="worker" target-role="reviewer" at-phase="p10" content-level="summary-with-ids" file-pattern="worker-to-reviewer.md">
      <required-fields>
      request, urd, impl-plan, slice, context, key-decisions, open-items
    </required-fields>
    </handoff>
    <handoff id="h5" source-role="reviewer" target-role="supervisor" at-phase="p10" content-level="summary-with-ids" file-pattern="reviewer-to-followup.md" trigger="IMPORTANT or MINOR findings exist">
      <required-fields>
      request, urd, proposal, context, key-decisions, open-items, acceptance-criteria
    </required-fields>
      <note>
      Reviewer hands IMPORTANT/MINOR findings to supervisor, who creates the follow-up epic
    </note>
    </handoff>
    <handoff id="h6" source-role="supervisor" target-role="architect" at-phase="p3" content-level="summary-with-ids" file-pattern="supervisor-to-architect.md" context="follow-up lifecycle only">
      <required-fields>
      request, urd, followup-epic, followup-ure, followup-urd, context, key-decisions, findings-summary, acceptance-criteria
    </required-fields>
      <note>
      Follow-up specific. Supervisor completes FOLLOWUP_URE and FOLLOWUP_URD,
      then hands off to architect with scoped findings and requirements
      for FOLLOWUP_PROPOSAL creation.
    </note>
    </handoff>
    <same-actor-transitions note="No handoff document needed">
      <transition from-phase="p5" to-phase="p6" actor="architect" />
      <transition from-phase="p6" to-phase="p7" actor="architect" />
    </same-actor-transitions>
  </handoffs>
  <!-- ═══════════════════════════════════════════════════════════════════════
     CONSTRAINTS (Given/When/Then/Should)

     Protocol-level constraints. Coding-standard constraints live in
     CONSTRAINTS.md and are not duplicated here.
     ═══════════════════════════════════════════════════════════════════════ -->
  <constraints>
    <!-- Audit trail -->
    <constraint id="C-audit-never-delete" given="any task or label" when="modifying" then="add labels and comments only" should-not="delete or close tasks prematurely, remove labels" />
    <constraint id="C-audit-dep-chain" given="any phase transition" when="creating new task" then="chain dependency: bd dep add parent --blocked-by child" should-not="skip dependency chaining or invert direction" />
    <!-- Reviews -->
    <constraint id="C-review-consensus" given="review cycle (p4 or p10)" when="evaluating" then="all 3 reviewers must ACCEPT before proceeding" should-not="proceed with any REVISE vote outstanding" role-ref="epoch,reviewer,supervisor" phase-ref="p4,p10" />
    <constraint id="C-review-binary" given="a reviewer" when="voting" then="use ACCEPT or REVISE only" should-not="use APPROVE, APPROVE_WITH_COMMENTS, REQUEST_CHANGES, or REJECT" role-ref="reviewer" phase-ref="p4,p10" />
    <constraint id="C-severity-eager" given="code review round (p10 only)" when="starting review" then="ALWAYS create 3 severity group tasks (BLOCKER, IMPORTANT, MINOR) immediately" should-not="lazily create severity groups only when findings exist" role-ref="reviewer" phase-ref="p10" />
    <constraint id="C-severity-not-plan" given="plan review (p4)" when="reviewing" then="use binary ACCEPT/REVISE only" should-not="create severity tree for plan reviews" role-ref="reviewer" phase-ref="p4" />
    <constraint id="C-blocker-dual-parent" given="a BLOCKER finding in code review" when="recording" then="add as child of BOTH the severity group AND the slice it blocks" should-not="add to severity group only" role-ref="reviewer" phase-ref="p10" />
    <constraint id="C-followup-timing" given="code review completion with IMPORTANT or MINOR findings" when="creating follow-up epic" then="create immediately upon review completion" should-not="gate follow-up epic on BLOCKER resolution" role-ref="supervisor" phase-ref="p10" />
    <!-- Ownership -->
    <constraint id="C-vertical-slices" given="implementation decomposition" when="assigning work" then="each production code path owned by exactly ONE worker (full vertical)" should-not="assign horizontal layers or same path to multiple workers" role-ref="supervisor" phase-ref="p8,p9" />
    <constraint id="C-supervisor-no-impl" given="supervisor role" when="implementation phase" then="spawn workers for all code changes" should-not="implement code directly" role-ref="supervisor" phase-ref="p8,p9" />
    <constraint id="C-supervisor-cartographers" given="supervisor needs codebase exploration and code review" when="starting Phase 8 (IMPL_PLAN) and Phase 10 (Code Review)" then="create exactly 3 Cartographers via TeamCreate with /aura:explore before any exploration; Cartographers are dual-role: explore codebase in Phase 8, switch to /aura:reviewer in Phase 10; Cartographers NEVER shut down between phases — persist for full Ride the Wave cycle; max 3 worker-reviewer cycles; supervisor shuts down Cartographers after cycle 3 or all-ACCEPT" should-not="perform deep codebase exploration directly as supervisor; shut down Cartographers between Phase 8 and Phase 10; exceed 3 worker-reviewer cycles" role-ref="epoch,supervisor" phase-ref="p8,p9,p10" />
    <constraint id="C-integration-points" given="multiple vertical slices share types, interfaces, or data flows" when="decomposing IMPL_PLAN in Phase 8" then="identify horizontal Layer Integration Points and document them in IMPL_PLAN; each integration point specifies: owning slice, consuming slices, shared contract, merge timing; include integration points in slice descriptions so workers know what to export and import" should-not="leave cross-slice dependencies implicit; assume workers will discover contracts on their own" role-ref="epoch,supervisor" phase-ref="p8" />
    <constraint id="C-slice-review-before-close" given="workers complete their implementation slices" when="slice implementation is done" then="workers notify supervisor with bd comments add (not bd close); slices must be reviewed at least once by Cartographers before closure; only the supervisor closes slices, after review passes" should-not="close slices immediately upon worker completion; allow workers to close their own slices" role-ref="epoch,supervisor" phase-ref="p9,p10" />
    <constraint id="C-max-review-cycles" given="worker-Cartographer review-fix cycles are ongoing" when="counting review-fix iterations" then="limit to a maximum of 3 cycles total; after cycle 3, remaining IMPORTANT findings move to FOLLOWUP epic; proceed to Phase 11 (UAT) regardless of remaining IMPORTANTs after cycle 3" should-not="exceed 3 worker-reviewer cycles; block UAT on non-BLOCKER findings after 3 cycles" role-ref="epoch,supervisor" phase-ref="p10" />
    <constraint id="C-slice-leaf-tasks" given="vertical slice created" when="decomposing slice into implementation units" then="create Beads leaf tasks (L1: types, L2: tests, L3: impl) within each slice with bd dep add slice-id --blocked-by leaf-task-id" should-not="create slices without leaf tasks — a slice with no children is undecomposed and cannot be tracked" role-ref="supervisor" phase-ref="p8,p9" />
    <constraint id="C-handoff-skill-invocation" given="an agent is launched for a new phase (especially p7 to p8 handoff)" when="composing the launch prompt" then="prompt MUST start with Skill(/aura:{role}) invocation directive so the agent loads its role instructions" should-not="launch agents without skill invocation — they skip role-critical procedures like explore team setup and leaf task creation" role-ref="epoch,architect,supervisor" phase-ref="p7" />
    <!-- Task management -->
    <constraint id="C-dep-direction" given="adding a Beads dependency" when="determining direction" then="parent blocked-by child: bd dep add stays-open --blocked-by must-finish-first" should-not="invert (child blocked-by parent)" />
    <constraint id="C-frontmatter-refs" given="cross-task references (URD, request, etc.)" when="linking tasks" then="use description frontmatter references: block" should-not="use bd dep relate (buggy) or blocking dependencies for reference docs" />
    <!-- Git -->
    <constraint id="C-agent-commit" given="code is ready to commit" when="committing" then="use git agent-commit -m ..." should-not="use git commit -m ..." role-ref="architect,supervisor,worker" phase-ref="p9,p12" />
    <!-- Naming -->
    <constraint id="C-proposal-naming" given="a new or revised proposal" when="creating task" then="title PROPOSAL-{N} where N increments; mark old as aura:superseded" should-not="reuse N or delete old proposals" role-ref="architect" phase-ref="p3" />
    <constraint id="C-review-naming" given="a review task" when="creating" then="title {SCOPE}-REVIEW-{axis}-{round} where axis=A|B|C, round starts at 1" should-not="use numeric reviewer IDs (1/2/3) instead of axis letters" role-ref="reviewer" phase-ref="p4,p10" />
    <!-- User interviews -->
    <constraint id="C-ure-verbatim" given="user interview (URE or UAT)" when="recording in Beads" then="capture full question text, ALL option descriptions, AND user's verbatim response" should-not="summarize options as (1)/(2)/(3) without option text" role-ref="architect" phase-ref="p2,p5,p11" />
    <!-- Follow-up lifecycle -->
    <constraint id="C-followup-lifecycle" given="follow-up epic created" when="starting follow-up work" then="run same protocol phases with FOLLOWUP_* prefix: FOLLOWUP_URE → FOLLOWUP_URD → FOLLOWUP_PROPOSAL → FOLLOWUP_IMPL_PLAN → FOLLOWUP_SLICE" should-not="skip the follow-up lifecycle or treat the follow-up epic as a flat task list" role-ref="supervisor" phase-ref="p10" />
    <constraint id="C-followup-leaf-adoption" given="supervisor creates FOLLOWUP_SLICE-N" when="assigning original IMPORTANT/MINOR leaf tasks to follow-up slices" then="add leaf task as child of follow-up slice (dual-parent: leaf blocks both severity group AND follow-up slice)" should-not="remove the leaf task from its original severity group parent" role-ref="supervisor" phase-ref="p10" />
    <!-- Worker completion -->
    <constraint id="C-worker-gates" given="worker finishes implementation" when="signaling completion" then="run quality gates (typecheck + tests) AND verify production code path (no TODOs, real deps)" should-not="close with only 'tests pass' as completion gate" role-ref="worker" phase-ref="p9" />
    <!-- Error quality -->
    <constraint id="C-actionable-errors" given="an error, exception, or user-facing message" when="creating or raising" then="make it actionable: describe (1) what went wrong, (2) why it happened, (3) where it failed (file location, module, or function), (4) when it failed (step, operation, or timestamp), (5) what it means for the caller, and (6) how to fix it" should-not="raise generic or opaque error messages (e.g. 'invalid input', 'operation failed') that don't guide the user toward resolution" />
  </constraints>
  <!-- ═══════════════════════════════════════════════════════════════════════
     TASK TITLE CONVENTIONS

     Mapping from task titles to labels and creating roles.
     ═══════════════════════════════════════════════════════════════════════ -->
  <task-titles>
    <title-convention pattern="REQUEST: {description}" label-ref="L-p1s1_1" created-by="epoch,architect" phase-ref="p1" />
    <title-convention pattern="ELICIT: {description}" label-ref="L-p2s2_1" created-by="architect" phase-ref="p2" />
    <title-convention pattern="URD: {description}" label-ref="L-p2s2_2" created-by="architect" phase-ref="p2" extra-label-ref="L-urd" />
    <title-convention pattern="PROPOSAL-{N}: {description}" label-ref="L-p3s3" created-by="architect" phase-ref="p3" note="N increments per revision. Old proposals marked aura:superseded." />
    <title-convention pattern="PROPOSAL-{N}-REVIEW-{axis}-{round}: {description}" label-ref="L-p4s4" created-by="reviewer" phase-ref="p4" note="axis=A|B|C, round starts at 1" />
    <title-convention pattern="UAT-{N}: {description}" label-ref="L-p5s5" created-by="architect" phase-ref="p5" />
    <title-convention pattern="IMPL_PLAN: {description}" label-ref="L-p8s8" created-by="supervisor" phase-ref="p8" />
    <title-convention pattern="SLICE-{N}: {description}" label-ref="L-p9s9" created-by="supervisor" phase-ref="p9" note="N identifies slice within the implementation plan" />
    <title-convention pattern="SLICE-{N}-REVIEW-{axis}-{round}: {description}" label-ref="L-p10s10" created-by="reviewer" phase-ref="p10" note="axis=A|B|C, round starts at 1" />
    <title-convention pattern="IMPL-REVIEW-{axis}-{round}: {description}" label-ref="L-p10s10" created-by="supervisor" phase-ref="p10" note="When reviewing all slices collectively" />
    <title-convention pattern="FOLLOWUP: {description}" label-ref="L-followup" created-by="supervisor" note="Follow-up epic created after code review with IMPORTANT/MINOR findings. Single-parent epic relationship — no followup-of-followup." />
    <title-convention pattern="FOLLOWUP_URE: {description}" label-ref="L-p2s2_1" created-by="supervisor" phase-ref="p2" note="Scoping URE to determine which IMPORTANT/MINOR findings to address" />
    <title-convention pattern="FOLLOWUP_URD: {description}" label-ref="L-p2s2_2" created-by="supervisor" phase-ref="p2" extra-label-ref="L-urd" note="Requirements doc for follow-up scope. References original URD." />
    <title-convention pattern="FOLLOWUP_PROPOSAL-{N}: {description}" label-ref="L-p3s3" created-by="architect" phase-ref="p3" note="Proposal accounting for original URD + FOLLOWUP_URD + outstanding findings" />
    <title-convention pattern="FOLLOWUP_IMPL_PLAN: {description}" label-ref="L-p8s8" created-by="supervisor" phase-ref="p8" note="Implementation plan for follow-up slices" />
    <title-convention pattern="FOLLOWUP_SLICE-{N}: {description}" label-ref="L-p9s9" created-by="supervisor" phase-ref="p9" note="Follow-up slice. Adopts IMPORTANT/MINOR leaf tasks from original review as children (dual-parent: leaf blocks both original severity group AND follow-up slice)." />
  </task-titles>
  <!-- ═══════════════════════════════════════════════════════════════════════
     DOCUMENTS

     Mapping from protocol documentation files to the entities they cover.
     ═══════════════════════════════════════════════════════════════════════ -->
  <documents>
    <!-- Root-level docs (project-specific, not protocol-reusable) -->
    <document id="doc-readme" path="protocol/README.md" purpose="Protocol entry point and quick-start guide">
      <covers>
        <entity type="phase" depth="overview" refs="p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12" />
        <entity type="label" depth="schema-summary" refs="all" />
      </covers>
    </document>
    <document id="doc-claude" path="protocol/CLAUDE.md" purpose="Core agent directive: philosophy, constraints, roles, label schema">
      <covers>
        <entity type="phase" depth="summary" refs="p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12" />
        <entity type="role" depth="summary" refs="architect,reviewer,supervisor,worker" />
        <entity type="label" depth="full" refs="all" />
        <entity type="constraint" depth="full" refs="all-protocol" />
        <entity type="task-title" depth="full" refs="all" />
        <entity type="handoff" depth="summary" refs="h1,h2,h3,h4,h5,h6" />
        <entity type="severity" depth="full" refs="BLOCKER,IMPORTANT,MINOR" />
        <entity type="review-axis" depth="summary" refs="axis-A,axis-B,axis-C" />
      </covers>
    </document>
    <document id="doc-constraints" path="protocol/CONSTRAINTS.md" purpose="Coding standards, checklists, severity definitions, naming conventions">
      <covers>
        <entity type="constraint" depth="full" refs="all" />
        <entity type="severity" depth="full" refs="BLOCKER,IMPORTANT,MINOR" />
        <entity type="vote" depth="full" refs="ACCEPT,REVISE" />
        <entity type="label" depth="schema" refs="all" />
        <entity type="task-title" depth="full" refs="all" />
      </covers>
    </document>
    <document id="doc-process" path="protocol/PROCESS.md" purpose="Step-by-step workflow execution (single source of truth)">
      <covers>
        <entity type="phase" depth="full" refs="p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12" />
        <entity type="substep" depth="full" refs="all" />
        <entity type="role" depth="tools-matrix" refs="architect,reviewer,supervisor,worker" />
        <entity type="command" depth="tools-matrix" refs="all" />
        <entity type="label" depth="full" refs="all" />
        <entity type="transition" depth="full" refs="all" />
        <entity type="severity" depth="full" refs="BLOCKER,IMPORTANT,MINOR" />
      </covers>
    </document>
    <document id="doc-agents" path="protocol/AGENTS.md" purpose="Role taxonomy: phases owned, tools, handoffs per agent">
      <covers>
        <entity type="role" depth="full" refs="epoch,architect,reviewer,supervisor,worker" />
        <entity type="phase" depth="role-mapping" refs="all" />
        <entity type="command" depth="role-mapping" refs="all" />
        <entity type="handoff" depth="full" refs="h1,h2,h3,h4,h5,h6" />
        <entity type="review-axis" depth="full" refs="axis-A,axis-B,axis-C" />
      </covers>
    </document>
    <document id="doc-skills" path="protocol/SKILLS.md" purpose="Command reference: all /aura:* skills mapped to phase and role">
      <covers>
        <entity type="command" depth="full" refs="all" />
        <entity type="phase" depth="command-mapping" refs="all" />
        <entity type="role" depth="command-mapping" refs="all" />
        <entity type="label" depth="command-creates" refs="all" />
        <entity type="review-axis" depth="summary" refs="axis-A,axis-B,axis-C" />
      </covers>
    </document>
    <document id="doc-handoff" path="protocol/HANDOFF_TEMPLATE.md" purpose="Standardized template for 6 actor-change transitions">
      <covers>
        <entity type="handoff" depth="full" refs="h1,h2,h3,h4,h5,h6" />
        <entity type="role" depth="handoff-fields" refs="architect,supervisor,worker,reviewer" />
      </covers>
    </document>
    <document id="doc-migration" path="protocol/MIGRATION_v1_to_v2.md" purpose="Label and title migration from v1 to v2">
      <covers>
        <entity type="label" depth="v1-v2-mapping" refs="all" />
        <entity type="task-title" depth="v1-v2-mapping" refs="all" />
        <entity type="vote" depth="v1-v2-mapping" refs="ACCEPT,REVISE" />
      </covers>
    </document>
    <document id="doc-uat-template" path="protocol/UAT_TEMPLATE.md" purpose="User Acceptance Test structured output template">
      <covers>
        <entity type="phase" depth="template" refs="p5,p11" />
      </covers>
    </document>
    <document id="doc-uat-example" path="protocol/UAT_EXAMPLE.md" purpose="Worked UAT example">
      <covers>
        <entity type="phase" depth="example" refs="p5" />
      </covers>
    </document>
    <document id="doc-schema" path="protocol/schema.xml" purpose="This file: canonical machine-readable protocol definition (BCNF)">
      <covers>
        <entity type="all" depth="full" note="Single source of truth for all entity definitions and relationships" />
      </covers>
    </document>
    <document id="doc-root-readme" path="README.md" purpose="Project README with workflow overview, commands, structure">
      <covers>
        <entity type="phase" depth="overview" refs="all" />
        <entity type="command" depth="table" refs="all" />
        <entity type="role" depth="table" refs="all" />
      </covers>
    </document>
    <document id="doc-root-agents" path="AGENTS.md" purpose="Agent orchestration guide for this repository">
      <covers>
        <entity type="role" depth="orchestration" refs="all" />
        <entity type="constraint" depth="full" refs="C-dep-direction,C-agent-commit" />
      </covers>
    </document>
  </documents>
  <!-- ═══════════════════════════════════════════════════════════════════════
     DEPENDENCY DIRECTION (Beads)

     Canonical definition of how work flows through the dependency tree.
     ═══════════════════════════════════════════════════════════════════════ -->
  <dependency-model>
    <rule>
    Parent (stays open) is blocked-by child (must finish first).
    Work flows bottom-up; closure flows top-down.
  </rule>
    <canonical-chain>
    REQUEST → blocked-by ELICIT → blocked-by PROPOSAL
      → blocked-by IMPL_PLAN → blocked-by SLICE-N → blocked-by leaf tasks
  </canonical-chain>
    <command>bd dep add {parent-id} --blocked-by {child-id}</command>
    <anti-pattern>bd dep add {child-id} --blocked-by {parent-id}</anti-pattern>
    <reference-links note="URD and other reference docs use frontmatter, not blocking deps">
      <pattern>
      description frontmatter:
        references:
          urd: {urd-task-id}
          request: {request-task-id}
    </pattern>
    </reference-links>
  </dependency-model>
  <!-- ═══════════════════════════════════════════════════════════════════════
     FOLLOW-UP LIFECYCLE (R6 from URD)

     When code review produces IMPORTANT or MINOR findings, the supervisor
     creates a follow-up epic that runs the same protocol phases with
     FOLLOWUP_* prefixed task types. The IMPORTANT/MINOR leaf tasks from
     the original review gain a second parent: the follow-up slice they
     are assigned to (dual-parent).

     Kind: Separate enum values (FOLLOWUP_URE, FOLLOWUP_SLICE, etc.).
     Simple single-parent epic relationship — no followup-of-followup.
     ═══════════════════════════════════════════════════════════════════════ -->
  <followup-lifecycle>
    <trigger>Code review completion AND (IMPORTANT OR MINOR findings exist)</trigger>
    <owner-role>supervisor</owner-role>
    <gated-on-blocker>false</gated-on-blocker>
    <dependency-chain note="Same protocol phases but with FOLLOWUP_ prefix">
      <!--
      FOLLOWUP epic (aura:epic-followup)
        ├── relates_to: original URD
        ├── relates_to: original REVIEW-A/B/C tasks
        └── blocked-by: FOLLOWUP_URE
              └── blocked-by: FOLLOWUP_URD
                    └── blocked-by: FOLLOWUP_PROPOSAL-1
                          └── blocked-by: FOLLOWUP_IMPL_PLAN
                                ├── blocked-by: FOLLOWUP_SLICE-1
                                │     ├── blocked-by: important-leaf-task-...
                                │     └── blocked-by: minor-leaf-task-...
                                └── blocked-by: FOLLOWUP_SLICE-2
                                      └── blocked-by: ...
    -->
      <step task-title="FOLLOWUP: {description}" phase-ref="p10" description="Epic created by supervisor. References original URD and review tasks." />
      <step task-title="FOLLOWUP_URE: {description}" phase-ref="p2" description="Scoping URE with user to determine which findings to address." />
      <step task-title="FOLLOWUP_URD: {description}" phase-ref="p2" description="Requirements doc for follow-up scope. References original URD." />
      <step task-title="FOLLOWUP_PROPOSAL-{N}: {description}" phase-ref="p3" description="Proposal accounting for original URD + FOLLOWUP_URD + outstanding findings." />
      <step task-title="FOLLOWUP_IMPL_PLAN: {description}" phase-ref="p8" description="Supervisor decomposes follow-up into slices." />
      <step task-title="FOLLOWUP_SLICE-{N}: {description}" phase-ref="p9" description="Each slice adopts original IMPORTANT/MINOR leaf tasks as children." />
    </dependency-chain>
    <leaf-task-adoption>
      <rule>
      When supervisor creates FOLLOWUP_SLICE-N, the IMPORTANT/MINOR leaf tasks
      from the original review gain a second parent: the follow-up slice.
      This is the same dual-parent pattern as BLOCKER findings.
    </rule>
      <command>
      bd dep add {followup-slice-id} --blocked-by {important-leaf-task-id}
      bd dep add {followup-slice-id} --blocked-by {minor-leaf-task-id}
    </command>
      <note>
      Leaf tasks retain their original parent (the severity group from the original review)
      AND gain the follow-up slice as a second parent. Both must close for the leaf to be
      fully resolved.
    </note>
    </leaf-task-adoption>
    <references>
      <ref type="relates_to" target="original URD" note="Follow-up epic references original URD via frontmatter" />
      <ref type="relates_to" target="original REVIEW tasks" note="Follow-up epic references review tasks via frontmatter" />
    </references>
    <handoff-chain note="How handoffs flow through the follow-up lifecycle">
      <!--
      The follow-up lifecycle uses 6 handoff transitions (h1-h6), where h6 is unique to the follow-up lifecycle
      but scoped to the follow-up epic. The storage path changes to use the
      follow-up epic ID instead of the original request ID.

      Storage: .git/.aura/handoff/{followup-epic-id}/{source}-to-{target}.md
    -->
      <transition order="1" handoff-ref="h5" description="Reviewer → Followup: Bridge from original review to follow-up epic. Created by supervisor when IMPORTANT/MINOR findings exist. This handoff STARTS the follow-up lifecycle." />
      <transition order="2" handoff-ref="none" description="Supervisor creates FOLLOWUP_URE (same actor — supervisor owns follow-up epic and initiates scoping)" same-actor="true" />
      <transition order="3" handoff-ref="none" description="Supervisor creates FOLLOWUP_URD (same actor within Phase 2 — supervisor synthesizes follow-up requirements)" same-actor="true" />
      <transition order="4" handoff-ref="h6" description="Supervisor → Architect: Hands off completed FOLLOWUP_URE + FOLLOWUP_URD to architect for FOLLOWUP_PROPOSAL creation. Architect receives scoped findings and requirements." />
      <transition order="5" handoff-ref="h1" description="Architect → Supervisor: After FOLLOWUP_PROPOSAL is ratified, architect hands off to supervisor for FOLLOWUP_IMPL_PLAN. Handoff doc references original URD, FOLLOWUP_URD, and outstanding findings." />
      <transition order="6" handoff-ref="h2" description="Supervisor → Worker: FOLLOWUP_SLICE-N assignment. Worker receives both the follow-up slice spec AND the original leaf task IDs they must resolve." />
      <transition order="7" handoff-ref="h3" description="Supervisor → Reviewer: Code review of follow-up slices. Reviewer receives follow-up context + original findings being addressed." />
      <transition order="8" handoff-ref="h4" description="Worker → Reviewer: Worker completes follow-up slice. Handoff includes which original leaf tasks were resolved." />
    </handoff-chain>
  </followup-lifecycle>
  <!-- ═══════════════════════════════════════════════════════════════════════
     PROCEDURE STEPS

     Per-role ordered steps (startup sequence for supervisor,
     TDD layers for worker). Only roles with non-empty steps are listed.
     ═══════════════════════════════════════════════════════════════════════ -->
  <procedure-steps>
    <role ref="supervisor">
      <step order="1" instruction="Call Skill(/aura:supervisor) to load role instructions" command="Skill(/aura:supervisor)" />
      <step order="2" instruction="Read RATIFIED_PLAN and URD via bd show" command="bd show &lt;ratified-plan-id&gt; &amp;&amp; bd show &lt;urd-id&gt;" />
      <step order="3" instruction="Create standing explore team via TeamCreate before any codebase exploration" context="TeamCreate with /aura:explore role; minimum 3 agents" />
      <step order="4" instruction="Decompose into vertical slices" next-state="p8" />
      <step order="5" instruction="Create leaf tasks (L1/L2/L3) for every slice" command="bd create --labels L1,L2,L3 &lt;task-id&gt;" />
      <step order="6" instruction="Spawn workers for leaf tasks" command="aura-swarm start --epic &lt;epic-id&gt;" next-state="p9" />
    </role>
    <role ref="worker">
      <step order="1" instruction="Types, interfaces, schemas (no deps)" />
      <step order="2" instruction="Tests importing production code (will fail initially)" />
      <step order="3" instruction="Make tests pass. Wire with real dependencies. No TODOs." next-state="p9" />
    </role>
  </procedure-steps>
</aura-protocol>
