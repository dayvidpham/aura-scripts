{"id":"aura-scripts-35o","title":"REVIEW_2: Plan review for aura-scripts Nix flake","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-18T05:56:14.630953166-08:00","created_by":"David Huu Pham","updated_at":"2026-02-18T06:09:11.326708867-08:00","closed_at":"2026-02-18T06:09:11.326708867-08:00","close_reason":"Closed","labels":["aura:plan:review"],"dependencies":[{"issue_id":"aura-scripts-35o","depends_on_id":"aura-scripts-5fk","type":"blocks","created_at":"2026-02-18T05:56:19.909059205-08:00","created_by":"David Huu Pham"}],"comments":[{"id":5,"issue_id":"aura-scripts-35o","author":"David Huu Pham","text":"VOTE: REVISE — Proposal direction is correct but out of sync with existing implementation. Key gaps: phases 1-3 already implemented but presented as future work, agents section undocumented, runtime dep wrapping missing for packages, validation checklist incomplete. See REVIEW_2 comment on aura-scripts-5fk for full details.","created_at":"2026-02-18T14:07:36Z"}]}
{"id":"aura-scripts-5fk","title":"PROPOSE_PLAN: aura-scripts Nix flake with HM modules for unified agent config","description":"Phase 3 proposal — see beads comments for full plan","status":"open","priority":2,"issue_type":"feature","owner":"dayvidpham@gmail.com","created_at":"2026-02-18T05:50:38.560687051-08:00","created_by":"David Huu Pham","updated_at":"2026-02-18T05:50:38.560687051-08:00","labels":["aura:plan:proposal"],"dependencies":[{"issue_id":"aura-scripts-5fk","depends_on_id":"aura-scripts-ztn","type":"blocks","created_at":"2026-02-18T05:50:42.807367606-08:00","created_by":"David Huu Pham"},{"issue_id":"aura-scripts-5fk","depends_on_id":"aura-scripts-82l","type":"relates-to","created_at":"2026-02-18T06:15:34.683514665-08:00","created_by":"David Huu Pham"}],"comments":[{"id":2,"issue_id":"aura-scripts-5fk","author":"David Huu Pham","text":"PROPOSE_PLAN: aura-scripts Nix Flake with Home-Manager Modules\n\n## Problem Space\n\nCurrently, agent configuration is scattered across 4+ locations:\n- ~/.claude/ (settings.json, 33 command files, hooks, agents)\n- ~/codebases/dayvidpham/aura-scripts/protocol/ (CLAUDE.md, CONSTRAINTS.md, PROCESS.md)\n- ~/codebases/dayvidpham/opencode-security/ (security filter for OpenCode)\n- ~/codebases/agentconfig/ (reference only — TypeScript config tool)\n\nChanges to one tool's config must be manually replicated. The dotfiles flake already manages Claude Code and OpenCode as packages (modules/home-manager/programs/claude-code/ and opencode/), but only enables the binaries — no config management.\n\n## Proposed Solution\n\nTurn aura-scripts into a Nix flake that exports:\n1. homeManagerModules — declarative options for agent config generation\n2. packages — launch-parallel.py, aura-swarm as proper Nix derivations\n\nThe dotfiles flake imports aura-scripts as a flake input and uses its HM modules.\n\n## Architecture\n\n### Flake Outputs (from aura-scripts/flake.nix)\n\n```\n{\n  packages.x86_64-linux = {\n    launch-parallel    # Wrapped Python script\n    aura-swarm         # Go binary\n  };\n\n  homeManagerModules = {\n    aura-protocol      # Protocol docs (CLAUDE.md, CONSTRAINTS.md, PROCESS.md)\n    aura-commands      # Slash command .md files\n    aura-agent-config  # Settings/permissions generation for Claude Code + OpenCode\n  };\n}\n```\n\n### HM Module: aura-protocol\n\n```nix\noptions.aura.protocol = {\n  enable = mkEnableOption \"Aura protocol docs\";\n  target = mkOption {\n    type = types.enum [ \"claude\" \"opencode\" \"both\" ];\n    default = \"both\";\n    description = \"Which tools get protocol docs installed\";\n  };\n  constraints = mkOption {\n    type = types.path;\n    default = ./protocol/CONSTRAINTS.md;\n    description = \"Path to constraints file (override for project-specific)\";\n  };\n};\n```\n\nEffect: Generates ~/.claude/CLAUDE.md (and OpenCode equivalent) from protocol/ sources.\n\n### HM Module: aura-commands\n\n```nix\noptions.aura.commands = {\n  enable = mkEnableOption \"Aura slash commands\";\n  roles = mkOption {\n    type = types.listOf (types.enum [ \"architect\" \"supervisor\" \"worker\" \"reviewer\" \"epoch\" \"all\" ]);\n    default = [ \"all\" ];\n    description = \"Which role commands to install\";\n  };\n  extraCommands = mkOption {\n    type = types.attrsOf types.path;\n    default = {};\n    description = \"Additional command files to install\";\n  };\n};\n```\n\nEffect: Symlinks or copies command .md files into ~/.claude/commands/.\n\n### HM Module: aura-agent-config\n\n```nix\noptions.aura.agentConfig = {\n  enable = mkEnableOption \"Unified agent settings generation\";\n\n  claude = {\n    enable = mkOption { type = types.bool; default = true; };\n    permissions = {\n      allow = mkOption { type = types.listOf types.str; default = []; };\n      deny = mkOption { type = types.listOf types.str; default = []; };\n    };\n    hooks = mkOption { type = types.attrsOf (types.listOf types.attrs); default = {}; };\n    # ... more Claude-specific options\n  };\n\n  opencode = {\n    enable = mkOption { type = types.bool; default = false; };\n    security = {\n      trustedPaths = mkOption { type = types.listOf types.str; default = []; };\n      blockedPatterns = mkOption { type = types.listOf types.str; default = []; };\n    };\n    # ... OpenCode-specific options\n  };\n\n  # Shared options that translate to both\n  shared = {\n    model = mkOption { type = types.str; default = \"opus\"; };\n    sandbox = mkOption { type = types.bool; default = true; };\n  };\n};\n```\n\nEffect: Generates ~/.claude/settings.json AND OpenCode config from one option set.\nInspired by agentconfig's adapter/migration pattern but as pure Nix functions.\n\n## Integration with Dotfiles\n\nIn ~/dotfiles/flake.nix:\n```nix\ninputs.aura-scripts = {\n  url = \"github:dayvidpham/aura-scripts\";\n  inputs.nixpkgs.follows = \"nixpkgs\";\n};\n```\n\nIn homeConfigurations:\n```nix\nmodules = [\n  aura-scripts.homeManagerModules.aura-protocol\n  aura-scripts.homeManagerModules.aura-commands\n  aura-scripts.homeManagerModules.aura-agent-config\n  # ...\n];\n```\n\nIn user's home.nix:\n```nix\n{\n  aura.protocol.enable = true;\n  aura.commands.enable = true;\n  aura.commands.roles = [ \"all\" ];\n  aura.agentConfig = {\n    enable = true;\n    claude.enable = true;\n    opencode.enable = true;\n    shared.model = \"opus\";\n  };\n}\n```\n\n## Packages\n\n### launch-parallel\nWrap the Python script as a Nix derivation with proper dependency closure (python3, tmux).\n\n### aura-swarm\nPackage the Go binary. If source is available, build from source. If only binary, wrap it.\n\n## Tradeoffs\n\n| Decision | Chosen | Alternative | Rationale |\n|----------|--------|-------------|-----------|\n| Config generation | Pure Nix functions | Runtime Go/TS daemon | Simpler, reproducible, no state. Go sync is future work. |\n| Module granularity | 3 separate modules | 1 monolithic module | Composable — enable only what you need |\n| Command installation | File copy via HM | Symlinks into repo | HM manages the files; no dangling symlinks if repo moves |\n| Protocol doc location | Stay in aura-scripts | Move to dotfiles | Protocol is reusable across users/projects; dotfiles is personal |\n\n## Priority / Phases\n\n1. **Flake skeleton + packages** — Make flake.nix export launch-parallel and aura-swarm as packages\n2. **aura-protocol HM module** — Install CLAUDE.md/CONSTRAINTS.md/PROCESS.md\n3. **aura-commands HM module** — Install slash commands to ~/.claude/commands/\n4. **aura-agent-config HM module** — Generate settings.json from Nix options (Claude first, then OpenCode)\n5. **Integration test** — Wire into dotfiles, verify `home-manager switch` produces correct output\n\n## Validation Checklist\n\n- [ ] `nix flake check` passes on aura-scripts\n- [ ] `home-manager switch` produces correct ~/.claude/settings.json\n- [ ] Slash commands appear in ~/.claude/commands/\n- [ ] Protocol docs appear as CLAUDE.md in correct locations\n- [ ] launch-parallel and aura-swarm are in $PATH after switch\n- [ ] OpenCode config generated when opencode.enable = true\n- [ ] Existing dotfiles flake can import aura-scripts without conflicts","created_at":"2026-02-18T13:52:00Z"},{"id":3,"issue_id":"aura-scripts-5fk","author":"David Huu Pham","text":"REVISION-1: Revised based on user feedback\n\nKEY CHANGES:\n1. Single module: homeManagerModules.aura-config-sync (not 3 separate modules)\n2. Role selection via individual enables with enableAll default:\n\n```nix\noptions.CUSTOM.programs.aura-config-sync = {\n  enable = mkEnableOption \"Aura protocol config sync\";\n\n  commands = {\n    enable = mkOption { type = bool; default = true; };\n    roles = {\n      enableAll = mkOption { type = bool; default = true; };\n      architect.enable = mkOption { type = bool; default = cfg.commands.roles.enableAll; };\n      supervisor.enable = mkOption { type = bool; default = cfg.commands.roles.enableAll; };\n      worker.enable = mkOption { type = bool; default = cfg.commands.roles.enableAll; };\n      reviewer.enable = mkOption { type = bool; default = cfg.commands.roles.enableAll; };\n      epoch.enable = mkOption { type = bool; default = cfg.commands.roles.enableAll; };\n    };\n    extraCommands = mkOption { type = attrsOf path; default = {}; };\n  };\n\n  protocol = {\n    enable = mkOption { type = bool; default = true; };\n    target = mkOption { type = enum [ \"claude\" \"opencode\" \"both\" ]; default = \"both\"; };\n  };\n\n  agentConfig = {\n    enable = mkOption { type = bool; default = true; };\n    claude = { ... };\n    opencode = { ... };\n    shared = { ... };\n  };\n\n  security = {\n    enable = mkOption { type = bool; default = false; };\n  };\n\n  hooks = { ... };\n};\n```\n\n3. agentconfig (~/codebases/agentconfig) is reference/inspiration only — not a dependency\n4. Protocol docs stay in aura-scripts as canonical source","created_at":"2026-02-18T13:56:04Z"},{"id":4,"issue_id":"aura-scripts-5fk","author":"David Huu Pham","text":"REVIEW_2: REVISE\n\n## Summary\nThe proposal is solid in direction and the REVISION-1 correctly addressed user feedback (single module, CUSTOM.programs namespace, enableAll pattern). However, the proposal is out of sync with the actual implementation in several ways, and there are implementation gaps and missed tradeoffs that should be documented before ratification.\n\n## 1. Who are the end-users and what do they want?\nWell-captured. The user wants a single source of truth for agent configs managed via Nix/Home Manager, with composable role selection. The URE verbatim captures are thorough. No issues here.\n\n## 2. How does this impact end-users?\nPositive: atomic config application via home-manager switch, declarative role management.\n\nRisk: Protocol docs writing to ~/.claude/CLAUDE.md could conflict with the user's personal CLAUDE.md. The implementation wisely defaults protocol.enable=false, but the proposal doesn't discuss the conflict scenario or a merge strategy.\n\n## 3. Are there implementation gaps?\n\n**Proposal vs. actual code discrepancies — the plan should be updated to reflect reality:**\n\na) The implementation (nix/hm-module.nix) ALREADY covers Phases 1-3 of the proposal (flake skeleton, packages, protocol, commands). The plan should acknowledge this existing work rather than presenting it as future work.\n\nb) The implementation has an `agents` section (agents/ directory → ~/.claude/agents/) that the proposal never mentions. This should be documented.\n\nc) The implementation has a `packages` section that the proposal only mentions as a flake output, not as a toggleable HM option.\n\nd) protocol.target uses `enum [ \"global\" \"xdg\" ]` in the implementation vs `enum [ \"claude\" \"opencode\" \"both\" ]` in the proposal. The implementation is more accurate — it's about filesystem location, not tool targeting. The plan should be updated.\n\n**Genuinely missing from implementation (future phases):**\n\ne) agentConfig section (settings.json generation, permissions, shared options) — entirely absent from HM module. This is the most complex part and should be its own clearly-scoped phase.\n\nf) security section — mentioned in REVISION-1 options block but no implementation or specification.\n\ng) hooks section — mentioned in REVISION-1 but no implementation or specification.\n\nh) OpenCode config generation — no implementation at all.\n\n## 4. Is the MVP scope right?\n\nThe phased approach is reasonable, but the phases are misaligned with reality:\n- Phases 1-3 are ALREADY DONE. The MVP should acknowledge this.\n- The actual remaining MVP work is: verify integration with dotfiles flake (Phase 5), then optionally agentConfig (Phase 4).\n- Recommend reframing phases as: Phase 1 = Integration test (wire into dotfiles, verify switch), Phase 2 = agentConfig/settings.json for Claude, Phase 3 = OpenCode support, Phase 4 = security + hooks.\n\n## 5. Is the validation checklist complete?\n\nMissing items:\n- `nix flake show` produces expected outputs\n- Verify launch-parallel runtime deps work (tmux in PATH — see tradeoffs)\n- Test enableAll=false with individual role enables\n- Test extraCommands/extraAgents\n- Test protocol with xdg target\n- Test no home.file attr collisions across sections\n\n## 6. What tradeoffs were missed?\n\na) **Runtime dependency closure for packages**: launch-parallel.py needs tmux at runtime. Current writeScriptBin only patches the shebang — tmux is NOT in PATH. Should use wrapProgram/makeWrapper. aura-swarm likely needs git, claude, etc.\n\nb) **home.file conflict with personal CLAUDE.md**: No merge/override strategy documented for protocol docs.\n\nc) **No lib export from flake**: Dotfiles flake cannot reuse helpers like listMdFiles or roleNames. Minor, but a composability gap.\n\nd) **OpenCode phasing is vague**: User's #1 priority is the Nix module, then config translation, but the proposal buries OpenCode in a Phase 4 parenthetical. Needs its own phase.\n\ne) **No schema evolution story**: User asked about versioned schemas (Q4). As Claude Code/OpenCode config formats evolve, the module options will need to track changes. Should be noted as a known future concern.\n\n## Verdict\nREVISE — update the proposal to:\n1. Acknowledge existing implementation (Phases 1-3 are done)\n2. Reframe remaining phases to match actual work needed\n3. Add agents section to the spec\n4. Fix protocol.target to match implementation (global|xdg)\n5. Address runtime dependency wrapping for packages\n6. Add missing validation checklist items","created_at":"2026-02-18T14:07:33Z"},{"id":6,"issue_id":"aura-scripts-5fk","author":"David Huu Pham","text":"REVIEW_1: ACCEPT — with implementation notes\n\n## Review Summary\n\nThe REVISION-1 proposal is well-structured and the implementation (flake.nix + nix/hm-module.nix) is already ahead of the plan, covering Phases 1-3 plus an agents subsection not in the original proposal. The single-module design under CUSTOM.programs.aura-config-sync correctly matches user requirements and the existing dotfiles namespace convention.\n\n## Review Against 6 Questions\n\n### 1. End-users and what they want\nClearly identified: David wants a single source of truth for agent config (Claude Code + OpenCode) managed declaratively via Nix/home-manager. The URE captures comprehensive Q\u0026A. PASS.\n\n### 2. End-user impact\nPositive: single `home-manager switch` deploys all agent config. Composable role selection with enableAll default + individual overrides. Packages properly Nix-wrapped. PASS.\n\n### 3. Implementation gaps (4 items)\n\n**G1: Package runtime deps not wrapped (medium risk).** flake.nix uses `writeScriptBin` with `builtins.replaceStrings` for shebang swapping. This does NOT add runtime dependencies (tmux, git, claude CLI) to PATH. launch-parallel.py calls `subprocess` to launch tmux sessions — tmux won't be found unless separately in PATH. Fix: use `writeShellApplication` or `makeWrapper` to wrap runtime deps.\n\n**G2: `lib ? config.lib` is non-standard.** hm-module.nix line 6: `lib ? config.lib`. HM modules receive `lib` from the module system directly. The fallback to `config.lib` is unusual and could cause subtle issues. Should just use `lib` from the module args.\n\n**G3: agentConfig section (settings.json generation) proposed but unimplemented.** This is the most complex part and is Phase 4. Acceptable as future work, but the REVISION-1 text presents it alongside implemented features without clearly marking it as \"not yet implemented.\" Should add explicit phase annotations.\n\n**G4: The `agents` subsection is implemented but NOT mentioned in the proposal or validation checklist.** This is a good addition but should be documented in the plan.\n\n### 4. MVP scope\nCorrect for phases 1-3 + agents. The phased approach is sound: packages → protocol → commands → agentConfig → integration test. The validation checklist mixes MVP items with Phase 4 items (e.g., \"home-manager switch produces correct ~/.claude/settings.json\" and \"OpenCode config generated when opencode.enable = true\" are Phase 4, not MVP). Should distinguish.\n\n### 5. Validation checklist completeness\nMissing items:\n- No validation that writeScriptBin packages work with runtime deps\n- No test for role filtering (enableAll=false + individual enables)\n- No test for extraCommands/extraAgents extension points\n- No mention of agents subsection in checklist\n- No check for home.file conflicts with existing dotfiles entries\n- `nix flake check` is listed but flake defines no `checks` output — would only verify evaluation\n\n### 6. Missed tradeoffs\n\n**T1: home.file immutability.** `source = storePath` creates /nix/store symlinks (read-only). Fine for commands and protocol docs, but will be a BLOCKER for Phase 4 settings.json if Claude Code needs to write back to it. Phase 4 design must address this — likely needs `home.file.*.text` with `mkForce` or a different approach entirely.\n\n**T2: No nixosModules output.** User mentioned in Q6 \"Flake should provide nixosModules and/or hmModules.\" Only homeManagerModules is provided. Fine for current use case but noted.\n\n**T3: Flake input naming.** Proposal shows `inputs.nixpkgs.follows = \"nixpkgs\"` for dotfiles integration, but aura-scripts flake uses `nixpkgs-stable`/`nixpkgs-unstable` with `nixpkgs = nixpkgs-stable` (via rec). The `follows` directive needs to match: `inputs.aura-scripts.inputs.nixpkgs-stable.follows = \"nixpkgs\"`.\n\n## Verdict\nACCEPT — the core architecture is sound, implementation is ahead of plan, and all gaps are addressable without architectural changes. G1 (runtime deps) is the most actionable fix for immediate correctness.","created_at":"2026-02-18T14:07:38Z"},{"id":8,"issue_id":"aura-scripts-5fk","author":"David Huu Pham","text":"REVIEW_3: ACCEPT — with minor notes\n\n## Review Against 6 Questions\n\n### 1. End-users \u0026 wants\nWell identified. David is the sole end-user, managing agent configs across Claude Code and OpenCode. The URE captures verbatim Q\u0026A thoroughly. The pain point (scattered config across 4+ locations) is real and clearly articulated.\n\n### 2. End-user impact\nPositive: `home-manager switch` deploys all agent configs atomically. No more manual file copying. The implementation correctly uses the existing `CUSTOM.programs.*` namespace from the dotfiles flake — confirmed by reading the dotfiles structure (claude-code and opencode modules currently only enable packages, zero config management).\n\nRisk noted: HM-managed files are declarative — manual edits to ~/.claude/commands/ get overwritten on next switch. The proposal doesn't discuss this, but this is standard HM behavior and the user is experienced with it.\n\n### 3. Implementation gaps\nThe implementation (hm-module.nix) is AHEAD of the proposal in some areas:\n- **Agents section**: Implemented (agents/ → ~/.claude/agents/) but not mentioned in the proposal at all. Should be documented.\n- **Protocol target divergence**: Proposal says `target = enum [\"claude\" \"opencode\" \"both\"]`, implementation has `target = enum [\"global\" \"xdg\"]`. The implementation choice is actually better (avoids premature OpenCode coupling) but should be reflected in the proposal.\n- **agentConfig not implemented**: Proposal's Phase 4 (settings.json generation, hooks, security) is not in the current code. This is fine for a phased approach but the validation checklist incorrectly includes Phase 4 items as if they're MVP.\n- **Minor: `lib ? config.lib` fallback**: The module uses `lib ? config.lib` — these are different things (nixpkgs lib vs HM config.lib). Harmless since `lib` is always provided by the module system, but the fallback is semantically wrong.\n- **`nix flake check` warns**: `homeManagerModules` is flagged as \"unknown flake output\" — this is a common convention but not in the official flake schema. Harmless warning, widely accepted pattern.\n\n### 4. MVP scope\nThe current implementation (commands + agents + protocol + packages) is the RIGHT MVP. It solves the primary pain point without over-reaching into settings.json generation. The phasing (packages → protocol → commands → agentConfig → integration test) is sound.\n\nHowever, the proposal's phases should explicitly mention agents (currently implemented but unlisted).\n\n### 5. Validation checklist completeness\nThe checklist mixes MVP and future items:\n- MVP items (should pass now): `nix flake check`, commands in ~/.claude/commands/, protocol docs, packages in $PATH\n- Future items (Phase 4): settings.json generation, OpenCode config — these should be labeled as Phase 4 validation\n\nMissing checklist items:\n- [ ] `enableAll = false` correctly excludes role commands\n- [ ] `extraCommands` and `extraAgents` merge works\n- [ ] Agent .md files appear in ~/.claude/agents/\n- [ ] Disabling the module removes managed files (HM rollback)\n\n### 6. Missed tradeoffs\n- **Epoch as a \"role\"**: `roleNames` includes \"epoch\" but epoch is more of a workflow orchestrator than an agent role. With `enableAll = false`, you'd need to explicitly enable `epoch` even though it's not really a selectable \"role\" like architect/worker. Consider whether epoch, or even user/msg/impl commands, should always be installed as core commands.\n- **No integration test output**: The flake defines no `checks` output — `nix flake check` only validates derivations build, not that the HM module produces correct file layouts. A VM test or `runCommand`-based check would strengthen validation.\n- **Single aarch64 system untested**: `supportedSystems` includes `aarch64-linux` but `--all-systems` is needed to verify. Minor since packages are just wrapped scripts.\n\n## Verdict\nThe architecture is sound. The single-module design under `CUSTOM.programs.aura-config-sync` matches the dotfiles convention. The implementation is already functional and ahead of the proposal. Phased approach is appropriate. Accept with the understanding that the proposal should be updated to reflect the agents section and the protocol.target divergence.","created_at":"2026-02-18T14:08:44Z"},{"id":12,"issue_id":"aura-scripts-5fk","author":"David Huu Pham","text":"REVIEW_2 (REVISION-2): ACCEPT — All original REVISE concerns addressed in aura-scripts-82l. One non-blocking note: aura-swarm also needs bd (beads CLI) as runtime dep. See full review on aura-scripts-82l.","created_at":"2026-02-18T14:16:39Z"}]}
{"id":"aura-scripts-7o2","title":"EPIC: Unified agent config — aura-scripts as Nix flake with HM modules","description":"Turn aura-scripts into a consumable Nix flake that exports homeManagerModules and packages for declarative management of Claude Code and OpenCode configuration.\n\nEnd-user: The developer (minttea) who maintains agent configs across Claude Code and OpenCode.\nEnd-goal: One Nix option set generates all agent config files. No manual syncing.","status":"closed","priority":1,"issue_type":"feature","owner":"dayvidpham@gmail.com","created_at":"2026-02-18T06:02:31.115295592-08:00","created_by":"David Huu Pham","updated_at":"2026-02-18T06:04:55.578982453-08:00","closed_at":"2026-02-18T06:04:55.578982453-08:00","close_reason":"Unnecessary separate epic — REQUEST task (ght) is the epic","labels":["epic"]}
{"id":"aura-scripts-82j","title":"REQUEST: Redesign Aura protocol architecture — standardized Beads schema, label taxonomy, follow-up epic workflow, and improved handoff","description":"Should devise a new architectural approach to the commands, process, and constraints that make it harder for work to get lost or forgotten about, for certain recurring issues to be addressed via improved validation pipelines, and for better process management and handoff. Improved human handoff would look something like the @protocol/HANDOFF_EXAMPLE-*.md files. Want to also define an explicit Beads schema and taxonomy with with labels that apply to each phase, task, review, UAT, URE, URD, IMPL_PLAN. Labels are being applied non-uniformly, often forgotten about and in a non-standardized manner.\n\nShould look something like this:\n\nThe PROPOSAL-1 and PROPOSAL-2 should be a child of the URE.\n\nWhat we want:\n```\nREQUEST\n  └── blocked by URE\n        └── blocked by PROPOSAL-1 (closed, superseded)\n              └── blocked by PROPOSAL-1-REVIEW-1 (closed)\n              └── blocked by PROPOSAL-1-REVIEW-2 (closed)\n              └── blocked by PROPOSAL-1-REVIEW-3 (closed)\n        └── blocked by PROPOSAL-{2,3,...,N-1} (closed, superseded)\n              └── blocked by PROPOSAL-{K, for proposal number K}-REVIEW-1 (closed)\n              └── blocked by PROPOSAL-{K, for proposal number K}-REVIEW-2 (closed)\n              └── blocked by PROPOSAL-{K, for proposal number K}-REVIEW-3 (closed)\n        └── blocked by PROPOSAL-N (open, aura:plan:ratify)\n              └── blocked by PROPOSAL-N-REVIEW-1 (closed)\n              └── blocked by PROPOSAL-N-REVIEW-2 (closed)\n              └── blocked by PROPOSAL-N-REVIEW-3 (closed)\n              └── blocked by IMPL_PLAN\n                    ├── blocked by slice-1\n                    │     ├── blocked by leaf-task-a\n                    │     └── blocked by leaf-task-b\n                    └── blocked by slice-2\n                          ├── blocked by leaf-task-c\n                          └── blocked by leaf-task-d\n```\n\nHere is an actual example:\n```\nunified-schema-t9d: REQUEST: Aura ingest CLI command - data ingestion pipeline for Claude and OpenCode transcripts [P1] (open) [READY]\n    └── unified-schema-m3l: URE: Aura ingest pipeline requirements elicitation [P1] (open)\n    │   ├── unified-schema-apj: PROPOSAL-1: RFC v0.1.0 Aura ingest pipeline [P1] (closed)\n        └── unified-schema-hjy: PROPOSAL-2: RFC v0.2.0 Aura ingest pipeline (revised) [P1] (open)\n        │   ├── unified-schema-fuf: IMPL_PLAN: Aura ingest pipeline — 10 vertical slices (S1-S10) [P1] (open)\n        │   │   ├── unified-schema-bq9: IMPL-UAT-1: Group A implementation acceptance (S2, S4, S5) [P2] (closed)\n        │   │   ├── unified-schema-er6: Review Round 2: blocking fix verification [P2] (closed)\n        │   │   ├── unified-schema-i80: Code Review: Adapter Slices S6-S8 [P2] (closed)\n        │   │   ├── unified-schema-n6c: Code Review: Pipeline + CLI (S9-S10) [P2] (closed)\n        │       └── unified-schema-o20: Code Review: Foundation Slices S1-S5 [P2] (closed)\n            └── unified-schema-zj9: UAT-1: Plan acceptance for aura ingest pipeline RFC v0.2.0 [P2] (closed)\n```\n\nReviews rounds on the completed vertical slices in the IMPL_PLAN tend to create tasks that get lost. Unsure how to best account for them at the moment. Currently have this other FOLLOW_UP epic issue tracker that takes the Review Rounds / Code Reviews (these names need to be standardized) on the IMPL_PLAN, then takes the tasks generated from them, and then proposes architecture and designs that will resolve the issues the reviewers had.\n\nIdeally, there would be a follow-up epoch where: architect should propose new architecture, should also plan architectural changes or make a design that understands and prevents these issues, how they arise, and prevent them from arising in the future. Could be architecture, design, or just new, better validation rules via `go fmt` or `go vet` or ast-grep rules. launch the supervisor using the `@~/codebases/dayvidpham/aura-scripts/aura-swarm` command once the architecture is proposed to resolve all these issues, and the tasks are topologically sorted and placed into vertical slices.\n\nThis would be generic though, not specific to a golang codebase---just using these command as an example. This would produce a followup-epic with structure like so:\n\n```\nunified-schema-ldl: EPIC: Ingest Pipeline Follow-Up Work (post-implementation) [P2] (closed)\n    ├── unified-schema-f6f: F1: HostSlug \u0026 Project Identity Refactoring [P2] (closed)\n    │   ├── unified-schema-af6: R3: Adapters populate HostSlug, pipeline reads it [P2] (closed)\n    │   ├── unified-schema-da3: R2: Extract shared DeriveProjectIdentifiers into hostslug.go [P2] (closed)\n    │   ├── unified-schema-xvo: R1: Add HostSlug field to UnifiedMetadata [P2] (closed)\n        └── unified-schema-kip: M5: DeriveHostSlug doesn't handle git:// or file:// remotes [P3] (closed)\n    ├── unified-schema-02c: F7: Documentation [P3] (closed)\n    │   ├── unified-schema-z6u: ARCH: Preventive Architecture for Ingest Pipeline Follow-Up [P2] (open)\n    │   ├── ... (many more follow-up tasks organized by feature area)\n    └── unified-schema-qeb: F4: Pipeline Error Handling \u0026 Test Coverage [P3] (closed)\n        ├── ... (leaf tasks)\n```\n\nKey problems to solve:\n1. Work gets lost or forgotten — need harder guardrails\n2. Labels applied non-uniformly — need explicit schema/taxonomy\n3. Review round tasks get lost under IMPL_PLAN — need standardized naming and structure\n4. No formal follow-up epic workflow — need architecture for post-impl review → follow-up epoch\n5. Handoff quality inconsistent — need standardized handoff documents like HANDOFF_EXAMPLE-*.md\n6. Validation pipelines missing — need language-agnostic validation rule system (like go vet, ast-grep)\n7. Process management gaps — recurring issues not systematically prevented","status":"open","priority":2,"issue_type":"task","assignee":"architect","owner":"dayvidpham@gmail.com","created_at":"2026-02-19T15:33:41.892437571-08:00","created_by":"David Huu Pham","updated_at":"2026-02-19T15:33:41.892437571-08:00","labels":["aura:user:request"]}
{"id":"aura-scripts-82l","title":"PROPOSE_PLAN: REVISION-2 — aura-scripts Nix flake with HM modules","description":"REVISION-2: Addressing review findings from REVIEW_1 (ACCEPT), REVIEW_2 (REVISE), REVIEW_3 (ACCEPT).\n\n## What Changed from REVISION-1\n\n### 1. Acknowledged existing implementation (Phases 1-3 DONE)\n\nThe HM module (`nix/hm-module.nix`) and flake already implement:\n- Flake skeleton with `packages` output (launch-parallel, aura-swarm)\n- `aura-protocol` — protocol docs install to `~/.claude/` or `~/.config/aura/protocol/`\n- `aura-commands` — slash command `.md` files with role filtering and `enableAll` pattern\n- `aura-agents` — agent `.md` files into `~/.claude/agents/` (was undocumented in REVISION-1)\n- `packages` toggle — installable via `home.packages` when `packages.enable = true`\n\n### 2. Added `agents` section to spec\n\n```nix\nagents = {\n  enable = mkOption { type = bool; default = true; };\n  extraAgents = mkOption { type = attrsOf path; default = {}; };\n};\n```\nEffect: Installs all `.md` files from `agents/` into `~/.claude/agents/`, plus any user-supplied extras.\n\n### 3. Fixed `protocol.target` to match implementation\n\nProposal REVISION-1 said `enum [\"claude\" \"opencode\" \"both\"]`.\nImplementation correctly uses `enum [\"global\" \"xdg\"]`:\n- `\"global\"` → `~/.claude/`\n- `\"xdg\"` → `~/.config/aura/protocol/`\n\nThis avoids premature OpenCode coupling. OpenCode support is its own phase.\n\n### 4. Reframed phases to reflect actual remaining work\n\nOLD phases (REVISION-1):\n1. Flake skeleton + packages ← ALREADY DONE\n2. aura-protocol HM module ← ALREADY DONE\n3. aura-commands HM module ← ALREADY DONE\n4. aura-agent-config HM module\n5. Integration test\n\nNEW phases:\n1. **Fix package wrapping** — Replace `writeScriptBin` with `writeShellApplication` or `makeWrapper` so runtime deps (tmux, git, claude) are in PATH\n2. **Fix `lib ? config.lib`** — Remove non-standard fallback, use `lib` from module args directly\n3. **Integration test** — Wire into dotfiles flake, verify `home-manager switch` produces correct output\n4. **agentConfig HM module** — Generate `~/.claude/settings.json` from Nix options (Claude Code first). Must address `home.file` read-only symlink constraint — settings.json needs writeback, so use `home.file.*.text` with `home.activation` script or `xdg.configFile` with mutable copy\n5. **OpenCode config generation** — Translate shared options to OpenCode config format (own phase, not a parenthetical)\n\n### 5. Runtime dependency wrapping (G1 — all reviewers flagged)\n\nCurrent `writeScriptBin` only patches the shebang. `launch-parallel.py` calls `subprocess` to launch tmux sessions — tmux won't be found unless separately in PATH. `aura-swarm` likely needs git and claude CLI.\n\nFix: Use `writeShellApplication` which supports `runtimeInputs`:\n```nix\nlaunch-parallel = pkgs.writeShellApplication {\n  name = \"launch-parallel\";\n  runtimeInputs = [ pkgs.python3 pkgs.tmux pkgs.git ];\n  text = ''exec python3 ${./launch-parallel.py} \"$@\"'';\n};\n```\n\nOr use `makeWrapper`/`wrapProgram` on the existing derivation.\n\n### 6. `home.file` immutability and Phase 4 design (T1)\n\n`home.file.*.source = storePath` creates read-only `/nix/store` symlinks. Fine for commands, agents, protocol docs. **Blocker for Phase 4**: Claude Code writes to `settings.json` at runtime.\n\nOptions for Phase 4:\n- **A) `home.activation` script**: Generate settings.json to a temp location, copy (not symlink) on activation. User edits persist until next `home-manager switch`.\n- **B) Nix-managed read-only + runtime overlay**: Generate base config from Nix, Claude Code reads base + writes overrides to a separate file, merge at startup.\n- **C) `home.file.*.text` + `home.file.*.force`**: Overwrite on each switch. Simplest but loses runtime changes.\n\nRecommend **Option A** for Phase 4 — defer detailed design to that phase.\n\n### 7. Updated validation checklist (separated by phase)\n\n**Phase 1 (package wrapping):**\n- [ ] `launch-parallel` finds tmux at runtime without tmux in user PATH\n- [ ] `aura-swarm` finds git and claude at runtime\n- [ ] `nix flake show` produces expected outputs\n- [ ] `nix flake check` passes\n\n**Phase 2 (lib fix):**\n- [ ] Remove `lib ? config.lib`, verify module still evaluates correctly\n\n**Phase 3 (integration test):**\n- [ ] Dotfiles flake imports aura-scripts without conflicts\n- [ ] `home-manager switch` completes successfully\n- [ ] Slash commands appear in `~/.claude/commands/`\n- [ ] Agent files appear in `~/.claude/agents/`\n- [ ] Protocol docs appear when `protocol.enable = true`\n- [ ] `enableAll=false` with individual role enables works\n- [ ] `extraCommands` and `extraAgents` extension points work\n- [ ] `protocol.target = \"xdg\"` installs to correct location\n- [ ] No `home.file` attr collisions across sections\n\n**Phase 4 (agentConfig — future):**\n- [ ] `home-manager switch` produces correct `~/.claude/settings.json`\n- [ ] Settings.json writeback strategy works at runtime\n\n**Phase 5 (OpenCode — future):**\n- [ ] OpenCode config generated when `opencode.enable = true`\n\n## Architecture (unchanged from REVISION-1)\n\nSingle module at `CUSTOM.programs.aura-config-sync` with subsections: `packages`, `commands`, `agents`, `protocol`, and future `agentConfig`, `security`, `hooks`.\n\n## Tradeoffs (updated)\n\n| Decision | Chosen | Alternative | Rationale |\n|----------|--------|-------------|-----------|\n| Config generation | Pure Nix functions | Runtime Go/TS daemon | Simpler, reproducible, no state |\n| Module granularity | 1 module, N subsections | N separate modules | Single import, composable via enables |\n| Command installation | File copy via HM | Symlinks into repo | HM manages files; no dangling symlinks |\n| Protocol doc location | Stay in aura-scripts | Move to dotfiles | Protocol is reusable across users/projects |\n| Package wrapping | writeShellApplication | writeScriptBin | Proper runtime dep closure |\n| protocol.target | global/xdg enum | claude/opencode/both | Filesystem location, not tool targeting |\n| settings.json strategy | home.activation copy (Phase 4) | home.file symlink | Allows runtime writeback |\n| No lib export from flake | Keep internal | Export listMdFiles etc. | YAGNI — export when needed |\n| Schema evolution | Noted as future concern | Version tracking now | Premature until config formats stabilize |","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-18T06:11:04.780815709-08:00","created_by":"David Huu Pham","updated_at":"2026-02-18T06:11:04.780815709-08:00","labels":["aura:plan:proposal","proposal-2"],"dependencies":[{"issue_id":"aura-scripts-82l","depends_on_id":"aura-scripts-5fk","type":"relates-to","created_at":"2026-02-18T06:15:34.682583961-08:00","created_by":"David Huu Pham"},{"issue_id":"aura-scripts-82l","depends_on_id":"aura-scripts-ci4","type":"relates-to","created_at":"2026-02-18T06:47:54.159050888-08:00","created_by":"David Huu Pham"}],"comments":[{"id":10,"issue_id":"aura-scripts-82l","author":"David Huu Pham","text":"REVIEW_1 follow-up: ACCEPT\n\n## REVISION-2 Assessment\n\nREVISION-2 addresses the critical findings from all three reviews:\n\n**Resolved (all reviewers):**\n- G1 runtime deps: Concrete writeShellApplication example with runtimeInputs ✓\n- G2 lib fallback: Explicitly called out as Phase 2 fix ✓\n- G3/G4 agents + phase clarity: Agents added to spec, phases reframed to reflect actual state ✓\n- T1 settings.json writeback: Three options enumerated, Option A (home.activation) recommended ✓\n- Protocol.target corrected to global/xdg ✓\n- Validation checklist separated by phase ✓\n\n**Unresolved (minor, non-blocking):**\n1. **T3 flake input naming** — The dotfiles integration example should note that `follows` needs `inputs.aura-scripts.inputs.nixpkgs-stable.follows = \"nixpkgs\"` (not just `inputs.nixpkgs.follows`). Phase 3 integration will surface this — acceptable to catch then.\n2. **Epoch role classification** (REVIEW_3) — `roleNames` treats epoch as a role equal to architect/worker/etc, but it's a workflow orchestrator. Similarly, user/msg/impl commands are always-needed infrastructure. The `coreCommands` filter catches non-role-prefixed commands, but `aura:epoch.*` IS role-prefixed. With `enableAll=false` + `epoch.enable=false`, epoch commands vanish — probably unintended. Suggest either: (a) move epoch out of roleNames into coreCommands, or (b) document that epoch should always be enabled. Non-blocking for current work since enableAll defaults to true.\n3. **No `checks` output** (REVIEW_3) — `nix flake check` in the checklist only validates evaluation, not file layout correctness. A `runCommand`-based check would be stronger. Fine to defer — Phase 3 integration test is the real validation.\n\n## Verdict\nACCEPT — REVISION-2 is ready for ratification. All critical and medium-risk findings are addressed. The three unresolved items are minor and can be handled during implementation without architectural changes.","created_at":"2026-02-18T14:16:21Z"},{"id":11,"issue_id":"aura-scripts-82l","author":"David Huu Pham","text":"REVIEW_2: ACCEPT\n\n## Findings Checklist (vs. my original REVISE vote on REVISION-1)\n\n1. ✅ Acknowledged existing implementation — Phases 1-3 clearly marked as DONE\n2. ✅ Added agents section to spec — documented with options\n3. ✅ Fixed protocol.target — now global/xdg matching implementation\n4. ✅ Reframed phases — 5 new phases starting from actual remaining work\n5. ✅ Runtime dep wrapping — writeShellApplication with runtimeInputs proposed\n6. ✅ Validation checklist — separated by phase, includes all previously missing items\n7. ✅ OpenCode — now its own Phase 5\n\n## New Observations (non-blocking)\n\n**a) aura-swarm also needs `bd` (beads CLI)**: Verified by grepping subprocess calls — aura-swarm calls `bd show`, `bd create` at runtime. Phase 1 runtimeInputs for aura-swarm should be: python3, tmux, git, and bd (if available as Nix pkg, otherwise document as user-PATH dependency).\n\n**b) Phase 2 (lib fix) is correct**: Verified line 5 of hm-module.nix has `lib ? config.lib`. Standard HM modules receive `lib` directly from module args — the fallback to config.lib is non-standard and could mask evaluation errors.\n\n**c) Phase 4 Option A is sound**: home.activation copy is the standard Nix pattern for mutable config files. The tradeoff (switch overwrites runtime edits) is acceptable and well-documented.\n\n## Verdict\nAll original REVISE concerns addressed. Phases are realistic, validation is thorough, forward-looking design for Phase 4 is well-reasoned. ACCEPT.","created_at":"2026-02-18T14:16:36Z"},{"id":13,"issue_id":"aura-scripts-82l","author":"David Huu Pham","text":"REVIEW_3 (re-review): ACCEPT\n\n## Systematic check: all review findings vs REVISION-2\n\n### REVIEW_1 findings (ACCEPT):\n- G1 runtime deps: ADDRESSED (§5 — writeShellApplication with runtimeInputs)\n- G2 lib fallback: ADDRESSED (Phase 2 — remove it)\n- G3 agentConfig annotation: ADDRESSED (§4 — clearly Phase 4)\n- G4 agents undocumented: ADDRESSED (§2 — added to spec)\n- T1 home.file immutability: ADDRESSED (§6 — three options, recommends activation script)\n- T2 nixosModules: NOT ADDRESSED — user mentioned in URE Q6 \"Flake should provide nixosModules and/or hmModules.\" Minor — HM is the current use case, can add later.\n- T3 flake input follows: NOT ADDRESSED — dotfiles integration example says `inputs.aura-scripts.inputs.nixpkgs.follows = \"nixpkgs\"` but the actual aura-scripts flake uses `nixpkgs = nixpkgs-stable` (via rec). The correct follows directive in dotfiles would need to be `inputs.aura-scripts.inputs.nixpkgs-stable.follows = \"nixpkgs\"`. This is a correctness issue in the integration instructions but can be caught during Phase 3 integration testing.\n\n### REVIEW_2 findings (REVISE — the critical one):\n- Acknowledge existing impl: ADDRESSED (§1)\n- Reframe phases: ADDRESSED (§4 — 5 new phases reflecting actual remaining work)\n- Add agents: ADDRESSED (§2)\n- Fix protocol.target: ADDRESSED (§3)\n- Runtime dep wrapping: ADDRESSED (§5)\n- Protocol CLAUDE.md conflict/merge: NOT ADDRESSED — no discussion of what happens if user has personal CLAUDE.md and enables protocol docs. Low risk since protocol.enable defaults to false. Documenting the overwrite behavior would be sufficient.\n- No lib export: ADDRESSED (tradeoffs table — YAGNI)\n- OpenCode phasing: ADDRESSED (Phase 5 — its own clearly-scoped phase)\n- Schema evolution: ADDRESSED (tradeoffs table — noted as future concern)\n\n### REVIEW_3 findings (mine):\n- Implementation ahead of proposal: ADDRESSED (§1)\n- Protocol target divergence: ADDRESSED (§3)\n- Validation checklist mixed: ADDRESSED (§7 — separated by phase, thorough)\n- lib fallback: ADDRESSED (Phase 2)\n- Epoch role classification: NOT ADDRESSED — \"epoch\" in roleNames is debatable since it's a workflow orchestrator, not an agent role. But this is a naming/classification nit, not an architectural issue.\n- No flake checks output: NOT ADDRESSED — `nix flake check` validates evaluation only; no actual `checks` output in the flake for testing file layout. Can be added as part of Phase 3 but doesn't block ratification.\n\n## Remaining unaddressed items (all minor):\n1. Flake input follows directive (T3) — integration instructions need correction for nixpkgs-stable. Phase 3 integration testing will catch this.\n2. Protocol CLAUDE.md overwrite behavior — needs a one-line note: \"protocol.enable replaces existing CLAUDE.md; defaults to false for this reason.\"\n3. Epoch role classification — naming nit, no architectural impact.\n4. nixosModules output — YAGNI for now.\n5. No checks flake output — can be Phase 3 scope.\n\n## Verdict\nACCEPT. All major findings from the REVISE vote (REVIEW_2) are addressed. The remaining items are minor and can be handled during implementation phases rather than blocking ratification. The phasing is now realistic, the validation checklist is thorough and phase-separated, and the settings.json writeback strategy is properly scoped as a design decision for Phase 4.","created_at":"2026-02-18T14:16:39Z"},{"id":15,"issue_id":"aura-scripts-82l","author":"David Huu Pham","text":"RATIFIED: All 3 reviewers ACCEPT on REVISION-2, UAT passed (aura-scripts-ci4). Plan approved with design changes captured in UAT.","created_at":"2026-02-18T14:53:08Z"}]}
{"id":"aura-scripts-981","title":"Revert REQUEST→EPIC renaming: epics are a task type, not a replacement for REQUEST","description":"REQUEST was incorrectly renamed to EPIC in the Beads system. Epics are just a task type within Beads (like task, bug, feature), not a replacement for the REQUEST concept. The REQUEST type should be restored as its own distinct concept, and epic should remain only as a --type value for bd create.","status":"open","priority":2,"issue_type":"bug","owner":"dayvidpham@gmail.com","created_at":"2026-02-18T06:07:44.377640159-08:00","created_by":"David Huu Pham","updated_at":"2026-02-18T06:07:48.912745406-08:00"}
{"id":"aura-scripts-ci4","title":"UAT-1: Plan acceptance for aura-scripts Nix flake REVISION-2","description":"## Components Reviewed\n\n### Component 1: Module Structure\n**Definition shown:**\n```nix\nCUSTOM.programs.aura-config-sync = {\n  enable = true;\n  packages.enable = true;\n  commands.enable = true;\n  agents.enable = true;\n  protocol.enable = false;\n};\n```\n**Motivating example:** Minimal setup enabling only commands (packages/agents disabled).\n\n**Q1: The module uses CUSTOM.programs.aura-config-sync as the namespace. This matches your dotfiles convention (CUSTOM.programs.*). The alternative would be programs.aura-config-sync (standard HM namespace) or services.aura-config-sync. Which namespace is correct?**\nOptions:\n- CUSTOM.programs (current) — Matches your dotfiles convention for custom HM modules — keeps it separate from upstream programs.*\n- programs.aura-config-sync — Standard HM namespace — discoverable but risks collision with future upstream modules\n- aura.config-sync — Custom top-level namespace — clearly non-standard, no collision risk\n**User response:** \"The CUSTOM namespace is for the modules defined in the @~/dotfiles repo. Since this is external, should go into aura.config-sync\"\n\n**Q2: Protocol docs default to enable = false because installing to ~/.claude/CLAUDE.md would overwrite any personal CLAUDE.md you have there. The alternative is default true with a merge strategy. Is default-off the right call?**\nOptions:\n- Default off (current) — User must opt-in. Safest — never overwrites personal CLAUDE.md. But easy to forget to enable.\n- Default on, xdg target — Default to ~/.config/aura/protocol/ instead of ~/.claude/ — always installs but never conflicts with personal CLAUDE.md\n- Default on, global target — Installs to ~/.claude/ — convenient but WILL overwrite personal CLAUDE.md on every home-manager switch\n**User response:** \"Default on, xdg target\"\n\n**Decision:** ACCEPT\n\n---\n\n### Component 2: Commands with Role Filtering\n**Definition shown:**\n```nix\naura.config-sync.commands = {\n  enable = true;\n  roles = { enableAll = true; architect.enable = ...; supervisor.enable = ...; worker.enable = ...; reviewer.enable = ...; epoch.enable = ...; };\n  extraCommands = { \"my-custom:command.md\" = ./my-command.md; };\n};\n```\n**Motivating example:** Worker-only machine with enableAll=false, worker.enable=true.\n\n**Q1: Currently epoch is classified as a role alongside architect/supervisor/worker/reviewer. But epoch orchestrates ALL roles — setting enableAll=false would hide it, which breaks orchestration. Should epoch be reclassified?**\nCore commands (always installed): aura:plan, aura:status, aura:test, aura:feedback, aura:msg:*, aura:impl:*, aura:user:*\nRole commands (togglable): aura:architect:*, aura:supervisor:*, aura:worker:*, aura:reviewer:*\nOptions:\n- Move epoch to core commands — Always installed regardless of enableAll. Epoch orchestrates all roles so it should always be available.\n- Keep epoch as a role — A machine running only workers doesn't need epoch. User can explicitly enable epoch alongside their chosen roles.\n- Separate orchestration tier — Three tiers: core (always), orchestration (epoch), roles (architect/supervisor/worker/reviewer). Adds complexity but models the hierarchy accurately.\n**User response:** \"Move epoch to core commands\"\n\n**Q2: The extraCommands extension point uses attrsOf path — keys are filenames, values are file paths. This means you can add project-specific commands. Is this the right extension mechanism, or should it support inline text too?**\nOptions:\n- Path only (current) — Simple — just point to .md files. Consistent with how all other commands work.\n- Path or text — attrsOf (either path or str) — allows inline command definitions in Nix config. More flexible but mixed types add complexity.\n- Path only + extraCommandDirs — Add a second option to include entire directories of commands. Useful if you have many project-specific commands.\n**User response:** \"Path only + extraCommandDirs\"\n\n**Q3 (user-initiated comment, verbatim):** \"installation should rely mostly on creating mkOutOfStoreSymlink paths, similar to some other existing configs in ~/dotfiles that require more responsiveness and live updating, and don't require an entire build/recompilation step.\"\n\n**Decision:** ACCEPT with comments (mkOutOfStoreSymlink)\n\n---\n\n### Component 3: Package Wrapping\n**Definition shown:**\n```nix\n# Current (broken): writeScriptBin with shebang replace only\n# Proposed: writeShellApplication with runtimeInputs = [ python3 tmux git ]\n```\n**Motivating example:** launch-parallel fails at runtime because tmux not in PATH.\n\n**Q1: launch-parallel.py needs tmux and git at runtime. aura-swarm needs git, bd (beads CLI), and claude. Should ALL runtime deps be baked into the Nix wrapper, or should some be expected from the user's PATH?**\nOptions:\n- Bake all in (hermetic) — writeShellApplication with all runtimeInputs. launch-parallel gets python3+tmux+git. aura-swarm gets python3+git+bd+claude. Fully reproducible.\n- Bake tmux+python, expect claude+bd from PATH — claude and bd are user-managed tools (not in nixpkgs or custom). Wrap what Nix can provide, leave the rest to PATH.\n- Expect all from PATH — Only patch the shebang. User is responsible for having tmux, git, claude, bd available. Lightest wrapper.\n**User response:** \"Bake all in (hermetic)\"\n\n**Decision:** ACCEPT\n\n---\n\n### Component 4: settings.json Writeback Strategy (Phase 4)\n**Definition shown:** Three options: A) activation copy, B) base+overlay merge, C) nix-only read-only\n**Motivating example:** Claude Code writes permissions to settings.json at runtime; home.file symlinks are read-only.\n\n**Q1: Claude Code writes to ~/.claude/settings.json at runtime (e.g., when you grant permissions). Nix home.file creates read-only symlinks. How should Phase 4 handle this conflict?**\nOptions:\n- Activation copy (Option A) — Nix generates file, copies on switch. Runtime edits persist between switches but get overwritten on next rebuild. Simplest to implement.\n- Base + overlay (Option B) — Nix writes settings.base.json (immutable), runtime writes to settings.local.json, merged at startup. Never loses runtime changes. But requires custom merge logic and Claude Code doesn't support split configs.\n- Nix-only, no runtime writes (Option C) — All settings managed in Nix. home.file symlink, read-only. If Claude Code tries to write, it fails. You manage ALL permissions/settings in your Nix config.\n- Defer to Phase 4 — Don't decide now. Phase 4 design will have more context about what Claude Code actually needs at runtime. Just note it as an open question.\n**User response:** \"Defer to Phase 4\" with note: \"Can do Option B with some custom script for merging a user's config with the into the final\"\n\n**Decision:** ACCEPT\n\n---\n\n### Component 5: mkOutOfStoreSymlink for Live Updates\n**Definition shown:**\n```nix\n# Store symlink (current): source = \"${self}/commands/file.md\" → /nix/store/...\n# Out-of-store (proposed): source = config.lib.file.mkOutOfStoreSymlink \"/home/.../aura-scripts/commands/file.md\"\n```\n**Motivating example:** Edits to command files in repo immediately visible without home-manager switch.\n\n**Q1: mkOutOfStoreSymlink needs the absolute path to the aura-scripts repo checkout. How should this be configured?**\nOptions:\n- Explicit repoPath option (required) — User sets the path in their config. Clear, no magic. Fails with assertion if not set.\n- Explicit repoPath with default — Default to a conventional path like ~/codebases/dayvidpham/aura-scripts. User can override. Convenient but assumes directory structure.\n- Detect from flake input — Use self.outPath or builtins.toString self to derive the path. Works when flake is a local path input, not when fetched from GitHub.\n**User response:** \"Explicit repoPath option (required)\"\n\n**Q2: Should ALL file types use mkOutOfStoreSymlink (commands, agents, protocol docs), or only some?**\nOptions:\n- All files use mkOutOfStoreSymlink — Commands, agents, and protocol docs all live-update. Consistent behavior. All require repoPath.\n- Commands + agents live, protocol via store — Commands/agents change often during development. Protocol docs are more stable — store path is fine.\n- Make it configurable per section — Add a liveUpdate = true/false toggle per section. Maximum flexibility, more options to manage.\n**User response:** \"All files use mkOutOfStoreSymlink\"\n\n**User comment (verbatim):** \"Wondering how this will work with cross-config compilation. Should we adopt a yaml file based approach, some base json schema, or Nix-native? I think the agentconfig repo adopts a yaml file based approach?\"\n\n**Decision:** ACCEPT with comments\n\n---\n\n## Final Decision\n**ACCEPT** — All 5 components accepted. Key design changes from REVISION-2:\n1. Namespace: aura.config-sync (not CUSTOM.programs)\n2. Protocol: default on, xdg target\n3. Epoch: core command, not a role\n4. Extra commands: path + extraCommandDirs\n5. Installation: mkOutOfStoreSymlink with required repoPath\n6. Package wrapping: hermetic (all deps baked in)\n7. settings.json: deferred to Phase 4, Option B likely direction\n8. Open question: cross-config compilation strategy (yaml/json/nix-native) for Phase 4","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-18T06:47:50.616746754-08:00","created_by":"David Huu Pham","updated_at":"2026-02-18T06:55:49.823134533-08:00","closed_at":"2026-02-18T06:55:49.823134533-08:00","close_reason":"UAT passed, all 5 components ACCEPTED. Plan ratified.","labels":["aura:user:uat","proposal-2:uat-1"],"dependencies":[{"issue_id":"aura-scripts-ci4","depends_on_id":"aura-scripts-82l","type":"relates-to","created_at":"2026-02-18T06:47:54.158209461-08:00","created_by":"David Huu Pham"}],"comments":[{"id":14,"issue_id":"aura-scripts-ci4","author":"David Huu Pham","text":"UAT ADDENDUM (user-initiated, verbatim):\n\n\"I think we should have the cross-config compilation step PRODUCE a set of configs at pre-determined locations INSIDE the config-sync repo, then we can use mkOutOfStoreSymlink on the build artifacts of the compilation step.\"\n\nDesign implication for Phase 4+:\n- Cross-config compilation (yaml/json/nix → tool-specific configs) writes output to e.g. aura-scripts/build/ or aura-scripts/.out/\n- mkOutOfStoreSymlink points ~/.claude/settings.json → aura-scripts/.out/claude/settings.json\n- Nix HM module doesn't generate configs itself — it symlinks to the compilation output\n- This cleanly separates: (1) config compilation (build step, can be any toolchain), (2) config installation (Nix HM symlinks)\n- Solves the settings.json writeback problem: compilation output is a regular file, not a /nix/store symlink","created_at":"2026-02-18T14:49:36Z"}]}
{"id":"aura-scripts-eiq","title":"REVIEW_1: Plan review for aura-scripts Nix flake","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-18T05:56:14.605386475-08:00","created_by":"David Huu Pham","updated_at":"2026-02-18T06:07:49.177812248-08:00","closed_at":"2026-02-18T06:07:49.177812248-08:00","close_reason":"Closed","labels":["aura:plan:review"],"dependencies":[{"issue_id":"aura-scripts-eiq","depends_on_id":"aura-scripts-5fk","type":"blocks","created_at":"2026-02-18T05:56:19.886599733-08:00","created_by":"David Huu Pham"}],"comments":[{"id":7,"issue_id":"aura-scripts-eiq","author":"David Huu Pham","text":"VOTE: ACCEPT — Proposal is architecturally sound with implementation already ahead of plan. Key notes: (1) Package wrapping needs runtime deps via makeWrapper, (2) Validation checklist should separate MVP from Phase 4 items, (3) agents subsection is implemented but undocumented in proposal, (4) home.file immutability will need Phase 4 design consideration for settings.json writeback. All gaps are addressable without architectural changes.","created_at":"2026-02-18T14:07:43Z"}]}
{"id":"aura-scripts-ght","title":"EPIC: Unified agent config — aura-scripts as Nix flake with HM modules","description":"VERBATIM USER REQUEST:\n\nShould look into @~/codebases/agentconfig to create a single source of truth for our ~/.claude/commands, hooks, configs, and settings/permissions. The burden is increasing to try and get a single common config for both Claude Code and OpenCode; a more recent version of some commands and CLAUDE.md files exist at @~/codebases/dayvidpham/aura-scripts/protocol/ .\n\n---\n\nCONTEXT:\n- ~/codebases/agentconfig is an existing TypeScript project (has package.json, tsconfig, src/, test/)\n- ~/.claude/commands/ contains aura slash commands\n- ~/codebases/dayvidpham/aura-scripts/protocol/ has newer versions of CLAUDE.md, CONSTRAINTS.md, PROCESS.md\n- User wants unified config management across Claude Code and OpenCode\n- Current pain: maintaining duplicate/divergent configs across tools","status":"open","priority":2,"issue_type":"feature","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T23:42:08.038271796-08:00","created_by":"David Huu Pham","updated_at":"2026-02-18T06:04:41.498825719-08:00","labels":["aura:user:request"],"dependencies":[{"issue_id":"aura-scripts-ght","depends_on_id":"aura-scripts-7o2","type":"blocks","created_at":"2026-02-18T06:02:36.850277223-08:00","created_by":"David Huu Pham"}],"comments":[{"id":1,"issue_id":"aura-scripts-ght","author":"David Huu Pham","text":"USER ADDENDUM: An immediate translation and integration point to set up soon is ~/codebases/dayvidpham/opencode-security","created_at":"2026-02-18T07:42:16Z"}]}
{"id":"aura-scripts-m1w","title":"REVIEW_3: Plan review for aura-scripts Nix flake","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-18T05:56:14.655303784-08:00","created_by":"David Huu Pham","updated_at":"2026-02-18T06:09:11.328459698-08:00","closed_at":"2026-02-18T06:09:11.328459698-08:00","close_reason":"Closed","labels":["aura:plan:review"],"dependencies":[{"issue_id":"aura-scripts-m1w","depends_on_id":"aura-scripts-5fk","type":"blocks","created_at":"2026-02-18T05:56:19.931157716-08:00","created_by":"David Huu Pham"}],"comments":[{"id":9,"issue_id":"aura-scripts-m1w","author":"David Huu Pham","text":"VOTE: ACCEPT — Architecture is sound, implementation is ahead of proposal. Single-module design correctly uses CUSTOM.programs namespace. Key notes: (1) agents section implemented but not in proposal, (2) protocol.target diverged from proposal (improvement), (3) validation checklist mixes MVP and Phase 4 items, (4) epoch classification as \"role\" is debatable. See full review on aura-scripts-5fk.","created_at":"2026-02-18T14:08:47Z"}]}
{"id":"aura-scripts-ztn","title":"URE: Unified agent config via Nix home-manager modules","description":"PHASE 2: USER REQUIREMENTS ELICITATION\n\n## Verbatim User Request (Phase 1)\n\n\"Should look into @~/codebases/agentconfig to create a single source of truth for our ~/.claude/commands, hooks, configs, and settings/permissions. The burden is increasing to try and get a single common config for both Claude Code and OpenCode; a more recent version of some commands and CLAUDE.md files exist at @~/codebases/dayvidpham/aura-scripts/protocol/ .\"\n\nAddendum: \"An immediate translation and integration point I want to set up soon is @~/codebases/dayvidpham/opencode-security\"\n\n## Questions \u0026 Answers (All Verbatim)\n\n### Q1: What is the primary artifact you want agentconfig to manage?\nOptions presented: Everything unified | Settings + commands only | Config translation layer\n**Answer: Everything unified** — agentconfig becomes single source for settings/permissions, slash commands, protocol docs, hooks, and security filter config.\n\n### Q2: For the OpenCode integration, what does the translation look like?\nOptions: Bidirectional sync | One canonical source | Just security for now\n**Answer: Bidirectional sync** — can read either tool config and translate to the other.\n\n### Q3: Where should protocol docs live canonically?\nOptions: Stay in aura-scripts | Move to agentconfig | Shared git submodule\n**Answer (verbatim):** \"For my purposes, turn aura-scripts into a set of consumable NixOS modules/home-manager modules. In that case, should stay in aura-scripts, or can go in @~/dotfiles\"\n\n### Q4: What is the deployment model?\nOptions: Symlinks | Build + install script | Nix/Home Manager\n**Answer (verbatim):** \"Nix/Home Manager. How complicated is agentconfig? Does it deal with versioned schemas for the various tools?\"\n(Answered: agentconfig has Zod schemas but no versioned schema migrations.)\n\n### Q5: Dotfiles repo — does it already use home-manager?\nOptions: Flake + home-manager | Flake no HM | Not Nix-based\n**Answer: Flake + home-manager** — already manages some configs declaratively.\n\n### Q6: Nix module architecture for aura-scripts?\nOptions: Flake with HM module | Overlay + packages | Monorepo in dotfiles\n**Answer (verbatim):** \"Should maybe be (1) and (2). Would want a good flake with options to support tweaking and customization. What would we even be overlaying? Flake should provide nixosModules and/or hmModules, have seen this pattern before.\"\n\n### Q7: Sync engine — bidirectional sync approach?\nOptions: Nix-generated static | agentconfig TypeScript | Hybrid\n**Answer (verbatim):** \"Should be (1) for now, but should actually be using Golang. (1) is required when binaries or scripts (aura-swarm or launch-parallel) change.\"\n\n### Q8: Priority order?\nOptions: Nix module | OpenCode security | Config translation | Unify commands\n**Answer:** \"(1) Nix module, then (3) Config translation, then (4) Unify commands, then (2) OpenCode security\"\n\n## Additional User Feedback (Post-Elicitation)\n\n### Role of agentconfig\n**Verbatim:** \"We want to use agentconfig as inspiration for our own project, not using it in its own right.\"\n\n### Module structure\nUser rejected 3 separate HM modules. Wants a **single module**: `homeManagerModules.aura-config-sync`\n\n### Role selection pattern\nUser wants individual enables with `enableAll` default, NOT a list of role strings:\n```nix\nroles = {\n  enableAll = mkOption { type = bool; default = true; };\n  architect.enable = mkOption { ... default = cfg.commands.roles.enableAll; };\n  # etc.\n};\n```\n\n### Review process\nUser stated: \"Dont skip formal review.\" Then: \"Shouldnt be using the launch-parallel script, should just launch them with TeamCreate.\"\n\n### Epic structure\nUser stated: \"This should be an epic, and should have been captured by a URD.\"\nUser stated: \"The URE should capture all of the users inputs and feedback. It must also keep all of the users Q\u0026A.\"","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-18T05:49:46.54675304-08:00","created_by":"David Huu Pham","updated_at":"2026-02-18T06:03:45.046885864-08:00","labels":["aura:user:elicit"],"dependencies":[{"issue_id":"aura-scripts-ztn","depends_on_id":"aura-scripts-ght","type":"blocks","created_at":"2026-02-18T05:49:51.149323164-08:00","created_by":"David Huu Pham"}]}
