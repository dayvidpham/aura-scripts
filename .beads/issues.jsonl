{"id":"aura-plugins-06g","title":"IMPL_PLAN: Machine-executable aura protocol engine v1 MVP","description":"---\nreferences:\n  request: aura-plugins-bj1\n  urd: aura-plugins-umi\n  proposal: aura-plugins-gmv\n  handoff: aura-plugins-b5m\n---\n## Layer Structure (TDD)\n\n### Vertical Slices\n- SLICE-1 (aura-plugins-35d): types.py — Protocol type definitions (enums, frozen specs, lookup dicts)\n  - SLICE-1-IMPL (aura-plugins-9nc): types.py + __init__.py\n  - SLICE-1-TESTS (aura-plugins-g2a): test_aura_types.py + test_schema_types_sync.py\n  - Deps: None (foundation)\n- SLICE-2 (aura-plugins-la6): state_machine.py — 12-phase epoch lifecycle\n  - SLICE-2-L1 (aura-plugins-125): Type structure\n  - SLICE-2-L2 (aura-plugins-4mu): test_state_machine.py\n  - SLICE-2-L3 (aura-plugins-0n3): Implementation\n  - Deps: SLICE-1\n- SLICE-3 (aura-plugins-mrm): constraints.py — Runtime constraint validators\n  - SLICE-3-L1 (aura-plugins-eel): Type structure\n  - SLICE-3-L2 (aura-plugins-w28): test_constraints.py\n  - SLICE-3-L3 (aura-plugins-9ii): Implementation\n  - Deps: SLICE-1, SLICE-2\n- SLICE-4 (aura-plugins-8i5): interfaces.py — Cross-project integration + A2A types\n  - SLICE-4-L1 (aura-plugins-1cy): Protocol interfaces + A2A types\n  - SLICE-4-L2 (aura-plugins-exe): test_interfaces.py\n  - SLICE-4-L3 (aura-plugins-0rd): ModelId.parse() + event stubs\n  - Deps: SLICE-1 only\n- SLICE-5 (aura-plugins-lkz): workflow.py — Temporal workflow wrapper\n  - SLICE-5-L1 (aura-plugins-r1n): Temporal types + search attrs + pyproject.toml\n  - SLICE-5-L2 (aura-plugins-amx): test_workflow.py\n  - SLICE-5-L3 (aura-plugins-2au): EpochWorkflow + activities\n  - Deps: SLICE-1, SLICE-2, SLICE-3\n\n## Parallelism Layers\n- Layer 0: SLICE-1 (foundation, solo)\n- Layer 1: SLICE-2 + SLICE-4 (parallel after SLICE-1)\n- Layer 2: SLICE-3 (after SLICE-2)\n- Layer 3: SLICE-5 (after SLICE-3)\n\n## BDD Acceptance Criteria (10)\nAC1-AC10 from RATIFIED_PLAN (aura-plugins-gmv)","status":"in_progress","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:28:48Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:33:36Z","labels":["aura:p8-impl:s8-plan"],"dependencies":[{"issue_id":"aura-plugins-06g","depends_on_id":"aura-plugins-35d","type":"blocks","created_at":"2026-02-21T17:31:27Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-06g","depends_on_id":"aura-plugins-8i5","type":"blocks","created_at":"2026-02-21T17:31:29Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-06g","depends_on_id":"aura-plugins-la6","type":"blocks","created_at":"2026-02-21T17:31:28Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-06g","depends_on_id":"aura-plugins-lkz","type":"blocks","created_at":"2026-02-21T17:31:30Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-06g","depends_on_id":"aura-plugins-mrm","type":"blocks","created_at":"2026-02-21T17:31:29Z","created_by":"David Huu Pham","metadata":"{}"}],"comments":[{"id":9,"issue_id":"aura-plugins-06g","author":"David Huu Pham","text":"Phase 8 complete. IMPL_PLAN decomposed into 5 vertical slices with 14 leaf tasks. Handoff docs created for all workers. SLICE-1 worker spawned (Worker-1). Waiting for SLICE-1 foundation to complete before spawning Layer 1 (SLICE-2 + SLICE-4 in parallel).","created_at":"2026-02-22T01:36:08Z"}]}
{"id":"aura-plugins-0n3","title":"SLICE-2-L3: Impl — EpochStateMachine logic","description":"---\nreferences:\n  slice: aura-plugins-la6\n  impl_plan: aura-plugins-06g\n---\n## Scope\nImplement EpochStateMachine: advance(), validate_advance(), record_vote(), has_consensus(), record_blocker(), available_transitions. Makes L2 tests pass.\n\n## Files Owned\n- scripts/aura_protocol/state_machine.py (fill in implementations)\n\n## Acceptance Criteria\nGiven EpochStateMachine when advance(valid) then transitions correctly, when advance(invalid) then TransitionError raised should never allow invalid transitions","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:32:39Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:32:39Z","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-0n3","depends_on_id":"aura-plugins-4mu","type":"blocks","created_at":"2026-02-21T17:32:39Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-0rd","title":"SLICE-4-L3: Impl — ModelId.parse() + event stubs","description":"---\nreferences:\n  slice: aura-plugins-8i5\n  impl_plan: aura-plugins-06g\n---\n## Scope\nImplement ModelId.parse() and finalize event stub types. Makes L2 tests pass.\n\n## Files Owned\n- scripts/aura_protocol/interfaces.py (fill in implementations)\n\n## Acceptance Criteria\nGiven ModelId.parse(\"anthropic/claude-opus-4-6\") when parsed then provider=\"anthropic\" model=\"claude-opus-4-6\" should never accept strings without \"/\"","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:32:44Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:32:44Z","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-0rd","depends_on_id":"aura-plugins-exe","type":"blocks","created_at":"2026-02-21T17:32:45Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-125","title":"SLICE-2-L1: Types — EpochState, TransitionRecord, TransitionError","description":"---\nreferences:\n  slice: aura-plugins-la6\n  impl_plan: aura-plugins-06g\n---\n## Scope\nDefine the type structure for state_machine.py: EpochState (mutable state), TransitionRecord (frozen audit entry), TransitionError (exception), EpochStateMachine class skeleton with method signatures.\n\n## Files Owned\n- scripts/aura_protocol/state_machine.py (class structure + type definitions only)\n\n## Acceptance Criteria\nGiven state_machine.py when imported then EpochState, TransitionRecord, TransitionError, EpochStateMachine are importable should never have implementations yet (stubs/raise NotImplementedError)","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:32:38Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:32:38Z","labels":["aura:p9-impl:s9-slice"]}
{"id":"aura-plugins-1bm","title":"PROPOSAL-2: bin/aura-release — revised after review","description":"---\nreferences:\n  request: aura-plugins-j2k\n  urd: aura-plugins-99q\n  proposal_1: aura-plugins-wux\n  review_1: aura-plugins-1ey\n---\n\n# PROPOSAL-2: bin/aura-release (revised)\n\nAll BLOCKER and IMPORTANT findings from PROPOSAL-1-REVIEW addressed.\n\n## Changes from PROPOSAL-1\n\n### BLOCKER fixes\n1. **Plugin selection by name**: marketplace.json plugins selected by name==\"aura\" predicate, not array index\n2. **Section-anchored TOML parsing**: Regex anchored to [project] section. Match version= only between [project] header and next [...] header. Alternatively use tomllib (3.11+) for reading with regex replacement for writing (avoids reordering keys)\n3. **--check mode fully defined**:\n   - Standalone: `aura-release --check` (no bump argument required)\n   - Exit 0: all versions consistent\n   - Exit 1: drift detected (prints table of file → version)\n   - --check --sync is invalid (mutual exclusion enforced)\n\n### IMPORTANT fixes\n4. **Pre-defined rollback list**: Before any writes, capture the 3 target files + CHANGELOG.md path in a rollback set. On any failure, git checkout all of them unconditionally\n5. **No prior tag fallback**: If no vX.Y.Z tag exists, changelog includes all commits since initial commit (git rev-list --max-parents=0 HEAD)\n6. **Source of truth explicit**: --sync reads pyproject.toml as canonical version, overwrites plugin.json and marketplace.json to match\n7. **Explicit git add whitelist**: Commit stages exactly: pyproject.toml, .claude-plugin/plugin.json, .claude-plugin/marketplace.json, CHANGELOG.md. Never uses git commit -a or git add .\n\n### MINOR acknowledgments\n8. **Double-bump warning**: If current version != last tag version AND no --sync, warn user and require --force or abort\n9. **UTF-8 encoding**: subprocess.run with encoding=\"utf-8\" for all git log calls\n\n## Architecture\n\n### File: bin/aura-release\n\nSingle Python 3.10+ script, stdlib only.\n\n### Version parsing strategy\n\n```python\n# Read: section-anchored regex\ndef read_pyproject_version(path: Path) -\u003e str:\n    text = path.read_text(encoding=\"utf-8\")\n    # Match version= only within [project] section\n    m = re.search(\n        r\"^\\[project\\]\\s*\\n(?:(?!\\[).*\\n)*?version\\s*=\\s*\\\"(\\d+\\.\\d+\\.\\d+)\\\"\",\n        text, re.MULTILINE\n    )\n    ...\n\n# Write: targeted line replacement within [project] section\ndef write_pyproject_version(path: Path, old: str, new: str) -\u003e None:\n    text = path.read_text(encoding=\"utf-8\")\n    # Replace only the first occurrence after [project]\n    text = text.replace(f'version = \"{old}\"', f'version = \"{new}\"', 1)\n    path.write_text(text, encoding=\"utf-8\")\n```\n\n### marketplace.json plugin selection\n\n```python\ndef update_marketplace(path: Path, new_version: str) -\u003e None:\n    data = json.loads(path.read_text(encoding=\"utf-8\"))\n    data[\"metadata\"][\"version\"] = new_version\n    for plugin in data[\"plugins\"]:\n        if plugin[\"name\"] == \"aura\":\n            plugin[\"version\"] = new_version\n            break\n    path.write_text(json.dumps(data, indent=2) + \"\\n\", encoding=\"utf-8\")\n```\n\n### CLI interface\n\n```\n# Bump version\naura-release \u003cmajor|minor|patch\u003e [--dry-run] [--sync] [--no-changelog] [--no-commit] [--no-tag]\n\n# Check consistency only\naura-release --check\n```\n\nExit codes:\n- 0: success (or --check with consistent versions)\n- 1: --check found drift (prints version table)\n- 2: pre-flight failure (dirty tree, detached HEAD, etc.)\n\n### Workflow\n\n1. Parse args\n2. If --check: read all 3 files, compare versions, exit 0/1\n3. Pre-flight checks:\n   a. Not detached HEAD\n   b. Working tree clean (git status --porcelain, ignore .beads/)\n   c. Read versions from all 3 files\n   d. If versions differ AND --sync not given: exit 2 with error\n   e. If --sync: overwrite plugin.json + marketplace.json to match pyproject.toml\n4. Compute new version from current + bump type\n5. Define rollback set: [pyproject.toml, plugin.json, marketplace.json, CHANGELOG.md]\n6. try:\n   a. Update pyproject.toml (section-anchored replace)\n   b. Update plugin.json (json.load/dump)\n   c. Update marketplace.json (select by name==\"aura\")\n   d. Generate CHANGELOG entry (git log since last vX.Y.Z tag, or since root)\n   e. Prepend to CHANGELOG.md (create if missing)\n   f. If not --no-commit: git add \u003cwhitelist\u003e \u0026\u0026 git commit -m \"chore: release vX.Y.Z\"\n   g. If not --no-tag: git tag -a vX.Y.Z -m \"Release vX.Y.Z\"\n7. except: rollback all files in rollback set via git checkout\n8. Print summary\n\n### CHANGELOG format (Keep a Changelog)\n\n```markdown\n# Changelog\n\n## [0.3.0] - 2026-02-21\n\n### Added\n- feat: some new feature (#commit-short)\n\n### Fixed\n- fix: some bug fix (#commit-short)\n\n### Changed\n- refactor: some refactoring (#commit-short)\n\n### Other\n- chore: some chore (#commit-short)\n```\n\nCommit prefix → section mapping:\n- feat → Added\n- fix → Fixed\n- refactor, perf → Changed\n- docs → Documentation\n- everything else → Other\n\n## Nix integration\n- flake.nix packages auto-wrap bin/* → aura-release included automatically\n- No flake.nix changes needed\n\n## Files\n- bin/aura-release (NEW)\n- CHANGELOG.md (created on first release)","status":"open","priority":2,"issue_type":"feature","assignee":"architect","owner":"dayvidpham@gmail.com","created_at":"2026-02-21T20:14:01Z","created_by":"David Huu Pham","updated_at":"2026-02-21T20:14:01Z","labels":["aura:p3-plan:s3-propose"],"dependencies":[{"issue_id":"aura-plugins-1bm","depends_on_id":"aura-plugins-5sn","type":"blocks","created_at":"2026-02-21T12:19:14Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-1cy","title":"SLICE-4-L1: Types — Protocol interfaces + A2A types + ModelId","description":"---\nreferences:\n  slice: aura-plugins-8i5\n  impl_plan: aura-plugins-06g\n---\n## Scope\nDefine typing.Protocol interfaces (ConstraintValidatorInterface, TranscriptRecorder, SecurityGate, AuditTrail), A2A content types (TextPart, FilePart, DataPart, Part union), ToolCall, ModelId, and event stub types.\n\n## Files Owned\n- scripts/aura_protocol/interfaces.py (type defs)\n\n## Acceptance Criteria\nGiven interfaces.py when imported then all Protocols are runtime_checkable should never require ABC inheritance","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:32:43Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:32:43Z","labels":["aura:p9-impl:s9-slice"]}
{"id":"aura-plugins-1ey","title":"PROPOSAL-1-REVIEW: Design review findings","description":"---\nreferences:\n  proposal: aura-plugins-wux\n---\n\n## Review Verdict: REVISE (3 BLOCKERs)\n\n### BLOCKERs\n1. marketplace.json plugins must be selected by name==\"aura\", not array index\n2. TOML regex must be section-anchored to [project] block, or use tomllib (3.11+) with fallback\n3. --check mode is undefined (exit codes, interaction with --sync)\n\n### IMPORTANTs\n1. Rollback list must be pre-defined covering all 3 files regardless of write order\n2. \"No prior tag\" fallback for changelog is unspecified\n3. --sync source-of-truth (pyproject.toml) must be explicitly stated\n4. Dirty-tree exception: commit must use explicit git add (whitelist), not git commit -a\n\n### MINORs\n1. --no-commit --no-tag double-bump footgun\n2. Non-ASCII git log needs explicit UTF-8 handling","status":"open","priority":2,"issue_type":"task","assignee":"architect","owner":"dayvidpham@gmail.com","created_at":"2026-02-21T20:13:25Z","created_by":"David Huu Pham","updated_at":"2026-02-21T20:13:25Z","labels":["aura:p4-plan:s4-review"],"dependencies":[{"issue_id":"aura-plugins-1ey","depends_on_id":"aura-plugins-1bm","type":"blocks","created_at":"2026-02-21T12:14:05Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-220","title":"REQUEST: Multi-agent orchestration schema-as-runtime with generation pipeline and constraint enforcement","description":"Finding this workflow management untenable. How does LangGraph or LangChain handle these? We need strict schema specification with various constraints upheld, with roles, with shared pieces of context, and also floating pieces of context.\n\nAlso: is the aura:epoch command telling which skills directly to run? We have the skills/protocol/schema.xml that needs to be updated with these rules. Finding this workflow management untenable.\n\n---\n\nContext: The aura protocol has an N-file synchronization problem. schema.xml defines the protocol in BCNF, but the same rules must be restated across SKILL.md files, PROCESS.md, CLAUDE.md, and CONSTRAINTS.md. Every change requires touching 5-7 files manually, and drift is inevitable. We already have some testing and validation occurring via Python. Need to investigate: (1) how frameworks like LangGraph, OpenAI Agents SDK, Microsoft Agent Framework, AgentSpec handle strict schema specification with constraints, roles, shared/floating context; (2) a generation pipeline from schema.xml to downstream files; (3) runtime constraint enforcement.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-21T20:58:36Z","created_by":"David Huu Pham","updated_at":"2026-02-21T20:58:36Z","labels":["aura:p1-user:s1_1-classify"]}
{"id":"aura-plugins-2au","title":"SLICE-5-L3: Impl — EpochWorkflow + activities","description":"---\nreferences:\n  slice: aura-plugins-lkz\n  impl_plan: aura-plugins-06g\n---\n## Scope\nImplement EpochWorkflow (run, advance_phase, submit_vote, current_state, available_transitions) and activities (check_constraints, record_transition). Makes L2 tests pass.\n\n## Files Owned\n- scripts/aura_protocol/workflow.py (fill in implementations)\n\n## Acceptance Criteria\nGiven EpochWorkflow when advance_phase signal received then state transitions + search attrs updated atomically should never have non-deterministic operations","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:32:47Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:32:47Z","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-2au","depends_on_id":"aura-plugins-amx","type":"blocks","created_at":"2026-02-21T17:32:47Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-35d","title":"SLICE-1: types.py — Protocol type definitions","description":"---\nreferences:\n  impl_plan: aura-plugins-06g\n  urd: aura-plugins-umi\n  proposal: aura-plugins-gmv\n---\n## Specification\nDefine all typed enums and frozen dataclass specs for the aura protocol. This is the foundation module imported by all others.\n\n### Key Types\n- PhaseId (13 values: p1-p12 + complete)\n- Domain (user, plan, impl)\n- RoleId (epoch, architect, reviewer, supervisor, worker)\n- VoteType (ACCEPT, REVISE)\n- SeverityLevel (BLOCKER, IMPORTANT, MINOR)\n- PhaseSpec, Transition, ConstraintSpec, HandoffSpec (frozen dataclasses)\n- PHASE_SPECS, CONSTRAINT_SPECS, HANDOFF_SPECS (canonical lookup dicts)\n- PHASE_DOMAIN mapping\n\n### Also\n- Create scripts/aura_protocol/__init__.py with public API re-exports\n- Event stub types: PhaseTransitionEvent, ConstraintCheckEvent, ReviewVoteEvent, AuditEvent, ToolPermissionRequest, PermissionDecision\n\n## Files Owned\n- scripts/aura_protocol/__init__.py (NEW)\n- scripts/aura_protocol/types.py (NEW)\n- tests/test_aura_types.py (NEW)\n- tests/test_schema_types_sync.py (NEW)\n\n## Acceptance Criteria\n- AC8: Given Python type definitions when compared against schema.xml then every PhaseId, Domain, RoleId matches schema.xml should never drift\n- All enums are str Enums for JSON/Temporal serialization\n- All spec dataclasses are frozen (immutable)\n- PHASE_DOMAIN mapping matches schema.xml _EXPECTED_DOMAINS\n\n## Validation Checklist\n- [ ] Types defined (enums + frozen dataclasses)\n- [ ] Tests written (test_aura_types.py + test_schema_types_sync.py)\n- [ ] __init__.py with re-exports\n- [ ] All 13 PhaseId values present\n- [ ] PHASE_SPECS covers all 12 phases\n- [ ] Integration test verifies Python types match schema.xml","design":"{\"validation_checklist\":[\"PhaseId matches schema.xml\",\"Domain matches DomainType enum\",\"RoleId matches schema.xml\",\"PHASE_DOMAIN mapping correct\",\"All specs are frozen\",\"str Enums for serialization\"],\"acceptance_criteria\":[{\"given\":\"Python types.py\",\"when\":\"compared to schema.xml\",\"then\":\"all enums match\",\"should_not\":\"drift from schema.xml\"}],\"ratified_plan\":\"aura-plugins-gmv\"}","status":"closed","priority":2,"issue_type":"task","assignee":"worker-1","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:31:28Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:42:09Z","closed_at":"2026-02-22T01:42:09Z","close_reason":"Closed","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-35d","depends_on_id":"aura-plugins-9nc","type":"blocks","created_at":"2026-02-21T17:32:36Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-35d","depends_on_id":"aura-plugins-g2a","type":"blocks","created_at":"2026-02-21T17:32:37Z","created_by":"David Huu Pham","metadata":"{}"}],"comments":[{"id":10,"issue_id":"aura-plugins-35d","author":"David Huu Pham","text":"SLICE-1 complete. All 65 tests pass (49 unit tests in test_aura_types.py + 16 integration tests in test_schema_types_sync.py). Existing validate_schema tests pass with no regressions (95 passing). Files created: scripts/aura_protocol/__init__.py, scripts/aura_protocol/types.py, tests/test_aura_types.py, tests/test_schema_types_sync.py.","created_at":"2026-02-22T01:42:07Z"}]}
{"id":"aura-plugins-4mu","title":"SLICE-2-L2: Tests — test_state_machine.py (AC1-AC4)","description":"---\nreferences:\n  slice: aura-plugins-la6\n  impl_plan: aura-plugins-06g\n---\n## Scope\nWrite test_state_machine.py covering AC1 (transitions), AC2 (consensus gate), AC3 (revision loop), AC4 (BLOCKER gate). Tests import from state_machine.py and WILL FAIL until L3 implementation.\n\n## Files Owned\n- tests/test_state_machine.py\n\n## Acceptance Criteria\nGiven test_state_machine.py when run before L3 then tests fail (expected) should never pass without real implementation","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:32:38Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:32:38Z","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-4mu","depends_on_id":"aura-plugins-125","type":"blocks","created_at":"2026-02-21T17:32:39Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-5sn","title":"UAT-1: Plan acceptance for release automation PROPOSAL-2","description":"---\nreferences:\n  proposal: aura-plugins-1bm\n---\n\n## UAT Result: ACCEPT\n\nUser accepted PROPOSAL-2 design for bin/aura-release.\nNo revision feedback provided.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-21T20:19:14Z","created_by":"David Huu Pham","updated_at":"2026-02-21T20:19:14Z","labels":["aura:p5-user:s5-uat"],"dependencies":[{"issue_id":"aura-plugins-5sn","depends_on_id":"aura-plugins-bch","type":"blocks","created_at":"2026-02-21T12:19:27Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-6yr","title":"SLICE-2: Fix CLI UX error messages in bin/aura-release","description":"---\nreferences:\n  uat: aura-plugins-nfr\n  impl_plan: aura-plugins-bch\n---\n\n## Specification\n\nFix 4 UX issues identified during UAT-2 in bin/aura-release error messages.\n\n## Files Owned\n- bin/aura-release (lines ~430-465: CLI/main, lines ~305-341: cmd_release pre-flight, lines ~286-302: cmd_check)\n\n## Issues to Fix\n\n### Issue 1: No-args error message needs actionable examples\n**Current (line 459):**\n  bump type required (major, minor, or patch). Use --check for consistency validation.\n**Required:** Show example commands:\n  aura-release patch           # bump patch version\n  aura-release minor           # bump minor version\n  aura-release --check         # check version consistency\n  aura-release patch --dry-run # preview changes\n\n### Issue 2: Drift error needs to suggest exact fix command\n**Current (lines 337-340):**\n  Error: version drift detected:\n    pyproject.toml: 0.2.2\n    ...\n  Use --sync to align before bumping.\n**Required:** Show the exact command the user should run, e.g.:\n  Try: aura-release \u003cbump\u003e --sync\n  (where \u003cbump\u003e is the bump_kind the user already passed)\n\n### Issue 3: --sync should explain what needs to be clean\n**Current (lines 321-324):**\n  Error: working tree has uncommitted changes (outside .beads/).\n  Commit or stash them first.\n**Required:** Briefly explain WHAT needs to be clean: tracked files outside .beads/ must have no uncommitted changes. The .beads/ directory is always excluded from the clean-tree check.\n\n### Issue 4: Overall — all error paths should guide user to next action\nEvery error exit should end with a concrete \"Try: ...\" or \"Next: ...\" suggestion.\n\n## Acceptance Criteria\nGiven a user runs aura-release with no args, when they see the error, then the message shows example commands they can copy-paste.\nGiven a user runs aura-release patch and versions are drifted, when they see the drift error, then the message shows the exact command with --sync to fix it.\nGiven a user runs aura-release and the working tree is dirty, when they see the error, then the message explains what files need to be clean.","status":"open","priority":2,"issue_type":"task","assignee":"worker-1","owner":"dayvidpham@gmail.com","created_at":"2026-02-21T20:31:06Z","created_by":"David Huu Pham","updated_at":"2026-02-21T20:31:06Z","labels":["aura:p9-impl:s9-slice"],"comments":[{"id":1,"issue_id":"aura-plugins-6yr","author":"David Huu Pham","text":"SLICE-2 complete. All 4 UX error message fixes verified: (1) no-args shows usage examples, (2) drift error shows exact command with --sync, (3) dirty tree explains what needs to be clean, (4) detached HEAD shows git checkout suggestion.","created_at":"2026-02-21T20:32:40Z"}]}
{"id":"aura-plugins-7gm","title":"PROPOSAL-1-REVIEW-A-1: aura protocol engine v1","description":"VOTE: ACCEPT - The proposal faithfully serves the user's original request across all 8 URD requirements. R1 (machine-executable protocol) is the core deliverable and is thoroughly addressed with 5 well-scoped modules. R2-R3 are correctly deferred to v2/v3 per the user's explicit 3-version roadmap. R4-R8 are addressed proportionally to v1 scope.\n\n## Correctness Findings\n\n### Transition Table Design\nThe 12-phase transition table is derived directly from schema.xml transitions. Forward transitions, revision loops (p4-\u003ep3, p10-\u003ep9, p5-\u003ep3, p11-\u003ep9), and the terminal p12-\u003ecomplete are all accounted for. The PhaseId.COMPLETE sentinel correctly represents the terminal state without a corresponding PhaseSpec. The integration test (test_schema_types_sync.py) is a strong safeguard against type drift.\n\n### Temporal Integration\nSignals for mutations (advance_phase, submit_vote), queries for reads (current_state, available_transitions), search attributes for forensics (5 typed keys), and activities for I/O (check_constraints, record_transition) — all follow correct Temporal patterns. Determinism is preserved by keeping workflow code side-effect-free with all I/O in activities.\n\n### Engineering Tradeoffs\nAll 8 tradeoffs are well-justified and internally consistent: hand-rolled SM for fixed topology, one workflow per epoch for v1 simplicity, dataclasses for Temporal SDK compatibility, typing.Protocol for structural subtyping across repo boundaries, scripts/ package location matching existing pythonpath.\n\n### Review Consensus and BLOCKER Gates\nAC2 (consensus requires 3 ACCEPT votes) and AC4 (BLOCKER count \u003e 0 blocks p10-\u003ep11) correctly model the schema.xml constraints C-review-consensus and the p10 transition condition \"all 3 reviewers ACCEPT, all BLOCKERs resolved.\"\n\n### Minor Observations (Non-Blocking)\n1. A2A TaskState enum is mentioned in the URD (R5) and tradeoff table but not included in the module definitions. PhaseId covers lifecycle states, so this is not a functional gap, but should be tracked for A2A compliance completeness.\n2. EpochState uses set[PhaseId] and dict[str, VoteType] which will need Temporal serialization handling — this is an implementation detail, not a design flaw, and will be caught by test_workflow.py integration tests.\n3. The proposal could explicitly state how the follow-up lifecycle (schema.xml followup-lifecycle section) maps to the state machine — whether FOLLOWUP_* phases reuse the same EpochStateMachine or create a new instance. This does not block v1 since follow-up is triggered after code review, but clarifying the design intent would help implementers.\n\n### Verdict\nAll 6 end-user alignment criteria satisfied. No BLOCKER issues. The proposal is technically consistent with its stated rationale, faithfully addresses the URD requirements within v1 scope, and the public interfaces are sufficient for the MVP goals.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:00:16Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:00:16Z","labels":["aura:p4-plan:s4-review"]}
{"id":"aura-plugins-8i5","title":"SLICE-4: interfaces.py — Cross-project integration + A2A types","description":"---\nreferences:\n  impl_plan: aura-plugins-06g\n  urd: aura-plugins-umi\n  proposal: aura-plugins-gmv\n---\n## Specification\nPython Protocol interfaces for cross-project integration + A2A-compatible content types. Uses structural subtyping (typing.Protocol, runtime_checkable).\n\n### Protocol Interfaces\n- ConstraintValidatorInterface — validate(state) -\u003e list[ConstraintViolation]\n- TranscriptRecorder — record phase transitions, constraint checks, review votes\n- SecurityGate — check tool permissions\n- AuditTrail — record and query audit events\n\n### A2A Content Types (minimal v1 subset)\n- TextPart, FilePart, DataPart (frozen dataclasses)\n- Part = TextPart | FilePart | DataPart (union type)\n- ToolCall (MCP-compatible tool call representation)\n- ModelId (models.dev {provider}/{model} composite identifier)\n\n### Event Stub Types (frozen dataclasses)\n- PhaseTransitionEvent, ConstraintCheckEvent, ReviewVoteEvent\n- AuditEvent, ToolPermissionRequest, PermissionDecision\n\n## Files Owned\n- scripts/aura_protocol/interfaces.py (NEW)\n- tests/test_interfaces.py (NEW)\n\n## Acceptance Criteria\n- AC9: Given class implementing Protocol when isinstance() checked then True should not require subclassing\n- AC10: Given ModelId.parse(\"anthropic/claude-opus-4-6\") when parsed then provider=\"anthropic\" model=\"claude-opus-4-6\" should not accept strings without \"/\"\n\n## Validation Checklist\n- [ ] All Protocol interfaces are runtime_checkable\n- [ ] A2A Part union covers 3 types\n- [ ] ModelId.parse() validates format\n- [ ] Event stub types defined\n- [ ] Tests cover AC9 + AC10","design":"{\"validation_checklist\":[\"Protocol interfaces runtime_checkable\",\"Part union complete\",\"ModelId validates format\",\"Event stubs defined\"],\"acceptance_criteria\":[{\"given\":\"Protocol implementor\",\"when\":\"isinstance checked\",\"then\":\"returns True\",\"should_not\":\"require subclassing\"},{\"given\":\"ModelId.parse(valid)\",\"when\":\"parsed\",\"then\":\"correct provider and model\",\"should_not\":\"accept invalid format\"}],\"ratified_plan\":\"aura-plugins-gmv\"}","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:31:29Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:31:29Z","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-8i5","depends_on_id":"aura-plugins-0rd","type":"blocks","created_at":"2026-02-21T17:32:44Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-8i5","depends_on_id":"aura-plugins-1cy","type":"blocks","created_at":"2026-02-21T17:32:43Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-8i5","depends_on_id":"aura-plugins-35d","type":"blocks","created_at":"2026-02-21T17:31:31Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-8i5","depends_on_id":"aura-plugins-exe","type":"blocks","created_at":"2026-02-21T17:32:43Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-99q","title":"URD: Release automation requirements document","description":"---\nreferences:\n  request: aura-plugins-j2k\n  elicit: aura-plugins-wqw\n---\n\n# URD: Automated Release Tagging and Version Bumping\n\n## 1. Purpose\nA CLI tool (bin/aura-release) that automates version bumping, CHANGELOG generation, git commit, and annotated tagging for the aura-plugins repository.\n\n## 2. Scope\n- Single Python 3.10+ script, stdlib only (zero external dependencies)\n- Follows existing bin/ tool conventions (argparse, same shebang pattern)\n- Operates on the local git repository only (no push)\n\n## 3. Functional Requirements\n\n### FR-1: Version Bump\n- Accept bump type: major | minor | patch\n- Parse current version from pyproject.toml (source of truth)\n- Compute new version per semver rules\n- Update version in exactly 3 files:\n  - pyproject.toml: project.version field\n  - .claude-plugin/plugin.json: top-level version field\n  - .claude-plugin/marketplace.json: metadata.version AND plugins[0].version\n- Must NOT modify plugins[1].version (agentfilter, external)\n\n### FR-2: Version Consistency Check\n- Before bumping, validate all 3 files have the same version\n- If versions are inconsistent, offer a --sync flag to align them to pyproject.toml's version before bumping\n- On first run with existing drift, --sync aligns marketplace.json to current 0.2.2\n\n### FR-3: CHANGELOG Generation\n- Auto-generate CHANGELOG.md entries from git log between tags\n- Use \"Keep a Changelog\" format (https://keepachangelog.com)\n- Group commits by type using conventional commit prefixes (feat, fix, chore, etc.)\n- If no prior tag exists, include all commits since initial commit\n\n### FR-4: Git Commit\n- Stage the 3 version files + CHANGELOG.md\n- Create commit with message: \"chore: release vX.Y.Z\"\n\n### FR-5: Git Tag\n- Create annotated tag: vX.Y.Z\n- Tag message: \"Release vX.Y.Z\"\n\n## 4. Non-Functional Requirements\n\n### NFR-1: Pre-flight Checks\n- Working tree must be clean (no uncommitted changes beyond .beads/)\n- Must be on a branch (not detached HEAD)\n- Current version must parse as valid semver\n\n### NFR-2: Dry Run\n- Support --dry-run flag showing what would happen without making changes\n\n### NFR-3: Error Handling\n- Atomic: if any step fails, roll back file changes (git checkout the files)\n- Clear error messages for each failure mode\n\n### NFR-4: Idempotency\n- Running with --sync when versions already match is a no-op\n\n## 5. CLI Interface\n\n```\naura-release \u003cmajor|minor|patch\u003e [--dry-run] [--sync] [--no-changelog] [--no-commit] [--no-tag]\naura-release --check  # just validate version consistency\n```\n\n## 6. Files Affected\n- bin/aura-release (NEW — the tool itself)\n- pyproject.toml (version field)\n- .claude-plugin/plugin.json (version field)\n- .claude-plugin/marketplace.json (2 version fields)\n- CHANGELOG.md (created/appended)","status":"open","priority":2,"issue_type":"task","assignee":"architect","owner":"dayvidpham@gmail.com","created_at":"2026-02-21T20:10:46Z","created_by":"David Huu Pham","updated_at":"2026-02-21T20:10:46Z","labels":["aura:p2-user:s2_2-urd"],"dependencies":[{"issue_id":"aura-plugins-99q","depends_on_id":"aura-plugins-wux","type":"blocks","created_at":"2026-02-21T12:11:27Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-9ii","title":"SLICE-3-L3: Impl — RuntimeConstraintChecker logic","description":"---\nreferences:\n  slice: aura-plugins-mrm\n  impl_plan: aura-plugins-06g\n---\n## Scope\nImplement all constraint check methods in RuntimeConstraintChecker. Makes L2 tests pass.\n\n## Files Owned\n- scripts/aura_protocol/constraints.py (fill in implementations)\n\n## Acceptance Criteria\nGiven RuntimeConstraintChecker when checking violated state then returns ConstraintViolation list should never silently pass violations","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:32:42Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:32:42Z","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-9ii","depends_on_id":"aura-plugins-w28","type":"blocks","created_at":"2026-02-21T17:32:42Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-9nc","title":"SLICE-1-IMPL: types.py + __init__.py — enums, specs, lookup dicts","description":"---\nreferences:\n  slice: aura-plugins-35d\n  impl_plan: aura-plugins-06g\n---\n## Scope\nCreate scripts/aura_protocol/types.py and __init__.py. Define all enums (PhaseId, Domain, RoleId, VoteType, SeverityLevel), frozen dataclasses (Transition, PhaseSpec, ConstraintSpec, HandoffSpec), canonical lookup dicts (PHASE_SPECS, CONSTRAINT_SPECS, HANDOFF_SPECS, PHASE_DOMAIN), and event stub types.\n\n## Files Owned\n- scripts/aura_protocol/__init__.py\n- scripts/aura_protocol/types.py\n\n## Acceptance Criteria\nGiven types.py when imported then all enums are str Enums, all specs are frozen should never have mutable spec dataclasses","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:32:36Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:42:00Z","closed_at":"2026-02-22T01:42:00Z","close_reason":"Closed","labels":["aura:p9-impl:s9-slice"]}
{"id":"aura-plugins-amx","title":"SLICE-5-L2: Tests — test_workflow.py (AC6, AC7, Temporal sandbox)","description":"---\nreferences:\n  slice: aura-plugins-lkz\n  impl_plan: aura-plugins-06g\n---\n## Scope\nWrite test_workflow.py with Temporal sandbox tests covering AC6 (durability) and AC7 (search attributes). Tests use Temporal test environment.\n\n## Files Owned\n- tests/test_workflow.py\n\n## Acceptance Criteria\nGiven test_workflow.py when run in Temporal sandbox then workflow advances via signals, search attrs updated should never mock the workflow itself","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:32:46Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:32:46Z","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-amx","depends_on_id":"aura-plugins-r1n","type":"blocks","created_at":"2026-02-21T17:32:46Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-b5m","title":"HANDOFF: Architect → Supervisor for REQUEST aura-plugins-bj1","description":"---\nreferences:\n  request: aura-plugins-bj1\n  urd: aura-plugins-umi\n  proposal: aura-plugins-gmv\n---\nHandoff from architect to supervisor. See handoff document at\n.git/.aura/handoff/aura-plugins-bj1/architect-to-supervisor.md","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:17:50Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:17:50Z","labels":["aura:p7-plan:s7-handoff"]}
{"id":"aura-plugins-bch","title":"IMPL_PLAN: bin/aura-release implementation","description":"---\nreferences:\n  proposal: aura-plugins-1bm\n---\n\nSingle slice: implement bin/aura-release per PROPOSAL-2.\nOne file to create, no files to modify (version files modified by the tool at runtime, not at build time).","status":"open","priority":2,"issue_type":"epic","owner":"dayvidpham@gmail.com","created_at":"2026-02-21T20:19:22Z","created_by":"David Huu Pham","updated_at":"2026-02-21T20:19:22Z","labels":["aura:p8-impl:s8-plan"],"dependencies":[{"issue_id":"aura-plugins-bch","depends_on_id":"aura-plugins-6yr","type":"blocks","created_at":"2026-02-21T12:31:09Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-bch","depends_on_id":"aura-plugins-e19","type":"blocks","created_at":"2026-02-21T12:19:31Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-bj1","title":"REQUEST: SessionEntry database design — A2A/MCP-compliant variant-rich transcript schema","description":"---\nreferences:\n  related_epoch: aura-plugins-220\n  variant_rich_paper: /home/minttea/dev/agent-data-leverage/unified-schema/llm/research/variant-rich-paper.pdf\n  agentfilter_project: /home/minttea/codebases/dayvidpham/agentfilter/\n---\n\n## Verbatim User Request\n\n### SessionEntry, session_entries\n\nThe next thing is: the database design and code interface design that can encapsulate all the various steps, constraints, and roles of our PROCESS is going to be tricky. These will inherently be dealing with many variant roles and phases, each with their own schema for their transcripts, entries, tool calls, etc. This problem has a few steps.\n\n1. Part of this is a literature research task: I put a reference paper that deals with how to deal with variant-rich software environments in @llm/research/variant-rich-paper. Find its references and related works, and determine what architectures or solutions the software engineering research community has developed to deal with this problem. We are in a variant-rich software environment because our ingestion pipeline must account for (MANY model harnesses which may have MANY configurations, plugins and also interface with MANY models).\n\n2. There is another research task: we need a standardized, stable, uniform interface that we can use to adapt the transcript entries into. This is essentially the purpose of the Agent Context Protocol (ACP), which has been officially merged into the Agent2Agent Protocol (A2A). These have also been officially donated to the Linux Foundation. These protocols integrate and extend the Model Context Protocol (MCP).\n   * ACP: (https://agentcommunicationprotocol.dev/introduction/welcome) and its official OpenAPI spec (https://raw.githubusercontent.com/i-am-bee/acp/refs/heads/main/docs/spec/openapi.yaml)\n   * A2A: official v1.0 spec (https://a2a-protocol.org/latest/definitions/) ; official A2A Go SDK (https://github.com/a2aproject/a2a-go) ; \n   * MCP: official spec at (https://modelcontextprotocol.io/specification/2025-11-25) and specified as TypeScript (https://raw.githubusercontent.com/modelcontextprotocol/modelcontextprotocol/refs/heads/main/schema/2025-11-25/schema.ts)\nWe should define a database schema and design that is compliant with the A2A and MCP schema. When researching, use these links provided as the official, single source of truth. I have an example of an ACP-compliant Claude Code transcript parser and filtering project at @~/codebases/dayvidpham/agentfilter/ .\n\n### Model Name ID Refactor\n\nLet's also use the database of models at https://github.com/anomalyco/models.dev, since we need a stable model name identifier.\n\n## Classification (4 Axes)\n\n### Scope: LARGE\n- Database schema design for variant-rich transcript storage\n- Protocol compliance with 3 specs (A2A v1.0, ACP, MCP 2025-11-25)\n- Literature survey on variant-rich SPL architectures\n- Model name ID standardization via models.dev\n- Integration with existing agentfilter project patterns\n\n### Complexity: HIGH\n- Multiple protocol specs to reconcile (A2A extends ACP extends MCP)\n- Variant-rich environment: MANY model harnesses × MANY configs × MANY models\n- Must handle variant transcripts per role/phase/tool with different schemas\n- Relevant SPL techniques: Feature Model Synthesis, Constraints Extraction, Variant Integration\n\n### Risk: MEDIUM\n- Research and design phase — not touching production yet\n- Risk of over-engineering the schema if we don't bound scope\n- Risk of protocol spec drift (A2A recently donated to Linux Foundation)\n\n### Domain Novelty: HIGH\n- A2A v1.0 spec released 2025 — cutting edge\n- SPL variant-rich evolution is active research area (Strüber et al. SPLC'19, 35 citations)\n- No existing unified transcript schema standard for multi-harness agent systems","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-21T23:50:40Z","created_by":"David Huu Pham","updated_at":"2026-02-21T23:50:40Z","labels":["aura:p1-user:s1_1-classify","aura:p1-user:s1_2-research","aura:p1-user:s1_3-explore"],"dependencies":[{"issue_id":"aura-plugins-bj1","depends_on_id":"aura-plugins-gbr","type":"blocks","created_at":"2026-02-21T16:38:37Z","created_by":"David Huu Pham","metadata":"{}"}],"comments":[{"id":2,"issue_id":"aura-plugins-bj1","author":"David Huu Pham","text":"## Phase 1 Research Synthesis (s1_2-research)\n\n### Stream A: Variant-Rich SPL Literature (Strüber et al. SPLC'19)\n\n**Top architectural patterns for our problem:**\n\n1. **Delta-Oriented Schema Composition** (Schaefer 2010, Schulze \u0026 Leymann 2014) — core schema + per-harness delta modules composed at build time. Directly applicable: `core.xml` + `delta-claude-code.xml` + `delta-opencode.xml`.\n\n2. **Annotative 150% Model with Feature Guards** (Kaestner et al. 2009) — single schema containing ALL elements with boolean feature guards. Current schema.xml already implicit 150% model; making guards explicit is the next step.\n\n3. **FAMILIAR Feature Model Merge/Synthesis** (Acher et al. 2013) — reverse-engineer unified feature model from N harness-specific schemas. The `merge`, `slice`, `aggregate` operators encode each variant as propositional formula.\n\n4. **VariantSync Session-Oriented Editing** (Bittner et al. ESEC/FSE 2022) — when modifying schema for one harness, system computes which other variants share those features and propagates automatically. 94.5% of edits fall into 2 classes (AddToPC, RemFromPC).\n\n5. **Data Migration Product Lines** (Romero-Organvidez et al. VaMoS 2024) — SPL techniques applied to ETL pipelines. Feature model of transformations composed per harness config. Closest analogue to our problem.\n\n**Recommended: Hybrid compositional-annotative architecture (3 layers)**\n- Layer 1: Core schema (mandatory features, all harnesses)\n- Layer 2: Delta modules (harness-specific additions)\n- Layer 3: Feature guards (cross-cutting concerns, SAT-verified)\n\n**Key tool: python-sat or z3-solver** for constraint validation of Given/When/Then rules.\n\n### Stream B: A2A/ACP/MCP Protocol Specs\n\n**Protocol composition (layered stack):**\n- Layer 1: MCP = agent-to-tool (intra-agent tool calls, resources, prompts)\n- Layer 2: ACP = bridge (sessions, trajectory observability, MIME-typed parts) — NOW MERGED INTO A2A\n- Layer 3: A2A = agent-to-agent (discovery, task delegation, streaming)\n\n**Adopt directly from A2A:**\n- `Part` discriminated union (TextPart/FilePart/DataPart with `kind` discriminator)\n- `TaskState` enum (superset of all 3 protocols)\n- `ContextID` pattern for session grouping (simpler than ACP Session)\n- `Metadata map[string]any` extensibility on every type\n\n**Adopt directly from MCP:**\n- `ToolUseContent` / `ToolResultContent` for tool call representation\n- `Tool.annotations` (readOnlyHint, destructiveHint, idempotentHint)\n\n**Extend:**\n- Add `tool_use`/`tool_result` Part kinds (MCP's model, not in A2A)\n- Add `reasoning` field (from ACP TrajectoryMetadata.message)\n- Add `source` field (harness, model, protocol) — none of the 3 have this\n- Extend MessageRole to \"user\"|\"assistant\"|\"tool\"|\"system\"\n\n**Ignore:** AgentCard discovery, push notifications, ACP Session model, MCP Resource/Prompt registration, MCP Elicitation\n\n### Stream C: Existing Codebase Patterns\n\n**agentfilter reusable patterns:**\n- Three-way decision model (allow/deny/pass) → transcript classification\n- Specificity-based precedence resolution (8-level IntEnum)\n- Universal tool call envelope: `(session_id, tool_call_id, tool_name, tool_input)`\n- Operation classification: READ/WRITE/UNKNOWN frozensets\n- Dual-track parsing: heuristic fast-path + AST slow-path\n\n**models.dev integration:**\n- Composite identifier: `{provider_id}/{model_id}` (e.g., `anthropic/claude-opus-4-6`)\n- ModelFamily enum (~150 values): `claude-opus`, `gpt`, `gemini-flash`, etc.\n- Zod-validated schema with capabilities, cost, limits\n- API at `https://models.dev/api.json` — cache locally for offline resolution\n- Store: model_provider, model_id, model_family, model_name + capability snapshot","created_at":"2026-02-21T23:57:04Z"},{"id":3,"issue_id":"aura-plugins-bj1","author":"David Huu Pham","text":"## Proposed Canonical TranscriptEntry Schema (from research)\n\n```\nTranscriptEntry {\n  id:           UUID\n  timestamp:    ISO 8601\n  session_id:   UUID          // A2A ContextID\n  task_id:      UUID?         // A2A TaskID / ACP RunId\n  role:         \"user\"|\"assistant\"|\"tool\"|\"system\"\n  content:      ContentPart[]\n  tool_use?: {\n    id:         string\n    name:       string        // MCP tool name\n    input:      object\n  }\n  tool_result?: {\n    tool_use_id: string\n    content:     ContentPart[]\n    is_error:    bool\n  }\n  reasoning?:   string        // ACP TrajectoryMetadata.message\n  references:   UUID[]        // A2A referenceTaskIds\n  metadata:     map[string, any]\n  source: {\n    harness:    string        // \"claude-code\", \"opencode\", etc.\n    model:      string?       // models.dev canonical ID\n    protocol:   \"mcp\"|\"a2a\"|\"raw\"\n  }\n}\n\nContentPart (discriminated union via \"type\"):\n  { type:\"text\", text, mime_type? }\n  { type:\"file\", data? (base64), uri?, mime_type, filename? }\n  { type:\"data\", data: object, mime_type? }\n  { type:\"resource_link\", uri, name?, mime_type? }\n```\n\nPhase 1 research complete. Ready for Phase 2 (URE/URD).","created_at":"2026-02-21T23:57:12Z"}]}
{"id":"aura-plugins-dwy","title":"PROPOSAL-1-REVIEW-B-1: aura protocol engine v1","description":"VOTE: ACCEPT - The test strategy is well-designed with strong integration test foundations, proper fixture reuse, and observable-outcome assertions. Minor observations below do not rise to BLOCKER level.\n\n## Axis B: Test Quality Assessment\n\n### 1. Test File Plan Sufficiency\n\nThe 6 test files are well-scoped and properly partitioned:\n\n- **test_aura_types.py** — Enum coverage and spec completeness. This is appropriate: verifying that all PhaseId, Domain, RoleId, VoteType, SeverityLevel values exist and are correctly typed is a foundation test, not a brittle unit test. It tests observable contract (enum membership), not internal state.\n\n- **test_state_machine.py** — Transition validation and review gates. This is the most important test file. The BDD acceptance criteria (AC1-AC4) map directly to observable outcomes: calling advance() either succeeds and records a TransitionRecord, or raises TransitionError with specific violation messages. The SUT (EpochStateMachine) is tested directly — no mocking of the state machine itself.\n\n- **test_constraints.py** — Runtime constraint checking. Tests assert that check_all() and check_transition() return ConstraintViolation lists with constraint_ids and messages. Observable output, not internal state.\n\n- **test_workflow.py** — Temporal workflow sandbox tests. Temporal provides a dedicated test environment (WorkflowEnvironment.start_local()) that runs a real Temporal server in-memory. The SUT is the actual EpochWorkflow — only the Temporal infrastructure is provided by the test harness. This is a proper integration test pattern.\n\n- **test_interfaces.py** — Protocol compliance verification via isinstance() checks on runtime_checkable Protocols. This verifies structural subtyping contracts — exactly what end-users of the interfaces need.\n\n- **test_schema_types_sync.py** — THE critical integration test. Verifies that Python type definitions match schema.xml. This is the gold standard: the SUT is the types.py module, the dependency is schema.xml (parsed fresh), and the assertion is completeness (every schema.xml entity has a corresponding Python type).\n\n**Verdict: SUFFICIENT.** The file plan covers all modules and the most important invariants.\n\n### 2. Integration Test Strategy\n\n**test_schema_types_sync.py** is the linchpin integration test:\n- It verifies Python types match schema.xml entities (PhaseId, Domain, RoleId, VoteType, SeverityLevel)\n- It verifies PHASE_DOMAIN mapping matches _EXPECTED_DOMAINS from validate_schema.py\n- It verifies the transition table covers all schema.xml \u003ctransitions\u003e\n- It ensures the two representations (XML and Python code) cannot drift apart\n\nThis directly extends the existing SchemaFixture mutation testing pattern established in validate_schema.py, which is good continuity. The proposal explicitly states this in the validation checklist (items 1-5 and 17).\n\nThe existing test infrastructure (SchemaFixture, SchemaMutation, parametrized mutation detection) demonstrates the codebase already follows integration-first testing. The proposal correctly extends this pattern.\n\n**Verdict: STRONG integration strategy.**\n\n### 3. BDD Acceptance Criteria Testability\n\nAll 10 acceptance criteria (AC1-AC10) follow Given/When/Then/Should Not format and are testable:\n\n- **AC1 (transitions):** Given/When/Then maps to: create state machine, call advance(), assert TransitionRecord returned, assert error on invalid skip.\n- **AC2 (consensus gate):** Given/When/Then maps to: record 2 of 3 votes, call advance(p5), assert TransitionError.\n- **AC3 (revision loop):** Given/When/Then maps to: record REVISE vote, check available_transitions, assert only p3.\n- **AC4 (BLOCKER gate):** Given/When/Then maps to: set blocker_count \u003e 0, call advance(p11), assert TransitionError.\n- **AC5 (constraint enforcement):** Given/When/Then maps to: create checker, pass violated state, assert ConstraintViolation list.\n- **AC6 (Temporal durability):** Given/When/Then maps to: start workflow in sandbox, send signal, assert state and search attributes updated.\n- **AC7 (forensic query):** Given/When/Then maps to: start workflow at p9, query by search attribute, assert workflow found.\n- **AC8 (schema-types sync):** Given/When/Then maps to: parse schema.xml, compare to Python types, assert complete coverage.\n- **AC9 (interface compliance):** Given/When/Then maps to: create conforming class, assert isinstance() returns True.\n- **AC10 (ModelId parsing):** Given/When/Then maps to: parse valid string, assert fields, assert ValueError on invalid.\n\n**Verdict: ALL criteria are testable and complete.** Each maps to a specific test with observable output (return values, exceptions, or isinstance results). None require inspecting private state.\n\n### 4. Temporal Workflow Testability\n\nThe proposal correctly identifies that Temporal provides a sandbox test environment. The Temporal Python SDK offers:\n- `WorkflowEnvironment.start_local()` for a local in-memory Temporal server\n- Signal/query APIs for driving the workflow from tests\n- Search attribute queries for verifying forensic capabilities\n\nThe key design decision here is sound: the workflow wraps EpochStateMachine (tested separately in test_state_machine.py) and exposes signals/queries. The Temporal test would:\n1. Start the workflow in sandbox\n2. Send PhaseAdvanceSignal\n3. Query current_state() and assert phase changed\n4. Verify search attributes via the Temporal client\n\nThis is an integration test by nature — the real workflow code runs in a real (local) Temporal environment. The SUT (EpochWorkflow) is not mocked. Dependencies (Temporal server) are provided by the test harness.\n\n**Verdict: PROPERLY testable.** Temporal's sandbox testing is the right approach.\n\n### 5. Leverage of Existing Mutation Testing Framework\n\nThe proposal references SchemaFixture in test_schema_types_sync.py's integration test strategy. The existing framework provides:\n- `SchemaFixture` class for loading and mutating schema.xml\n- `SchemaMutation` dataclass for defining specific mutations\n- Parametrized testing for combinatorial coverage\n\nThe proposal's test_schema_types_sync.py would complement this: while SchemaFixture tests that validate_schema.py catches broken schemas, test_schema_types_sync.py tests that the Python type definitions match the valid schema. These are two sides of the same coin.\n\nThe proposal could potentially use SchemaFixture's `fresh_root()` to parse schema.xml in the integration tests, maintaining fixture reuse. This is not explicitly stated but is a natural extension.\n\n**Verdict: GOOD continuity with existing patterns.** The proposal extends rather than duplicates the mutation testing framework.\n\n### End-User Alignment Assessment\n\n1. **Who are the end-users?** Agent developers and protocol maintainers who need the state machine to enforce correct phase transitions.\n2. **What would end-users want?** Confidence that the protocol engine faithfully implements schema.xml rules — the test strategy delivers this via integration tests.\n3. **How would this affect them?** Drift between schema.xml and Python types would silently break protocol enforcement. test_schema_types_sync.py prevents this.\n4. **Are there implementation gaps?** Minor: the proposal does not specify whether test_workflow.py will use shared fixtures for EpochState construction across test files. Recommend a shared factory in tests/fixtures/.\n5. **Does MVP scope make sense?** Yes — the test files cover exactly the 5 modules proposed, plus the critical cross-module integration test.\n6. **Is validation checklist complete?** Yes — 17 items covering all testable properties.\n\n### Minor Observations (Non-Blocking)\n\n1. **Shared fixtures:** The proposal would benefit from an explicit shared fixture plan (e.g., a `tests/fixtures/epoch_fixtures.py` with factory functions for EpochState, PhaseSpec, ConstraintSpec). The existing SchemaFixture pattern shows the codebase values this. Not a blocker because the implementation phase will naturally create these.\n\n2. **Negative test cases for workflow:** AC6 says \"should not allow non-deterministic operations\" but this is hard to test directly (Temporal enforces this via sandbox replay). The AC phrasing is aspirational rather than testable — but the positive case (deterministic signal-driven transitions) is sufficient for v1.\n\n3. **test_constraints.py coverage:** The proposal lists 4 specific constraint checkers (check_review_consensus, check_dep_direction, check_severity_tree, check_handoff_required) but the validation checklist item 9 says \"Constraint checker catches all C-* constraints from schema.xml.\" The test should parametrize over all C-* constraint IDs from schema.xml to ensure completeness. This is an implementation detail best left to the worker, not a plan-level concern.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:00:38Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:00:38Z","labels":["aura:p4-plan:s4-review"]}
{"id":"aura-plugins-e19","title":"SLICE-1: Implement bin/aura-release","description":"---\nreferences:\n  impl_plan: aura-plugins-bch\n  proposal: aura-plugins-1bm\n---\n\nImplement bin/aura-release per PROPOSAL-2.\nSingle file: bin/aura-release","status":"open","priority":2,"issue_type":"task","assignee":"worker","owner":"dayvidpham@gmail.com","created_at":"2026-02-21T20:19:28Z","created_by":"David Huu Pham","updated_at":"2026-02-21T20:19:28Z","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-e19","depends_on_id":"aura-plugins-jjo","type":"blocks","created_at":"2026-02-21T12:23:45Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-eel","title":"SLICE-3-L1: Types — ConstraintViolation, RuntimeConstraintChecker skeleton","description":"---\nreferences:\n  slice: aura-plugins-mrm\n  impl_plan: aura-plugins-06g\n---\n## Scope\nDefine ConstraintViolation (frozen dataclass) and RuntimeConstraintChecker class skeleton with method signatures.\n\n## Files Owned\n- scripts/aura_protocol/constraints.py (type defs + method stubs)\n\n## Acceptance Criteria\nGiven constraints.py when imported then ConstraintViolation and RuntimeConstraintChecker importable should never have implementations yet","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:32:40Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:32:40Z","labels":["aura:p9-impl:s9-slice"]}
{"id":"aura-plugins-exe","title":"SLICE-4-L2: Tests — test_interfaces.py (AC9, AC10)","description":"---\nreferences:\n  slice: aura-plugins-8i5\n  impl_plan: aura-plugins-06g\n---\n## Scope\nWrite test_interfaces.py testing AC9 (Protocol isinstance checks) and AC10 (ModelId.parse). Tests import from interfaces.py.\n\n## Files Owned\n- tests/test_interfaces.py\n\n## Acceptance Criteria\nGiven test suite when run then Protocol compliance verified, ModelId parsing verified should never accept invalid model IDs","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:32:43Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:32:43Z","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-exe","depends_on_id":"aura-plugins-1cy","type":"blocks","created_at":"2026-02-21T17:32:44Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-g2a","title":"SLICE-1-TESTS: test_aura_types.py + test_schema_types_sync.py","description":"---\nreferences:\n  slice: aura-plugins-35d\n  impl_plan: aura-plugins-06g\n---\n## Scope\nWrite test_aura_types.py (enum completeness, spec freezing, PHASE_DOMAIN mapping) and test_schema_types_sync.py (integration test: Python types match schema.xml entities).\n\n## Files Owned\n- tests/test_aura_types.py\n- tests/test_schema_types_sync.py\n\n## Acceptance Criteria\nGiven test suite when run then all tests pass, enum completeness verified, schema.xml sync verified should never allow drift between Python types and schema.xml","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:32:37Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:42:02Z","closed_at":"2026-02-22T01:42:02Z","close_reason":"Closed","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-g2a","depends_on_id":"aura-plugins-9nc","type":"blocks","created_at":"2026-02-21T17:32:37Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-gbr","title":"ELICIT: SessionEntry orchestration — A2A/MCP-compliant protocol engine","description":"---\nreferences:\n  request: aura-plugins-bj1\n---\n\n## Questions and Responses\n\n### Round 1: End Vision\nQ: What is the end vision for transcript data? What will consumers DO with stored TranscriptEntries?\nOptions: Agent observability (Debug agent behavior), Analytics pipeline (Aggregate metrics), Training/fine-tuning data (Export for ML), Audit trail / compliance (Immutable record)\nA: ALL OF THE ABOVE. User notes: \"The exact end-goal vision is at ~/dev/agent-data-leverage/david-data-ingestion-typescript-pipeline/initial-collaboration-protocol.md and ~/dev/agent-data-leverage/david-data-ingestion-typescript-pipeline/nlp-project-proposal.md\"\n\n### Round 1: MVP Harnesses\nQ: Which model harnesses should the MVP support?\nOptions: Claude Code (JSONL transcripts), OpenCode (ACP messages), Generic JSON-RPC/MCP (future harnesses), Raw transcript files (heuristic parsing)\nA: Generic JSON-RPC/MCP, OpenCode, Claude Code. User notes: \"I already have an ACP compliant JSON-RPC 2.0 tool call filterer at ~/codebases/dayvidpham/agentfilter. However, this transcript parser is WIP and being built by me and others separately at ~/dev/agent-data-leverage/unified-schema, we can delegate to their implementation. We don't need to support transcript parsing so much, just orchestration. For the orchestration aspect, we can utilize some prior work done at ~/codebases/dayvidpham/nix-openclaw-vm/docs/research/temporal*.Rmd. They also have some usage of Temporal already.\"\n\n### Round 2: Orchestration Scope\nQ: What does 'orchestration' mean concretely here?\nOptions: Aura protocol workflow engine (12-phase machine-executable), Multi-harness pipeline coordinator (Temporal activities for ingestion), SessionEntry enrichment pipeline (post-ingestion tagging), Cross-project integration layer (bridge all projects)\nA: Aura protocol workflow engine + Cross-project integration layer. User notes: \"The cross-project integration layer is the end-goal vision, with a completely auditable agent workflow to improve open-source development, affecting the future of work for developers, and establishing a better integration layer for agents in the knowledge commons.\"\n\n### Round 2: Code Location\nQ: Where should the SessionEntry database design live?\nOptions: unified-schema (extend existing), aura-plugins (new module), New repo, nix-openclaw-vm (extend Temporal)\nA: unified-schema (extend existing). User notes: \"So because their team is handling it, we don't have to worry about it here. Should NOT modify any files outside of this repo.\"\n\n### Round 2: Schema Strategy\nQ: For the variant-rich schema problem: extend typed enum or delta composition?\nOptions: Extend typed enum (pragmatic), Delta composition (research-informed), Hybrid (recommended by research)\nA: Hybrid (recommended by research)\n\n### Round 3: MVP for Machine-Executable Protocol\nQ: What is the MVP for making the 12-phase protocol machine-executable?\nOptions: Constraint validator + state machine, Temporal workflow engine, Code generation from schema.xml, Schema.xml → runtime context injection\nA: User specified a 3-version roadmap:\n  v1: Constraint validator + state machine, built with Temporal (Python SDK)\n  v2: Schema.xml → runtime context injection (single source of truth, no SKILL.md drift)\n  v3: Full Temporal workflow engine (phases as workflows, handoffs as signals, constraints as activity guards)\nUser notes: \"Temporal used throughout though.\"\n\n### Round 3: Catch-All\nQ: Anything else about end vision, constraints, or integration points?\nOptions: Temporal is the target runtime, Must stay Python-only in aura-plugins, Beads is the task coordination layer, Nothing else\nA: Temporal is the target runtime + Must stay Python-only. User notes: \"Temporal has a Python SDK as well. Beads is what we will use for now. Eventually, should be superseded by our own solution that may utilize the APIs we develop. Temporal natively interfaces with a database for its audit trail and logging, so will be very useful here.\"","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T00:38:31Z","created_by":"David Huu Pham","updated_at":"2026-02-22T00:38:31Z","labels":["aura:p2-user:s2_1-elicit"],"dependencies":[{"issue_id":"aura-plugins-gbr","depends_on_id":"aura-plugins-gmv","type":"blocks","created_at":"2026-02-21T16:58:15Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-gbr","depends_on_id":"aura-plugins-umi","type":"blocks","created_at":"2026-02-21T16:39:11Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-gmv","title":"PROPOSAL-1: Machine-executable aura protocol engine v1 MVP — state machine + Temporal + constraint validators","description":"---\nreferences:\n  request: aura-plugins-bj1\n  urd: aura-plugins-umi\n  elicit: aura-plugins-gbr\n  related_epoch: aura-plugins-220\n---\n\n## Problem Space\n\n**Axes:** state machine (sequential with branching), constraint enforcement (transition-time), durability (Temporal), forensic queryability (search attributes), variant-rich integration (typed protocol/ABC interfaces)\n\n**Has-a / Is-a relationships:**\n- Epoch HAS-A state machine (12-phase lifecycle)\n- State machine HAS-A transition table (derived from schema.xml phase/transition definitions)\n- Epoch HAS-MANY constraint validators (structural, referential, semantic, runtime)\n- Temporal workflow IS-A durable wrapper around the state machine\n- PhaseId IS-A str Enum; Domain IS-A str Enum; RoleId IS-A str Enum (all typed)\n- ConstraintValidator IS-A Protocol (integration interface for cross-project)\n\n**Key insight:** The transition rules already exist in schema.xml (each `\u003cphase\u003e` has `\u003ctransitions\u003e` with `to-phase` and `condition`). For v1, we codify these as Python typed enums and a transition table. For v2, we parse schema.xml at runtime.\n\n## Engineering Tradeoffs\n\n| Decision | Options | Choice | Rationale |\n|----------|---------|--------|-----------|\n| State machine library | `transitions` lib / hand-rolled / `statemachine` lib | Hand-rolled dataclass + dict | Schema.xml defines exactly 12 phases with known transitions. A library adds dependency weight with no benefit for a fixed-topology machine. Simpler to test. |\n| Temporal workflow granularity | One workflow per epoch / one per phase | One per epoch (v1) | Per-epoch is sufficient for v1. Signals handle phase advances. Per-phase parallelism is v3 scope. |\n| Schema-to-code derivation | Parse schema.xml at runtime (v2) / codify transitions in Python (v1) | Python typed enums + frozen dataclass specs (v1) | Runtime parsing is v2 scope. For v1, we define the transition table as code, validated against schema.xml by integration tests. |\n| Constraint enforcement timing | Transition-time only / continuous polling | Transition-time only (v1) | Simpler, deterministic, sufficient. Constraints are checked when `advance_phase()` is called. |\n| Type system | Pydantic / dataclasses / attrs | dataclasses (frozen) | No Pydantic dependency currently. Frozen dataclasses provide immutability + type safety. Temporal SDK works with dataclasses natively. |\n| Package location | `scripts/aura_protocol/` / `src/aura_protocol/` | `scripts/aura_protocol/` | Consistent with existing `pythonpath = [\"scripts\"]` in pyproject.toml. `validate_schema` already lives in `scripts/`. |\n| Integration interfaces | Abstract Base Classes / `typing.Protocol` | `typing.Protocol` (runtime_checkable) | Structural subtyping — external projects don't need to inherit from our base classes. More Pythonic, better for cross-repo integration where we can't control the other side. |\n| A2A/MCP types scope | Full A2A type hierarchy / minimal content types | Minimal: Part union + TaskState + tool call types | v1 needs just enough for interface definitions. Full hierarchy is v2/v3 scope. |\n\n## MVP Milestone (v1)\n\n### Scope\n5 Python modules + corresponding tests, extending the existing validate_schema.py patterns:\n\n### Module 1: `scripts/aura_protocol/types.py` — Protocol Type Definitions\nTyped enums and frozen dataclass specs for all protocol entities. Derived from schema.xml but codified in Python.\n\n```python\nclass Domain(str, Enum):\n    USER = \"user\"\n    PLAN = \"plan\"\n    IMPL = \"impl\"\n\nclass PhaseId(str, Enum):\n    P1_REQUEST = \"p1\"\n    P2_ELICIT = \"p2\"\n    P3_PROPOSE = \"p3\"\n    P4_REVIEW = \"p4\"\n    P5_UAT = \"p5\"\n    P6_RATIFY = \"p6\"\n    P7_HANDOFF = \"p7\"\n    P8_IMPL_PLAN = \"p8\"\n    P9_SLICE = \"p9\"\n    P10_CODE_REVIEW = \"p10\"\n    P11_IMPL_UAT = \"p11\"\n    P12_LANDING = \"p12\"\n    COMPLETE = \"complete\"\n\nclass RoleId(str, Enum):\n    EPOCH = \"epoch\"\n    ARCHITECT = \"architect\"\n    REVIEWER = \"reviewer\"\n    SUPERVISOR = \"supervisor\"\n    WORKER = \"worker\"\n\nclass VoteType(str, Enum):\n    ACCEPT = \"ACCEPT\"\n    REVISE = \"REVISE\"\n\nclass SeverityLevel(str, Enum):\n    BLOCKER = \"BLOCKER\"\n    IMPORTANT = \"IMPORTANT\"\n    MINOR = \"MINOR\"\n\n# Phase-domain mapping (from schema.xml semantic rule _EXPECTED_DOMAINS)\nPHASE_DOMAIN: dict[PhaseId, Domain]\n\n# Frozen spec dataclasses\n@dataclass(frozen=True)\nclass Transition:\n    to_phase: PhaseId\n    condition: str\n    action: str | None = None\n\n@dataclass(frozen=True)\nclass PhaseSpec:\n    id: PhaseId\n    number: int\n    domain: Domain\n    name: str\n    owner_roles: frozenset[RoleId]\n    transitions: tuple[Transition, ...]\n\n@dataclass(frozen=True)\nclass ConstraintSpec:\n    id: str\n    given: str\n    when: str\n    then: str\n    should_not: str\n\n@dataclass(frozen=True)\nclass HandoffSpec:\n    id: str\n    source_role: RoleId\n    target_role: RoleId\n    at_phase: PhaseId\n    content_level: str\n    required_fields: tuple[str, ...]\n\n# Canonical protocol definition — the transition table\nPHASE_SPECS: dict[PhaseId, PhaseSpec]\nCONSTRAINT_SPECS: dict[str, ConstraintSpec]\nHANDOFF_SPECS: dict[str, HandoffSpec]\n```\n\n### Module 2: `scripts/aura_protocol/state_machine.py` — 12-Phase State Machine\nManages epoch lifecycle state and validates transitions against the protocol.\n\n```python\n@dataclass\nclass EpochState:\n    \"\"\"Mutable epoch runtime state.\"\"\"\n    current_phase: PhaseId\n    completed_phases: set[PhaseId]\n    review_votes: dict[str, VoteType]  # \"{axis}\" -\u003e vote\n    blocker_count: int\n    current_role: RoleId\n    epoch_id: str\n    transition_history: list[TransitionRecord]\n\n@dataclass(frozen=True)\nclass TransitionRecord:\n    from_phase: PhaseId\n    to_phase: PhaseId\n    timestamp: datetime\n    triggered_by: str  # role or signal name\n    condition_met: str\n\nclass TransitionError(Exception):\n    \"\"\"Raised when a transition is invalid.\"\"\"\n    violations: list[str]\n\nclass EpochStateMachine:\n    def __init__(self, epoch_id: str, specs: dict[PhaseId, PhaseSpec] | None = None): ...\n    \n    def advance(self, to_phase: PhaseId, *, triggered_by: str, condition_met: str) -\u003e TransitionRecord:\n        \"\"\"Advance to next phase. Raises TransitionError if invalid.\"\"\"\n    \n    def validate_advance(self, to_phase: PhaseId) -\u003e list[str]:\n        \"\"\"Dry-run: returns list of violation messages (empty = valid).\"\"\"\n    \n    def record_vote(self, axis: str, vote: VoteType) -\u003e None:\n        \"\"\"Record a reviewer vote (p4 or p10).\"\"\"\n    \n    def has_consensus(self) -\u003e bool:\n        \"\"\"True if all 3 review axes have ACCEPT votes.\"\"\"\n    \n    def record_blocker(self, *, resolved: bool = False) -\u003e None:\n        \"\"\"Track BLOCKER count for code review gating.\"\"\"\n    \n    @property\n    def state(self) -\u003e EpochState: ...\n    \n    @property\n    def available_transitions(self) -\u003e list[Transition]: ...\n```\n\n### Module 3: `scripts/aura_protocol/constraints.py` — Runtime Constraint Validators\nExtends the validate_schema.py pattern for runtime state checking.\n\n```python\n@dataclass(frozen=True)\nclass ConstraintViolation:\n    constraint_id: str\n    message: str\n    context: dict[str, str]\n\nclass RuntimeConstraintChecker:\n    \"\"\"Checks protocol constraints against current epoch state.\"\"\"\n    \n    def __init__(self, constraint_specs: dict[str, ConstraintSpec] | None = None): ...\n    \n    def check_all(self, state: EpochState) -\u003e list[ConstraintViolation]:\n        \"\"\"Run all constraint checks against current state.\"\"\"\n    \n    def check_transition(self, state: EpochState, to_phase: PhaseId) -\u003e list[ConstraintViolation]:\n        \"\"\"Check constraints specific to a proposed transition.\"\"\"\n    \n    def check_review_consensus(self, state: EpochState) -\u003e list[ConstraintViolation]:\n        \"\"\"C-review-consensus: all 3 must ACCEPT.\"\"\"\n    \n    def check_dep_direction(self, parent_id: str, child_id: str) -\u003e list[ConstraintViolation]:\n        \"\"\"C-dep-direction: parent blocked-by child.\"\"\"\n    \n    def check_severity_tree(self, state: EpochState) -\u003e list[ConstraintViolation]:\n        \"\"\"C-severity-eager: 3 groups must exist for p10.\"\"\"\n    \n    def check_handoff_required(self, from_phase: PhaseId, to_phase: PhaseId) -\u003e list[ConstraintViolation]:\n        \"\"\"C-handoff-skill-invocation: handoff doc required for actor changes.\"\"\"\n```\n\n### Module 4: `scripts/aura_protocol/workflow.py` — Temporal Workflow Definition\nDurable execution wrapper around the state machine.\n\n```python\nfrom temporalio import workflow, activity\nfrom temporalio.common import SearchAttributeKey, TypedSearchAttributes\n\n# Search attributes for forensic queries (R4)\nSA_EPOCH_ID = SearchAttributeKey.for_text(\"AuraEpochId\")\nSA_PHASE = SearchAttributeKey.for_keyword(\"AuraPhase\")\nSA_ROLE = SearchAttributeKey.for_keyword(\"AuraRole\")\nSA_STATUS = SearchAttributeKey.for_keyword(\"AuraStatus\")\nSA_DOMAIN = SearchAttributeKey.for_keyword(\"AuraDomain\")\n\n@dataclass(frozen=True)\nclass EpochInput:\n    epoch_id: str\n    request_description: str\n\n@dataclass(frozen=True) \nclass EpochResult:\n    epoch_id: str\n    final_phase: PhaseId\n    transition_count: int\n    constraint_violations_total: int\n\n@dataclass(frozen=True)\nclass PhaseAdvanceSignal:\n    to_phase: PhaseId\n    triggered_by: str\n    condition_met: str\n\n@dataclass(frozen=True)\nclass ReviewVoteSignal:\n    axis: str  # \"A\", \"B\", \"C\"\n    vote: VoteType\n    reviewer_id: str\n\n@workflow.defn\nclass EpochWorkflow:\n    \"\"\"Temporal workflow for a single epoch lifecycle.\n    \n    The workflow wraps EpochStateMachine and exposes:\n    - Signals for phase advances and review votes\n    - Queries for current state\n    - Search attributes for forensic queries\n    \"\"\"\n    \n    @workflow.run\n    async def run(self, input: EpochInput) -\u003e EpochResult:\n        \"\"\"Wait for signals to advance through phases until COMPLETE.\"\"\"\n    \n    @workflow.signal\n    async def advance_phase(self, signal: PhaseAdvanceSignal) -\u003e None:\n        \"\"\"Signal to advance to the next phase.\"\"\"\n    \n    @workflow.signal\n    async def submit_vote(self, signal: ReviewVoteSignal) -\u003e None:\n        \"\"\"Signal to record a review vote.\"\"\"\n    \n    @workflow.query\n    def current_state(self) -\u003e EpochState:\n        \"\"\"Query current epoch state.\"\"\"\n    \n    @workflow.query\n    def available_transitions(self) -\u003e list[Transition]:\n        \"\"\"Query available transitions from current phase.\"\"\"\n\n@activity.defn\nasync def check_constraints(state: EpochState, to_phase: PhaseId) -\u003e list[ConstraintViolation]:\n    \"\"\"Activity to run constraint checks (allows retry on transient failures).\"\"\"\n\n@activity.defn\nasync def record_transition(record: TransitionRecord) -\u003e None:\n    \"\"\"Activity to persist transition to audit trail.\"\"\"\n```\n\n### Module 5: `scripts/aura_protocol/interfaces.py` — Cross-Project Integration Interfaces\nPython Protocols for variant-rich integration.\n\n```python\nfrom typing import Protocol, runtime_checkable\n\n@runtime_checkable\nclass ConstraintValidatorInterface(Protocol):\n    \"\"\"Any constraint validator must implement this.\"\"\"\n    def validate(self, state: EpochState) -\u003e list[ConstraintViolation]: ...\n\n@runtime_checkable\nclass TranscriptRecorder(Protocol):\n    \"\"\"Interface for unified-schema integration (transcript recording).\n    \n    Implementors live in unified-schema; we only define the contract.\n    \"\"\"\n    async def record_phase_transition(self, event: PhaseTransitionEvent) -\u003e None: ...\n    async def record_constraint_check(self, event: ConstraintCheckEvent) -\u003e None: ...\n    async def record_review_vote(self, event: ReviewVoteEvent) -\u003e None: ...\n\n@runtime_checkable\nclass SecurityGate(Protocol):\n    \"\"\"Interface for agentfilter integration (permission checking).\n    \n    Implementors live in agentfilter; we only define the contract.\n    \"\"\"\n    async def check_tool_permission(self, request: ToolPermissionRequest) -\u003e PermissionDecision: ...\n\n@runtime_checkable\nclass AuditTrail(Protocol):\n    \"\"\"Interface for the audit trail backend.\n    \n    v1: backed by Beads (bd CLI).\n    v2+: backed by Temporal event history + search attributes.\n    \"\"\"\n    async def record_event(self, event: AuditEvent) -\u003e None: ...\n    async def query_events(self, *, phase: PhaseId | None = None, role: RoleId | None = None) -\u003e list[AuditEvent]: ...\n\n# A2A-compatible content types (minimal subset for v1)\n@dataclass(frozen=True)\nclass TextPart:\n    \"\"\"A2A TextPart — text content.\"\"\"\n    text: str\n\n@dataclass(frozen=True)\nclass FilePart:\n    \"\"\"A2A FilePart — file content reference.\"\"\"\n    file_uri: str\n    mime_type: str | None = None\n\n@dataclass(frozen=True)\nclass DataPart:\n    \"\"\"A2A DataPart — structured data.\"\"\"\n    data: dict\n\nPart = TextPart | FilePart | DataPart  # A2A Part discriminated union\n\n@dataclass(frozen=True)\nclass ToolCall:\n    \"\"\"MCP-compatible tool call representation.\"\"\"\n    tool_name: str\n    tool_input: dict\n    tool_output: dict | None = None\n\n@dataclass(frozen=True)\nclass ModelId:\n    \"\"\"models.dev composite identifier: {provider_id}/{model_id}.\"\"\"\n    provider: str\n    model: str\n    \n    def __str__(self) -\u003e str:\n        return f\"{self.provider}/{self.model}\"\n    \n    @classmethod\n    def parse(cls, s: str) -\u003e \"ModelId\":\n        provider, _, model = s.partition(\"/\")\n        if not model:\n            raise ValueError(f\"Invalid model ID: {s!r} (expected 'provider/model')\")\n        return cls(provider=provider, model=model)\n```\n\n### File Tree (New Files)\n\n```\nscripts/\n  aura_protocol/                  # NEW package\n    __init__.py                   # Re-exports public API\n    types.py                      # Typed enums, frozen dataclass specs\n    state_machine.py              # EpochStateMachine + EpochState\n    constraints.py                # RuntimeConstraintChecker\n    workflow.py                   # Temporal EpochWorkflow + activities\n    interfaces.py                 # Protocol/ABC for cross-project integration\ntests/\n  test_aura_types.py              # NEW: enum coverage, spec completeness\n  test_state_machine.py           # NEW: transition validation, review gates\n  test_constraints.py             # NEW: runtime constraint checking\n  test_workflow.py                # NEW: Temporal workflow (sandbox tests)\n  test_interfaces.py              # NEW: Protocol compliance verification\n  test_schema_types_sync.py       # NEW: integration test — Python types match schema.xml\n```\n\n### Dependencies\n\n```toml\n# pyproject.toml additions\n[project]\ndependencies = [\"temporalio\u003e=1.9.0\"]\n\n[project.optional-dependencies]\ndev = [\"pytest\u003e=8.0\", \"pytest-asyncio\u003e=0.24\"]\n```\n\n## Validation Checklist\n\n- [ ] All PhaseId enum values match schema.xml `\u003cphase\u003e` elements (integration test)\n- [ ] All Domain enum values match schema.xml `\u003cenum name=\"DomainType\"\u003e` (integration test)\n- [ ] All RoleId enum values match schema.xml `\u003crole\u003e` elements (integration test)\n- [ ] PHASE_DOMAIN mapping matches schema.xml semantic rule _EXPECTED_DOMAINS\n- [ ] Transition table covers all transitions in schema.xml `\u003ctransitions\u003e`\n- [ ] State machine rejects invalid transitions (not in transition table)\n- [ ] Review consensus gate requires exactly 3 ACCEPT votes (axes A, B, C)\n- [ ] BLOCKER resolution gate blocks p10→p11 transition\n- [ ] Constraint checker catches all C-* constraints from schema.xml\n- [ ] Temporal workflow advances state via signals only (deterministic)\n- [ ] Search attributes updated on every phase transition\n- [ ] Temporal queries return correct current state\n- [ ] All Protocol interfaces are runtime_checkable\n- [ ] ModelId.parse() validates provider/model format\n- [ ] A2A Part union covers TextPart, FilePart, DataPart\n- [ ] Existing validate_schema.py tests still pass (no regressions)\n- [ ] Integration test: Python PhaseSpec transitions match schema.xml transitions\n\n## BDD Acceptance Criteria\n\n### AC1: State Machine Transitions\n**Given** an epoch in phase P1 **when** advance(\"p2\") is called with valid context **then** state transitions to P2 and transition is recorded **should not** allow skipping phases (e.g., p1→p8)\n\n### AC2: Review Consensus Gate\n**Given** an epoch in phase P4 with votes {A: ACCEPT, B: ACCEPT} **when** advance(\"p5\") is called **then** TransitionError is raised with \"consensus\" violation **should not** proceed without all 3 ACCEPT votes\n\n### AC3: Review Revision Loop\n**Given** an epoch in phase P4 with any REVISE vote **when** checking available transitions **then** only p3 (create new proposal) is available **should not** allow advance to p5\n\n### AC4: BLOCKER Resolution Gate\n**Given** an epoch in phase P10 with blocker_count \u003e 0 **when** advance(\"p11\") is called **then** TransitionError is raised **should not** proceed to UAT with unresolved BLOCKERs\n\n### AC5: Constraint Enforcement\n**Given** a RuntimeConstraintChecker with all schema.xml constraints **when** checking state with a violation **then** returns ConstraintViolation with the constraint_id and descriptive message **should not** silently pass violations\n\n### AC6: Temporal Workflow Durability\n**Given** a running EpochWorkflow **when** advance_phase signal is received **then** state machine transitions and search attributes are updated atomically **should not** allow non-deterministic operations in workflow code\n\n### AC7: Forensic Query via Search Attributes\n**Given** a running EpochWorkflow at phase P9 **when** querying Temporal with filter AuraPhase=\"p9\" **then** the workflow is returned in results **should not** have stale search attributes\n\n### AC8: Schema-Types Synchronization\n**Given** the Python type definitions in types.py **when** compared against schema.xml entities **then** every PhaseId, Domain, RoleId, VoteType, and SeverityLevel has a corresponding schema.xml element **should not** drift from schema.xml\n\n### AC9: Integration Interface Compliance\n**Given** a class implementing TranscriptRecorder Protocol **when** checked with isinstance() **then** returns True if all methods match **should not** require subclassing (structural subtyping)\n\n### AC10: Model ID Parsing\n**Given** ModelId.parse(\"anthropic/claude-opus-4-6\") **when** parsed **then** provider=\"anthropic\" and model=\"claude-opus-4-6\" **should not** accept strings without \"/\" separator","design":"{\"validation_checklist\":[\"PhaseId matches schema.xml phases\",\"Domain matches DomainType enum\",\"RoleId matches schema.xml roles\",\"Transition table covers all schema.xml transitions\",\"Review consensus requires 3 ACCEPT votes\",\"BLOCKER gate blocks p10-\u003ep11\",\"Constraint checker covers all C-* constraints\",\"Temporal workflow uses signals only\",\"Search attributes updated on transitions\",\"Protocol interfaces are runtime_checkable\",\"ModelId validates provider/model format\",\"Existing tests pass (no regressions)\",\"Integration test: Python specs match schema.xml\"],\"acceptance_criteria\":[{\"given\":\"epoch in phase P1\",\"when\":\"advance(p2) with valid context\",\"then\":\"transitions to P2, records transition\"},{\"given\":\"epoch in P4 with 2 of 3 ACCEPT\",\"when\":\"advance(p5)\",\"then\":\"TransitionError raised\"},{\"given\":\"epoch in P10 with blockers\",\"when\":\"advance(p11)\",\"then\":\"TransitionError raised\"},{\"given\":\"RuntimeConstraintChecker\",\"when\":\"checking violated state\",\"then\":\"returns ConstraintViolation list\"},{\"given\":\"running EpochWorkflow\",\"when\":\"advance_phase signal\",\"then\":\"state and search attributes updated atomically\"},{\"given\":\"Python types\",\"when\":\"compared to schema.xml\",\"then\":\"all enums have corresponding elements\"}],\"tradeoffs\":[{\"decision\":\"Hand-rolled state machine vs library\",\"rationale\":\"Fixed 12-phase topology, library adds unnecessary dependency\"},{\"decision\":\"One workflow per epoch vs per phase\",\"rationale\":\"Per-epoch simpler for v1, per-phase is v3\"},{\"decision\":\"dataclasses vs Pydantic\",\"rationale\":\"No Pydantic dep, Temporal SDK native dataclass support\"},{\"decision\":\"typing.Protocol vs ABC\",\"rationale\":\"Structural subtyping for cross-repo integration\"}]}","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T00:58:11Z","created_by":"David Huu Pham","updated_at":"2026-02-22T00:58:11Z","labels":["aura:p3-plan:s3-propose","aura:p6-plan:s6-ratify"],"dependencies":[{"issue_id":"aura-plugins-gmv","depends_on_id":"aura-plugins-06g","type":"blocks","created_at":"2026-02-21T17:29:21Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-gmv","depends_on_id":"aura-plugins-7gm","type":"blocks","created_at":"2026-02-21T17:00:19Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-gmv","depends_on_id":"aura-plugins-b5m","type":"blocks","created_at":"2026-02-21T17:17:57Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-gmv","depends_on_id":"aura-plugins-dwy","type":"blocks","created_at":"2026-02-21T17:00:42Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-gmv","depends_on_id":"aura-plugins-jd9","type":"blocks","created_at":"2026-02-21T17:00:39Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-gmv","depends_on_id":"aura-plugins-qil","type":"blocks","created_at":"2026-02-21T17:17:00Z","created_by":"David Huu Pham","metadata":"{}"}],"comments":[{"id":4,"issue_id":"aura-plugins-gmv","author":"David Huu Pham","text":"Reviewer A (Correctness): VOTE: ACCEPT - Proposal faithfully addresses all 8 URD requirements within v1 scope. Transition table derived from schema.xml is sound (12 phases + COMPLETE sentinel, forward transitions + 4 revision loops). Temporal integration follows correct patterns (signals for mutations, queries for reads, activities for I/O, search attributes for forensics). All engineering tradeoffs are well-justified and internally consistent. Review consensus and BLOCKER gates correctly model schema.xml constraints. 3 minor non-blocking observations: (1) A2A TaskState enum noted in URD but absent from module definitions, (2) Temporal serialization of set/dict with enum keys is an implementation detail to handle, (3) follow-up lifecycle state machine reuse could be clarified. No BLOCKER issues found. Full review at aura-plugins-7gm.","created_at":"2026-02-22T01:00:26Z"},{"id":5,"issue_id":"aura-plugins-gmv","author":"David Huu Pham","text":"Reviewer C (Elegance): VOTE: ACCEPT - Design demonstrates proportionate complexity. 5-module decomposition maps to 5 orthogonal problem axes. str Enum + frozen dataclasses match fixed 12-phase topology without over-engineering. typing.Protocol for cross-repo integration avoids forced inheritance. Two minor under-specifications (event type stubs needed, vote key format ambiguous) are resolvable during implementation without proposal revision. No premature abstractions of consequence. Complexity proportional to innate problem structure. Review task: aura-plugins-jd9","created_at":"2026-02-22T01:00:45Z"},{"id":6,"issue_id":"aura-plugins-gmv","author":"David Huu Pham","text":"Reviewer B (Test quality): VOTE: ACCEPT - Test strategy is well-designed: (1) 6 test files properly cover all 5 modules + cross-module sync integration test. (2) test_schema_types_sync.py is the linchpin integration test preventing Python/schema.xml drift. (3) All 10 BDD acceptance criteria (AC1-AC10) map to testable observable outcomes (return values, exceptions, isinstance). (4) Temporal sandbox testing is the correct approach — SUT is not mocked. (5) Existing SchemaFixture mutation framework is naturally extended. Minor observation: recommend shared EpochState factory fixtures during implementation, but this is an implementation detail, not a plan deficiency. Review task: aura-plugins-dwy","created_at":"2026-02-22T01:00:53Z"},{"id":7,"issue_id":"aura-plugins-gmv","author":"David Huu Pham","text":"RATIFIED: All 3 reviewers ACCEPT (A: aura-plugins-7gm, B: aura-plugins-dwy, C: aura-plugins-jd9), UAT passed (aura-plugins-qil)","created_at":"2026-02-22T01:17:09Z"}]}
{"id":"aura-plugins-j2k","title":"REQUEST: Automated release tagging and version bumping for aura-plugins","description":"---\nverbatim_request: \"I need automated release tagging and version bumping for the Claude Code plugin.\"\nclassification:\n  scope: medium\n  complexity: medium\n  risk: low\n  domain_novelty: low\n---\n\n## User Request (Verbatim)\n\n\"I need automated release tagging and version bumping for the Claude Code plugin.\"\n\n## Phase 1 Findings\n\n### s1_1-classify\nScope: medium | Complexity: medium | Risk: low | Domain Novelty: low\n\n### s1_2-research\n- Git tag convention: vX.Y.Z (annotated tags) is industry standard\n- Semver: major, minor, patch\n- Pre-release checks: clean working tree, version consistency across files\n- Single Python script with argparse is sufficient for small projects\n- CHANGELOG: Keep a Changelog format\n- Post-release: push tag, optionally gh release create\n\n### s1_3-explore\n- 3 files need version updates: pyproject.toml, plugin.json, marketplace.json\n- marketplace.json has 2 version fields (metadata.version + plugins[0].version)\n- plugins[1].version (agentfilter) is external, must NOT be bumped\n- Currently out of sync: marketplace.json at 0.2.1, others at 0.2.2\n- No git tags exist\n- bin/ tools, flake.nix, README.md have no hardcoded versions","status":"open","priority":2,"issue_type":"task","assignee":"architect","owner":"dayvidpham@gmail.com","created_at":"2026-02-21T20:10:12Z","created_by":"David Huu Pham","updated_at":"2026-02-21T20:10:12Z","labels":["aura:p1-user:s1_1-classify","aura:p1-user:s1_2-research","aura:p1-user:s1_3-explore"],"dependencies":[{"issue_id":"aura-plugins-j2k","depends_on_id":"aura-plugins-wqw","type":"blocks","created_at":"2026-02-21T12:10:26Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-jd9","title":"PROPOSAL-1-REVIEW-C-1: aura protocol engine v1","description":"VOTE: ACCEPT - The design demonstrates proportionate complexity across all dimensions.\n\n## Axis C (Elegance) Assessment\n\n### Module Decomposition (5 modules): APPROPRIATE\nThe 5-module split (types, state_machine, constraints, workflow, interfaces) maps to 5 orthogonal concerns in the problem domain. No redundancy, no missing axis. Minor observation: A2A content types (TextPart/FilePart/DataPart/ToolCall/ModelId) in interfaces.py are data types, not interfaces — they could live in types.py. Not a structural issue.\n\n### Typed Enum Approach: EXACTLY RIGHT\nstr Enum provides forward-compatible serialization (strings serialize trivially to JSON/Temporal payloads) while maintaining compile-time type safety. The transition table as dict[PhaseId, PhaseSpec] with frozen dataclasses matches the fixed 12-phase topology without library overhead.\n\n### Integration Interfaces (typing.Protocol): CORRECT CHOICE\nruntime_checkable Protocol is the right abstraction for cross-repo integration where we don't control the other side. Avoids forcing inheritance. 4 Protocol definitions with zero implementation weight — just contracts.\n\n### A2A Content Types Subset: WELL-SCOPED\nTextPart/FilePart/DataPart/Part union/ToolCall/ModelId covers what v1 needs per URD R5. Omitting ResourceLinkPart is appropriate (MCP-specific, not needed for orchestration). ModelId with parse()/str() is clean.\n\n### Package Layout: CONSISTENT\nscripts/aura_protocol/ respects existing pythonpath = [\"scripts\"] in pyproject.toml. Test files follow existing flat tests/ convention.\n\n### Premature Abstractions: MINIMAL\nHandoffSpec and SecurityGate are the most \"premature\" elements, but they are lightweight declarations (frozen dataclass, Protocol) with zero implementation burden. Acceptable as forward-looking documentation.\n\n### Under-Specification: TWO MINOR ITEMS\n1. Event types for integration protocols (PhaseTransitionEvent, ConstraintCheckEvent, ReviewVoteEvent, AuditEvent, ToolPermissionRequest, PermissionDecision) are referenced but not defined. Should be listed as stub dataclasses.\n2. EpochState.review_votes key format is ambiguous — should clarify that axis letter (\"A\"/\"B\"/\"C\") is the canonical key (matches PROPOSAL-1-REVIEW-{axis}-{round} naming convention).\n\n### Conclusion\nNo over-engineering: no generic FSM library, no schema parser for v1, no Pydantic dependency. No under-engineering: frozen dataclasses for immutability, runtime_checkable for structural subtyping, integration test against schema.xml for drift detection. Complexity is proportional to the innate 12-phase, 5-role, 3-domain protocol structure. The two under-specification items are minor enough to resolve during implementation (L1: types layer) rather than requiring a proposal revision.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:00:36Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:00:36Z","labels":["aura:p4-plan:s4-review"]}
{"id":"aura-plugins-jjo","title":"SLICE-1-REVIEW: Code review for bin/aura-release","description":"---\nreferences:\n  slice: aura-plugins-e19\n---\n\n## Review Findings (all resolved)\n\n### BLOCKER (fixed)\n1. rollback() had `or True` guard causing git checkout on non-existent files → removed\n\n### IMPORTANT (fixed)\n2. --sync + --no-commit leaves files dirty → added warning message\n3. cmd_check drift marker compared to first dict value → now uses pyproject.toml as canonical reference\n4. write_pyproject_version raised false RuntimeError on re-run → switched to pre-check regex match\n\n### MINOR (acknowledged)\n5. commits_since drops commit bodies/trailers → documented limitation, spec does not require trailers\n6. working_tree_dirty drops old rename path → extremely unlikely scenario\n\nAll BLOCKER and IMPORTANT findings resolved in the implementation.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-21T20:23:41Z","created_by":"David Huu Pham","updated_at":"2026-02-21T20:23:41Z","labels":["aura:p10-impl:s10-review"]}
{"id":"aura-plugins-la6","title":"SLICE-2: state_machine.py — 12-phase epoch lifecycle","description":"---\nreferences:\n  impl_plan: aura-plugins-06g\n  urd: aura-plugins-umi\n  proposal: aura-plugins-gmv\n---\n## Specification\nManage epoch lifecycle state and validate transitions against the protocol. Pure Python — no Temporal dependency.\n\n### Key Types\n- EpochState (mutable runtime state)\n- TransitionRecord (frozen, immutable audit entry)\n- TransitionError (exception with violations list)\n- EpochStateMachine (main class)\n\n### Key Behaviors\n- advance(to_phase) — validates and executes transitions\n- validate_advance(to_phase) — dry-run validation\n- record_vote(axis, vote) — record reviewer votes\n- has_consensus() — check 3/3 ACCEPT\n- record_blocker(resolved) — track BLOCKER count\n- available_transitions property\n\n### Transition Rules (from schema.xml)\n- Sequential forward: p1→p2→p3→p4→p5→p6→p7→p8→p9→p10→p11→p12→complete\n- Review revision loops: p4→p3 (REVISE), p10→p9 (BLOCKER fix)\n- Consensus gate: p4→p5 requires 3 ACCEPT, p5→p6 requires UAT pass\n- BLOCKER gate: p10→p11 requires blocker_count == 0\n\n## Files Owned\n- scripts/aura_protocol/state_machine.py (NEW)\n- tests/test_state_machine.py (NEW)\n\n## Acceptance Criteria\n- AC1: Given epoch in P1 when advance(p2) then transitions, records transition should not allow p1→p8\n- AC2: Given epoch in P4 with 2/3 ACCEPT when advance(p5) then TransitionError should not proceed without consensus\n- AC3: Given epoch in P4 with REVISE when checking transitions then only p3 available\n- AC4: Given epoch in P10 with blockers when advance(p11) then TransitionError should not proceed to UAT\n\n## Validation Checklist\n- [ ] EpochState dataclass defined\n- [ ] TransitionRecord frozen dataclass\n- [ ] TransitionError with violations list\n- [ ] EpochStateMachine class with all methods\n- [ ] Tests cover AC1-AC4\n- [ ] Transition table covers all schema.xml transitions","design":"{\"validation_checklist\":[\"State transitions validated\",\"Review consensus gate works\",\"BLOCKER resolution gate works\",\"Transition history recorded\"],\"acceptance_criteria\":[{\"given\":\"epoch in P1\",\"when\":\"advance(p2)\",\"then\":\"transitions to P2\"},{\"given\":\"epoch in P4 with 2/3 ACCEPT\",\"when\":\"advance(p5)\",\"then\":\"TransitionError raised\"},{\"given\":\"epoch in P10 with blockers\",\"when\":\"advance(p11)\",\"then\":\"TransitionError raised\"}],\"ratified_plan\":\"aura-plugins-gmv\"}","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:31:28Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:31:28Z","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-la6","depends_on_id":"aura-plugins-0n3","type":"blocks","created_at":"2026-02-21T17:32:39Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-la6","depends_on_id":"aura-plugins-125","type":"blocks","created_at":"2026-02-21T17:32:38Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-la6","depends_on_id":"aura-plugins-35d","type":"blocks","created_at":"2026-02-21T17:31:30Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-la6","depends_on_id":"aura-plugins-4mu","type":"blocks","created_at":"2026-02-21T17:32:38Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-lkz","title":"SLICE-5: workflow.py — Temporal workflow wrapper","description":"---\nreferences:\n  impl_plan: aura-plugins-06g\n  urd: aura-plugins-umi\n  proposal: aura-plugins-gmv\n---\n## Specification\nTemporal workflow wrapping EpochStateMachine with durable execution. Signals for mutations, queries for reads, search attributes for forensics.\n\n### Key Types\n- EpochInput, EpochResult (frozen dataclasses)\n- PhaseAdvanceSignal, ReviewVoteSignal (frozen signal types)\n- Search attribute keys: SA_EPOCH_ID, SA_PHASE, SA_ROLE, SA_STATUS, SA_DOMAIN\n\n### Workflow\n- EpochWorkflow (@workflow.defn)\n  - run(input) — wait for signals, advance through phases\n  - advance_phase(signal) — signal handler\n  - submit_vote(signal) — signal handler\n  - current_state() — query\n  - available_transitions() — query\n\n### Activities\n- check_constraints(state, to_phase) — activity\n- record_transition(record) — activity\n\n### pyproject.toml Changes\n- Add temporalio\u003e=1.9.0 to [project].dependencies\n- Add pytest\u003e=8.0, pytest-asyncio\u003e=0.24 to [project.optional-dependencies].dev\n\n## Files Owned\n- scripts/aura_protocol/workflow.py (NEW)\n- tests/test_workflow.py (NEW)\n- pyproject.toml (MODIFY — add dependencies)\n\n## Acceptance Criteria\n- AC6: Given running EpochWorkflow when advance_phase signal then state + search attrs updated atomically should not have non-deterministic ops\n- AC7: Given workflow at P9 when querying AuraPhase=\"p9\" then workflow returned should not have stale attrs\n\n## Validation Checklist\n- [ ] EpochWorkflow with signals, queries, search attrs\n- [ ] Activities for constraint checking and transition recording\n- [ ] Temporal sandbox tests pass\n- [ ] pyproject.toml deps added\n- [ ] Search attributes updated on every transition","design":"{\"validation_checklist\":[\"Temporal workflow uses signals only\",\"Search attributes updated\",\"Sandbox tests pass\",\"pyproject.toml updated\"],\"acceptance_criteria\":[{\"given\":\"running EpochWorkflow\",\"when\":\"advance_phase signal\",\"then\":\"state and search attrs updated atomically\",\"should_not\":\"non-deterministic ops\"},{\"given\":\"workflow at P9\",\"when\":\"query AuraPhase=p9\",\"then\":\"workflow returned\",\"should_not\":\"stale search attrs\"}],\"ratified_plan\":\"aura-plugins-gmv\"}","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:31:30Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:31:30Z","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-lkz","depends_on_id":"aura-plugins-2au","type":"blocks","created_at":"2026-02-21T17:32:47Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-lkz","depends_on_id":"aura-plugins-35d","type":"blocks","created_at":"2026-02-21T17:31:31Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-lkz","depends_on_id":"aura-plugins-amx","type":"blocks","created_at":"2026-02-21T17:32:46Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-lkz","depends_on_id":"aura-plugins-la6","type":"blocks","created_at":"2026-02-21T17:31:32Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-lkz","depends_on_id":"aura-plugins-mrm","type":"blocks","created_at":"2026-02-21T17:31:32Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-lkz","depends_on_id":"aura-plugins-r1n","type":"blocks","created_at":"2026-02-21T17:32:45Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-mrm","title":"SLICE-3: constraints.py — Runtime constraint validators","description":"---\nreferences:\n  impl_plan: aura-plugins-06g\n  urd: aura-plugins-umi\n  proposal: aura-plugins-gmv\n---\n## Specification\nRuntime constraint checking engine. Extends validate_schema.py patterns for runtime state.\n\n### Key Types\n- ConstraintViolation (frozen dataclass: constraint_id, message, context dict)\n- RuntimeConstraintChecker (main class)\n\n### Key Behaviors\n- check_all(state) — run all constraints against EpochState\n- check_transition(state, to_phase) — check transition-specific constraints\n- check_review_consensus(state) — C-review-consensus\n- check_dep_direction(parent, child) — C-dep-direction\n- check_severity_tree(state) — C-severity-eager (3 groups for p10)\n- check_handoff_required(from_phase, to_phase) — C-handoff-skill-invocation\n\n### Constraints to Implement (from schema.xml C-* IDs)\nAll constraint IDs from schema.xml must have corresponding check methods.\n\n## Files Owned\n- scripts/aura_protocol/constraints.py (NEW)\n- tests/test_constraints.py (NEW)\n\n## Acceptance Criteria\n- AC5: Given RuntimeConstraintChecker when checking violated state then returns ConstraintViolation list should not silently pass\n\n## Validation Checklist\n- [ ] ConstraintViolation dataclass defined\n- [ ] RuntimeConstraintChecker class with all check methods\n- [ ] Tests cover all C-* constraints\n- [ ] check_all aggregates all violations\n- [ ] Each check method returns specific constraint_id","design":"{\"validation_checklist\":[\"All C-* constraints covered\",\"ConstraintViolation with context\",\"Aggregation via check_all\"],\"acceptance_criteria\":[{\"given\":\"RuntimeConstraintChecker\",\"when\":\"checking violated state\",\"then\":\"returns ConstraintViolation list\",\"should_not\":\"silently pass violations\"}],\"ratified_plan\":\"aura-plugins-gmv\"}","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:31:29Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:31:29Z","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-mrm","depends_on_id":"aura-plugins-35d","type":"blocks","created_at":"2026-02-21T17:31:31Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-mrm","depends_on_id":"aura-plugins-9ii","type":"blocks","created_at":"2026-02-21T17:32:42Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-mrm","depends_on_id":"aura-plugins-eel","type":"blocks","created_at":"2026-02-21T17:32:40Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-mrm","depends_on_id":"aura-plugins-la6","type":"blocks","created_at":"2026-02-21T17:31:31Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-mrm","depends_on_id":"aura-plugins-w28","type":"blocks","created_at":"2026-02-21T17:32:41Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-nfr","title":"UAT-2: Implementation testing — UX issues found","description":"---\nreferences:\n  slice: aura-plugins-e19\n  review: aura-plugins-jjo\n---\n\n## UAT Result: ACCEPT with UX fixes needed\n\n### User Testing Logs (Verbatim)\n\nUser ran the following commands and found UX confusion:\n\n1. `python3 bin/aura-release` (no args) → error message says \"bump type required\" but doesn't show example usage\n2. `python3 bin/aura-release --dry-run` → confusing: fails asking for bump type, user expected it to show what current state is\n3. `python3 bin/aura-release --dry-run --sync` → same, fails asking for bump type\n4. `python3 bin/aura-release patch --dry-run` → fails with drift error, user didn't know --sync was needed alongside patch\n\n### User Feedback (Verbatim)\n- \"This was confusing: what does the program do when no subcommands or flags are given? How come the --dry-run kept failing? Error message is un-informative.\"\n- \"--check flag has good output and actionable output message.\"\n- \"--sync was confusing: only seasoned CLI users would know how to parse the message and know what was missing.\"\n- \"Good so far: should also have a message about what needs to be clean in the git worktree when syncing.\"\n\n### Issues to Fix\n1. No-args and missing-bump-type error messages need actionable examples\n2. Drift error needs to show the exact command to run (e.g., \"Try: aura-release patch --sync\")\n3. --sync should explain what needs to be clean in the git worktree\n4. Overall: error messages should guide the user to the next action","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-21T20:30:17Z","created_by":"David Huu Pham","updated_at":"2026-02-21T20:30:17Z","labels":["aura:p11-user:s11-uat"]}
{"id":"aura-plugins-qil","title":"UAT-1: aura protocol engine v1 MVP plan","description":"---\nreferences:\n  proposal: aura-plugins-gmv\n  urd: aura-plugins-umi\n---\n## UAT Questions and Responses\n\n### Plan Presentation\nQ: Does this plan meet your requirements for v1 MVP? (5 modules in scripts/aura_protocol/, 6 test files, typed enums + frozen dataclasses, Temporal workflow, integration interfaces)\nOptions: Accept plan as-is (Proceed to ratification and implementation. All requirements satisfied.), Accept with notes (Plan is good but I have minor feedback to incorporate.), Request changes (Plan needs revision before proceeding.)\nA: User asked clarifying question: 'Is the state_machine.py defined using Temporal FSM primitives, or is it defined separately?'\n\n### Clarification: State Machine Architecture\nQ: Does this separation (pure Python state machine + Temporal workflow wrapper) meet your requirements?\nOptions: Accept plan as-is (Separation makes sense. Proceed to ratification and implementation.), Accept with notes (Good approach, but I have additional feedback.), Use Temporal primitives (I'd rather the state machine use Temporal's native patterns directly.)\nA: Accept plan as-is — Separation makes sense. Proceed to ratification and implementation.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:17:00Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:17:00Z","labels":["aura:p5-user:s5-uat"]}
{"id":"aura-plugins-r1n","title":"SLICE-5-L1: Types — Temporal workflow types + search attrs + pyproject.toml","description":"---\nreferences:\n  slice: aura-plugins-lkz\n  impl_plan: aura-plugins-06g\n---\n## Scope\nDefine Temporal types: EpochInput, EpochResult, PhaseAdvanceSignal, ReviewVoteSignal (frozen dataclasses). Define search attribute keys. Update pyproject.toml with temporalio\u003e=1.9.0 and dev deps.\n\n## Files Owned\n- scripts/aura_protocol/workflow.py (type defs + search attrs)\n- pyproject.toml (MODIFY)\n\n## Acceptance Criteria\nGiven workflow.py when imported then all signal/query types importable should never import state_machine internals (only public API)","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:32:45Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:32:45Z","labels":["aura:p9-impl:s9-slice"]}
{"id":"aura-plugins-umi","title":"URD: Machine-executable aura protocol engine with Temporal orchestration","description":"---\nreferences:\n  request: aura-plugins-bj1\n  elicit: aura-plugins-gbr\n  related_epoch: aura-plugins-220\n  variant_rich_paper: Strüber et al. SPLC'19 (DOI: 10.1145/3336294.3336302)\n  agentfilter_project: ~/codebases/dayvidpham/agentfilter/\n  unified_schema_project: ~/dev/agent-data-leverage/unified-schema/\n  temporal_research: ~/codebases/dayvidpham/nix-openclaw-vm/docs/research/temporal*.Rmd\n  collaboration_protocol: ~/dev/agent-data-leverage/david-data-ingestion-typescript-pipeline/initial-collaboration-protocol.md\n  nlp_proposal: ~/dev/agent-data-leverage/david-data-ingestion-typescript-pipeline/nlp-project-proposal.md\n---\n\n## Requirements\n\n### R1: Machine-Executable 12-Phase Protocol (v1 MVP)\nExtend validate_schema.py to enforce workflow state transitions. Add a state machine (Python, Temporal SDK) that validates phase ordering, review consensus gates, and dependency chain integrity. Temporal provides durability, audit trail, and search attributes for forensic queryability.\n\n### R2: Schema.xml Runtime Context Injection (v2)\nParse schema.xml at agent startup and inject the relevant phase/role/constraint context into the agent's prompt. Single source of truth — eliminates SKILL.md drift. Constraints checked at injection time.\n\n### R3: Full Temporal Workflow Engine (v3)\nImplement the 12-phase protocol as Temporal workflows. Phases become workflows, handoffs become signals, constraints become activity guards. Agents orchestrated by Temporal rather than reading SKILL.md.\n\n### R4: Hybrid Schema Strategy\n- Core: Typed enums (Python newtype pattern) for universal fields (session_id, model_id, role, phase)\n- Deltas: Per-harness extension modules for harness-specific transcript fields\n- Feature guards: Cross-cutting constraints verified by SAT solver (z3 or python-sat)\n- Matches unified-schema's existing BCNF approach but extends it for the aura protocol dimensions\n\n### R5: A2A/MCP Type Compliance\n- Adopt A2A Part discriminated union (TextPart/FilePart/DataPart) for content representation\n- Adopt MCP ToolUseContent/ToolResultContent for tool call representation\n- Adopt A2A TaskState enum as superset of all protocol lifecycle states\n- Extend with: reasoning field (ACP TrajectoryMetadata), source field (harness+model), tool/system roles\n- Use models.dev {provider_id}/{model_id} for stable model identifiers\n\n### R6: Integration Interfaces (End Vision)\nDefine interfaces that bridge:\n- aura-plugins (protocol definition + constraint enforcement)\n- unified-schema (transcript ingestion + analytics — NOT modified by us)\n- agentfilter (security filtering — NOT modified by us)\n- nix-openclaw-vm (Temporal runtime — eventual execution backend)\n\n### R7: Python-Only in aura-plugins\nAll code in aura-plugins must be Python. Temporal Python SDK for workflow engine. No Go in this repo (Go lives in unified-schema and nix-openclaw-vm).\n\n### R8: Beads Coordination (Transitional)\nBeads (bd CLI) remains the inter-agent task coordination mechanism for now. Eventually superseded by our own solution using the APIs we develop. The orchestration layer must integrate with beads, not replace it prematurely.\n\n## Priorities (User-Stated)\n1. v1 MVP: Constraint validator + state machine with Temporal (Python SDK)\n2. Cross-project integration interfaces (define, don't implement outside aura-plugins)\n3. A2A/MCP type compliance for future interop\n4. Hybrid schema for variant-rich harness support\n\n## Design Choices (From Elicitation)\n- Temporal throughout all versions (Python SDK)\n- unified-schema team owns SessionEntry DB schema (we don't modify)\n- Hybrid schema: typed enums (core) + deltas (harness-specific) + feature guards (cross-cutting)\n- Beads is transitional; Temporal audit trail is the long-term solution\n\n## MVP Goals (v1)\n1. Python state machine that models the 12-phase aura protocol transitions\n2. Temporal workflow that wraps the state machine with durable execution\n3. Constraint validators (extending validate_schema.py) that check runtime state\n4. Search attributes on Temporal for forensic queries (phase, role, agent, status)\n5. Integration interface definitions (Python protocols/ABCs) for unified-schema and agentfilter\n\n## End-Vision Goals\nCompletely auditable agent workflow engine for open-source development:\n- Agents orchestrated by Temporal workflows with durable state\n- schema.xml as single source of truth — runtime context injected, not read from SKILL.md\n- Cross-project integration: protocol enforcement (aura-plugins) + ingestion (unified-schema) + security (agentfilter) + execution (Temporal)\n- Open contribution: the orchestration APIs become the \"Application Document Interface\" for agent-native development\n- Audit trail: every phase transition, constraint check, handoff, and review decision is recorded in Temporal event history with search attributes","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T00:39:07Z","created_by":"David Huu Pham","updated_at":"2026-02-22T00:39:07Z","labels":["aura:p2-user:s2_2-urd","aura:urd"],"comments":[{"id":8,"issue_id":"aura-plugins-umi","author":"David Huu Pham","text":"Ratified: PROPOSAL-1 (aura-plugins-gmv) accepted. Scope: v1 MVP — 5 Python modules (types, state_machine, constraints, workflow, interfaces) with 6 test files. Pure Python state machine + Temporal workflow wrapper.","created_at":"2026-02-22T01:17:09Z"}]}
{"id":"aura-plugins-w28","title":"SLICE-3-L2: Tests — test_constraints.py (AC5, all C-* constraints)","description":"---\nreferences:\n  slice: aura-plugins-mrm\n  impl_plan: aura-plugins-06g\n---\n## Scope\nWrite test_constraints.py testing AC5 and all C-* constraint checks. Tests import from constraints.py and WILL FAIL until L3.\n\n## Files Owned\n- tests/test_constraints.py\n\n## Acceptance Criteria\nGiven test_constraints.py when run before L3 then tests fail should never pass without real constraint logic","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:32:41Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:32:41Z","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-w28","depends_on_id":"aura-plugins-eel","type":"blocks","created_at":"2026-02-21T17:32:41Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-wqw","title":"ELICIT: Release automation requirements","description":"---\nreferences:\n  request: aura-plugins-j2k\n---\n\n## URE Survey Results (Verbatim)\n\n### Q1: What semver bump types should the tool support?\n**Answer:** major, minor, patch (Recommended)\n\u003e Standard 3-level semver bumps (e.g., 0.2.2 → 0.3.0, 0.2.3, 1.0.0)\n\n### Q2: Should the tool also fix the current version drift (marketplace.json at 0.2.1)?\n**Answer:** Yes, fix as part of this feature (Recommended)\n\u003e The release tool's first run will sync all 3 files to the same version\n\n### Q3: What post-bump actions should the tool perform?\n**Answer:** Commit + tag (Recommended)\n\u003e Auto-commit the version files and create an annotated git tag (vX.Y.Z)\n\n### Q4: Should the tool include CHANGELOG generation?\n**Answer:** Yes, auto-generate\n\u003e Generate CHANGELOG.md from git log between tags (Keep a Changelog format)","status":"open","priority":2,"issue_type":"task","assignee":"architect","owner":"dayvidpham@gmail.com","created_at":"2026-02-21T20:10:23Z","created_by":"David Huu Pham","updated_at":"2026-02-21T20:10:23Z","labels":["aura:p2-user:s2_1-elicit"],"dependencies":[{"issue_id":"aura-plugins-wqw","depends_on_id":"aura-plugins-99q","type":"blocks","created_at":"2026-02-21T12:10:49Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-wux","title":"PROPOSAL-1: bin/aura-release — version bump, changelog, and tag tool","description":"---\nreferences:\n  request: aura-plugins-j2k\n  elicit: aura-plugins-wqw\n  urd: aura-plugins-99q\n---\n\n# PROPOSAL-1: bin/aura-release\n\n## Summary\n\nA single Python 3.10+ script (stdlib only) at bin/aura-release that:\n1. Bumps version across 3 manifest files\n2. Auto-generates CHANGELOG.md from git log\n3. Creates a commit and annotated git tag\n\n## Architecture\n\n### Single-file design\nFollowing the bin/aura-swarm and bin/aura-parallel convention:\n- Shebang: #!/usr/bin/env python3\n- argparse CLI, no external dependencies\n- ~300-400 lines estimated\n\n### Version file map\n\n| File | Field(s) | Parse method |\n|------|----------|-------------|\n| pyproject.toml | project.version (line ~3) | Regex on `version = \"X.Y.Z\"` |\n| .claude-plugin/plugin.json | .version | json.load/dump |\n| .claude-plugin/marketplace.json | .metadata.version + .plugins[0].version | json.load/dump |\n\nNote: plugins[1] (agentfilter) is never touched.\n\n### CLI interface\n\n```\nbin/aura-release \u003cmajor|minor|patch\u003e [options]\nbin/aura-release --check\n```\n\nOptions:\n- --dry-run: Show what would happen, change nothing\n- --sync: Align all files to pyproject.toml version before bumping\n- --no-changelog: Skip CHANGELOG generation\n- --no-commit: Skip git commit\n- --no-tag: Skip git tag creation\n\n### Workflow (happy path)\n\n1. Pre-flight checks:\n   - Not detached HEAD\n   - Working tree clean (allow .beads/ changes)\n   - All 3 version files have same version (or --sync used)\n2. Parse current version from pyproject.toml\n3. Compute new version (semver bump)\n4. Update 3 files (4 version fields total)\n5. Generate CHANGELOG.md entry:\n   - Find previous tag (or use root commit if none)\n   - Collect commits since last tag\n   - Group by conventional commit prefix (feat, fix, chore, refactor, etc.)\n   - Prepend new section to CHANGELOG.md (create if missing)\n   - Format: Keep a Changelog (https://keepachangelog.com)\n6. Stage files: pyproject.toml, plugin.json, marketplace.json, CHANGELOG.md\n7. Commit: \"chore: release vX.Y.Z\"\n8. Tag: annotated vX.Y.Z with message \"Release vX.Y.Z\"\n9. Print summary and remind user to push\n\n### Error recovery\n- If any step fails after file modification, restore files via git checkout\n- JSON files written with indent=2 to preserve formatting\n- TOML updated via regex to avoid adding a TOML library dependency\n\n### --check mode\nJust validates version consistency across all 3 files and exits with code 0 (consistent) or 1 (drift detected), printing the versions found.\n\n## Nix integration\n- flake.nix already wraps bin/* scripts → aura-release will auto-package\n- No version field in flake.nix → no changes needed there\n\n## Files to create/modify\n- bin/aura-release (NEW)\n- CHANGELOG.md (created on first release)\n\n## What this does NOT do\n- Push to remote (user does this manually)\n- Create GitHub releases (can be done later via gh release create)\n- Modify flake.nix or nix/hm-module.nix","status":"open","priority":2,"issue_type":"feature","assignee":"architect","owner":"dayvidpham@gmail.com","created_at":"2026-02-21T20:11:23Z","created_by":"David Huu Pham","updated_at":"2026-02-21T20:11:23Z","labels":["aura:p3-plan:s3-propose"],"dependencies":[{"issue_id":"aura-plugins-wux","depends_on_id":"aura-plugins-1ey","type":"blocks","created_at":"2026-02-21T12:13:28Z","created_by":"David Huu Pham","metadata":"{}"}]}
