"""Bootstrap codegen: generate draft Python source from SchemaSpec.

This is a ONE-TIME tool (UAT-1 hybrid approach). It generates a draft Python
source file that the developer reviews and selectively merges into types.py.

Public API:
    generate_types_source(spec: SchemaSpec) -> str

The output is valid Python source that can be parsed by ast.parse().
It contains:
- Enum class stubs for SubstepType, ExecutionMode, ContentLevel, ReviewAxis
- Dataclass stubs for all 9 new spec types
- Canonical dict stubs for all 6 new dicts
- A header comment explaining this is a generated draft

Design intent:
- Generate draft source; developer reviews and merges selectively
- Output must be valid Python (parseable by ast.parse)
- Does not modify types.py directly (safety: developer reviews first)
- Uses the SchemaSpec as the single source of truth for entity data
"""

from __future__ import annotations

import ast
import textwrap
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from aura_protocol.schema_parser import SchemaSpec


# ─── Internal helpers ─────────────────────────────────────────────────────────


def _repr_str(s: str) -> str:
    """Return a repr-safe string literal, handling embedded quotes."""
    return repr(s)


def _repr_tuple_of_strs(items: tuple[str, ...] | list[str]) -> str:
    if not items:
        return "()"
    if len(items) == 1:
        return f"({_repr_str(items[0])},)"
    inner = ", ".join(_repr_str(i) for i in items)
    return f"({inner},)"


def _indent(text: str, n: int = 4) -> str:
    return textwrap.indent(text, " " * n)


# ─── Section generators ────────────────────────────────────────────────────────


def _gen_header() -> str:
    return '''\
# ============================================================
# AUTO-GENERATED DRAFT — DO NOT COMMIT DIRECTLY
#
# This file was generated by scripts/aura_protocol/gen_types.py
# from skills/protocol/schema.xml.
#
# HOW TO USE:
#   1. Review the generated definitions below.
#   2. Copy/merge the definitions you want into types.py.
#   3. Run tests to verify correctness.
#   4. Do NOT commit this file to version control.
#
# This is a one-time bootstrap tool (UAT-1 hybrid approach).
# ============================================================

from __future__ import annotations

from dataclasses import dataclass
from enum import Enum
'''


def _gen_substep_type_enum(spec: "SchemaSpec") -> str:
    """Generate SubstepType enum from schema substep types."""
    types = sorted({s.type.value for s in spec.substep_specs.values()})
    lines = ["class SubstepType(str, Enum):"]
    lines.append('    """Substep type classification within a phase."""')
    lines.append("")
    for t in types:
        name = t.upper().replace("-", "_")
        lines.append(f"    {name} = {_repr_str(t)}")
    return "\n".join(lines)


def _gen_execution_mode_enum(spec: "SchemaSpec") -> str:
    """Generate ExecutionMode enum from schema execution modes."""
    # Collect distinct execution modes from substep specs
    modes = sorted({s.execution.value for s in spec.substep_specs.values()})
    lines = ["class ExecutionMode(str, Enum):"]
    lines.append('    """Substep execution mode within a phase."""')
    lines.append("")
    for mode in modes:
        name = mode.upper().replace("-", "_")
        lines.append(f"    {name} = {_repr_str(mode)}")
    return "\n".join(lines)


def _gen_content_level_enum(spec: "SchemaSpec") -> str:
    """Generate ContentLevel enum from handoff content levels."""
    # Collect distinct content levels from handoffs
    levels = sorted({h.content_level.value for h in spec.handoffs.values()})
    lines = ["class ContentLevel(str, Enum):"]
    lines.append('    """Handoff document content level."""')
    lines.append("")
    for level in levels:
        name = level.upper().replace("-", "_")
        lines.append(f"    {name} = {_repr_str(level)}")
    return "\n".join(lines)


def _gen_review_axis_enum(spec: "SchemaSpec") -> str:
    """Generate ReviewAxis enum from schema review axes."""
    letters = sorted(
        (ax.letter.value for ax in spec.review_axes.values()),
        key=lambda x: x,
    )
    lines = ["class ReviewAxis(str, Enum):"]
    lines.append('    """Review axis identifier letters."""')
    lines.append("")
    for letter in letters:
        lines.append(f"    {letter} = {_repr_str(letter)}")
    return "\n".join(lines)


def _gen_dataclass_stubs() -> str:
    """Generate frozen dataclass stubs for all 9 new spec types."""
    stubs = [
        textwrap.dedent("""\
            @dataclass(frozen=True)
            class SubstepSpec:
                \"\"\"Phase substep specification.\"\"\"
                id: str
                type: SubstepType
                execution: ExecutionMode
                order: int
                label_ref: str
                parallel_group: str | None = None
                description: str | None = None
        """),
        textwrap.dedent("""\
            @dataclass(frozen=True)
            class RoleSpec:
                \"\"\"Agent role specification.\"\"\"
                id: RoleId
                name: str
                description: str
                owned_phases: frozenset[PhaseId]
        """),
        textwrap.dedent("""\
            @dataclass(frozen=True)
            class DelegateSpec:
                \"\"\"Delegation relationship from epoch role to another role.\"\"\"
                to_role: RoleId
                phases: tuple[str, ...]
        """),
        textwrap.dedent("""\
            @dataclass(frozen=True)
            class CommandSpec:
                \"\"\"Protocol command (skill) specification.\"\"\"
                id: str
                name: str
                description: str
                role_ref: RoleId | None
                phases: tuple[str, ...]
                file: str
                creates_labels: tuple[str, ...]
        """),
        textwrap.dedent("""\
            @dataclass(frozen=True)
            class LabelSpec:
                \"\"\"Protocol label specification.\"\"\"
                id: str
                value: str
                special: bool
                phase_ref: str | None = None
                substep_ref: str | None = None
                severity_ref: str | None = None
                description: str | None = None
        """),
        textwrap.dedent("""\
            @dataclass(frozen=True)
            class ReviewAxisSpec:
                \"\"\"Code review axis specification.\"\"\"
                id: str
                letter: ReviewAxis
                name: str
                short: str
                key_questions: tuple[str, ...]
        """),
        textwrap.dedent("""\
            @dataclass(frozen=True)
            class TitleConvention:
                \"\"\"Task title naming convention.\"\"\"
                pattern: str
                label_ref: str
                created_by: str
                phase_ref: str | None = None
                extra_label_ref: str | None = None
                note: str | None = None
        """),
        textwrap.dedent("""\
            @dataclass(frozen=True)
            class ProcedureStep:
                \"\"\"Single step in a role procedure.\"\"\"
                order: int
                description: str
                next_state: PhaseId | None = None
        """),
        textwrap.dedent("""\
            @dataclass(frozen=True)
            class ConstraintContext:
                \"\"\"Context injection fragment for runtime constraint evaluation.\"\"\"
                id: str
                when: str
                then: str
        """),
    ]
    return "\n\n".join(stubs)


def _gen_role_specs_dict(spec: "SchemaSpec") -> str:
    """Generate ROLE_SPECS dict from spec.roles."""
    lines = ["ROLE_SPECS: dict[RoleId, RoleSpec] = {"]
    for role_id, role in sorted(spec.roles.items(), key=lambda x: x[0].value):
        phases_set = sorted(role.owned_phases, key=lambda p: p.value)
        phases_repr = "{" + ", ".join(f"PhaseId.{p.name}" for p in phases_set) + "}"
        lines.append(f"    RoleId.{role_id.name}: RoleSpec(")
        lines.append(f"        id=RoleId.{role_id.name},")
        lines.append(f"        name={_repr_str(role.name)},")
        lines.append(f"        description={_repr_str(role.description)},")
        lines.append(f"        owned_phases=frozenset({phases_repr}),")
        lines.append("    ),")
    lines.append("}")
    return "\n".join(lines)


def _gen_command_specs_dict(spec: "SchemaSpec") -> str:
    """Generate COMMAND_SPECS dict from spec.commands."""
    lines = ["COMMAND_SPECS: dict[str, CommandSpec] = {"]
    for cid, cmd in sorted(spec.commands.items()):
        role_ref_repr = (
            f"RoleId.{cmd.role_ref.name}" if cmd.role_ref is not None else "None"
        )
        lines.append(f"    {_repr_str(cid)}: CommandSpec(")
        lines.append(f"        id={_repr_str(cid)},")
        lines.append(f"        name={_repr_str(cmd.name)},")
        lines.append(f"        description={_repr_str(cmd.description)},")
        lines.append(f"        role_ref={role_ref_repr},")
        lines.append(f"        phases={_repr_tuple_of_strs(cmd.phases)},")
        lines.append(f"        file={_repr_str(cmd.file)},")
        lines.append(f"        creates_labels={_repr_tuple_of_strs(cmd.creates_labels)},")
        lines.append("    ),")
    lines.append("}")
    return "\n".join(lines)


def _gen_label_specs_dict(spec: "SchemaSpec") -> str:
    """Generate LABEL_SPECS dict from spec.labels."""
    lines = ["LABEL_SPECS: dict[str, LabelSpec] = {"]
    for lid, label in sorted(spec.labels.items()):
        lines.append(f"    {_repr_str(lid)}: LabelSpec(")
        lines.append(f"        id={_repr_str(lid)},")
        lines.append(f"        value={_repr_str(label.value)},")
        lines.append(f"        special={label.special},")
        if label.phase_ref is not None:
            lines.append(f"        phase_ref={_repr_str(label.phase_ref)},")
        if label.substep_ref is not None:
            lines.append(f"        substep_ref={_repr_str(label.substep_ref)},")
        if label.severity_ref is not None:
            lines.append(f"        severity_ref={_repr_str(label.severity_ref)},")
        if label.description is not None:
            lines.append(f"        description={_repr_str(label.description)},")
        lines.append("    ),")
    lines.append("}")
    return "\n".join(lines)


def _gen_review_axis_specs_dict(spec: "SchemaSpec") -> str:
    """Generate REVIEW_AXIS_SPECS dict from spec.review_axes."""
    lines = ["REVIEW_AXIS_SPECS: dict[str, ReviewAxisSpec] = {"]
    for aid, axis in sorted(spec.review_axes.items()):
        lines.append(f"    {_repr_str(aid)}: ReviewAxisSpec(")
        lines.append(f"        id={_repr_str(aid)},")
        lines.append(f"        letter=ReviewAxis.{axis.letter.name},")
        lines.append(f"        name={_repr_str(axis.name)},")
        lines.append(f"        short={_repr_str(axis.short)},")
        lines.append(f"        key_questions={_repr_tuple_of_strs(axis.key_questions)},")
        lines.append("    ),")
    lines.append("}")
    return "\n".join(lines)


def _gen_title_conventions_list(spec: "SchemaSpec") -> str:
    """Generate TITLE_CONVENTIONS list from spec.title_conventions."""
    lines = ["TITLE_CONVENTIONS: list[TitleConvention] = ["]
    for tc in spec.title_conventions:
        lines.append("    TitleConvention(")
        lines.append(f"        pattern={_repr_str(tc.pattern)},")
        lines.append(f"        label_ref={_repr_str(tc.label_ref)},")
        lines.append(f"        created_by={_repr_str(tc.created_by)},")
        if tc.phase_ref is not None:
            lines.append(f"        phase_ref={_repr_str(tc.phase_ref)},")
        if tc.extra_label_ref is not None:
            lines.append(f"        extra_label_ref={_repr_str(tc.extra_label_ref)},")
        if tc.note is not None:
            lines.append(f"        note={_repr_str(tc.note)},")
        lines.append("    ),")
    lines.append("]")
    return "\n".join(lines)


def _gen_procedure_steps_dict(spec: "SchemaSpec") -> str:
    """Generate PROCEDURE_STEPS dict from spec.procedure_steps."""
    lines = ["PROCEDURE_STEPS: dict[RoleId, tuple[ProcedureStep, ...]] = {"]
    for role_id in sorted(spec.procedure_steps.keys(), key=lambda r: r.value):
        steps = spec.procedure_steps[role_id]
        lines.append(f"    RoleId.{role_id.name}: (")
        for step in steps:
            if step.next_state is not None:
                lines.append(
                    f"        ProcedureStep(order={step.order}, "
                    f"description={_repr_str(step.description)}, "
                    f"next_state=PhaseId.{step.next_state.name}),"
                )
            else:
                lines.append(f"        ProcedureStep(order={step.order}, description={_repr_str(step.description)}),")
        lines.append("    ),")
    lines.append("}")
    return "\n".join(lines)


# ─── Public API ───────────────────────────────────────────────────────────────


def generate_types_source(spec: "SchemaSpec") -> str:
    """Generate draft Python source code from a parsed SchemaSpec.

    This is a one-time bootstrap tool (UAT-1). The output is valid Python
    source that can be parsed by ast.parse(). Developers review the output
    and selectively merge definitions into types.py.

    Args:
        spec: A fully parsed SchemaSpec from parse_schema().

    Returns:
        A string of valid Python source code containing:
        - Enum stubs for SubstepType, ExecutionMode, ContentLevel, ReviewAxis
        - Frozen dataclass stubs for all 9 new spec types
        - Populated canonical dicts: ROLE_SPECS, COMMAND_SPECS, LABEL_SPECS,
          REVIEW_AXIS_SPECS, TITLE_CONVENTIONS, PROCEDURE_STEPS

    Example::

        from pathlib import Path
        from aura_protocol.schema_parser import parse_schema
        from aura_protocol.gen_types import generate_types_source

        spec = parse_schema(Path("skills/protocol/schema.xml"))
        source = generate_types_source(spec)

        # Verify output is valid Python
        import ast
        ast.parse(source)  # Does not raise if valid

        # Write to review file
        Path("generated_types_draft.py").write_text(source)
    """
    sections = [
        _gen_header(),
        "# ─── Enums ────────────────────────────────────────────────────────────────────\n",
        _gen_substep_type_enum(spec),
        "",
        _gen_execution_mode_enum(spec),
        "",
        _gen_content_level_enum(spec),
        "",
        _gen_review_axis_enum(spec),
        "",
        "# ─── Frozen Dataclasses ───────────────────────────────────────────────────────\n",
        _gen_dataclass_stubs(),
        "# ─── Canonical Dicts ─────────────────────────────────────────────────────────\n",
        _gen_role_specs_dict(spec),
        "",
        _gen_command_specs_dict(spec),
        "",
        _gen_label_specs_dict(spec),
        "",
        _gen_review_axis_specs_dict(spec),
        "",
        _gen_title_conventions_list(spec),
        "",
        _gen_procedure_steps_dict(spec),
        "",
    ]
    source = "\n".join(sections)

    # Self-validate: output must be parseable Python
    try:
        ast.parse(source)
    except SyntaxError as e:
        raise ValueError(
            f"generate_types_source produced invalid Python: {e}. "
            f"This is a bug in gen_types.py. "
            f"Fix: inspect the generated source and correct the syntax error."
        ) from e

    return source
